# A0129650E
###### src\main\raijin\common\datatypes\Constants.java
``` java
  public static final String KEY_UNDO_HELP = "Ctrl + Z";
  public static final String KEY_UNDO_HELP_DESC = "Keyboard shortcut for Undo";
  
  public static final String KEY_REDO_HELP = "Ctrl + Y";
  public static final String KEY_REDO_HELP_DESC = "Keyboard shortcut for Redo";
   
  public static final String KEY_CLEAR_HELP = "Ctrl + R";
  public static final String KEY_CLEAR_HELP_DESC = "Keyboard shortcut for Clear";
  
  public static final String KEY_COPY_HELP = "Ctrl + C";
  public static final String KEY_COPY_HELP_DESC = "Keyboard shortcut for Copy";
  
  public static final String KEY_CUT_HELP = "Ctrl + X";
  public static final String KEY_CUT_HELP_DESC = "Keyboard shortcut for Cut";
 
  public static final String KEY_PASTE_HELP = "Ctrl + V";
  public static final String KEY_PASTE_HELP_DESC = "Keyboard shortcut for Paste";
  
  public static final String KEY_TAB_HELP = "tab";
  public static final String KEY_TAB_HELP_DESC = "Press to autocomplete your command";

  public static final String KEY_VIEW_DOWN_HELP = "F2";
  public static final String KEY_VIEW_DOWN_HELP_DESC = "Keyboard shortcut for to "
  		+ "toggle down between all, today, tomorrow and future pending tasks";
  
  public static final String KEY_VIEW_UP_HELP = "F1";
  public static final String KEY_VIEW_UP_HELP_DESC = "Keyboard shortcut for to "
	  		+ "toggle up between all, today, tomorrow and future pending tasks";
   
  public static final String KEY_MINMAX_HELP = "Alt + M";
  public static final String KEY_MINMAX_HELP_DESC = "To switch between simple and advanced mode";
 
  public static final String SCROLL_UP_HELP = "Pg Up";
  public static final String SCROLL_UP_HELP_DESC = "To scroll up the display panel";

  public static final String SCROLL_DOWN_HELP = "Pg Down";
  public static final String SCROLL_DOWN_HELP_DESC = "To scroll down the display panel";

```
###### src\main\raijin\common\eventbus\events\SetFailureEvent.java
``` java

package raijin.common.eventbus.events;

public class SetFailureEvent {

  public String output;

  public SetFailureEvent(String output) {
    this.output = output;
  }

}
```
###### src\main\raijin\logic\command\DeleteCommandRunner.java
``` java

package raijin.logic.command;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.TreeSet;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.UndoableRedoable;
import raijin.logic.parser.ParsedInput;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.TaskUtils;

public class DeleteCommandRunner extends CommandRunner implements  UndoableRedoable {

  TreeSet<Integer> idsToDelete = new TreeSet<Integer>();
  TreeSet<Integer> idsUndone = new TreeSet<Integer>();
  Queue<Integer> idsDeleted = new LinkedList<Integer>();
  Queue<Task> tasksDeleted = new LinkedList<Task>();
  String taskDescription;
  Task task;

  public Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {
    idsToDelete = input.getIds();
    taskDescription = "";
    
    if (idsToDelete.isEmpty()) {
      idsToDelete = getIdsFromTags(input.getTags());
    }

    while(!idsToDelete.isEmpty()) {
      int id = idsToDelete.pollFirst();
      try {
        this.task = tasksManager.getPendingTask(id);
        tasksDeleted.offer(task);
            
        tasksManager.deletePendingTask(id);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DELETE);
      }
      /*
      if (taskDescription == "" && idsToDelete.isEmpty()) {
        taskDescription = "\""+ task.getName() + "\"";
      } else if (!idsToDelete.isEmpty()) {
        taskDescription += "\""+ task.getName() +"\", ";
      } else {
        taskDescription += "& \""+ task.getName() +"\"";
      }*/
      
      taskDescription += String.format(Constants.FEEDBACK_DELETE_SUCCESS, task.getName())+"\n";
    }
    
    history.pushCommand(this);
    
    return new Status(taskDescription);
  }

  public void undo() {
    while (!tasksDeleted.isEmpty()) {
      task = tasksDeleted.poll();
      
      task.setId(idManager.getId());  
      idsUndone.add(task.getId());
      tasksManager.addPendingTask(task);
    }
  }

  public void redo() throws UnableToExecuteCommandException {
    while (!idsUndone.isEmpty()) {
      int id = idsUndone.pollFirst();
      idsDeleted.offer(id);
      try {
        task = tasksManager.getPendingTask(id);
        tasksDeleted.offer(task);
        tasksManager.deletePendingTask(id);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DELETE);
      }
    }
  }


  /**
   * Get id from filtered tasks when tag is chosen 
   * @param tags
   * @return
   */
  TreeSet<Integer> getIdsFromTags(TreeSet<String> tags) {
    List<Task> filtered = TaskUtils.filterTaskWithTags(tasksManager.getPendingTasks(), 
        tags);
    System.out.println(filtered.toString());
    return new TreeSet<Integer>(filtered.stream().map(
        t -> t.getId()).collect(Collectors.toList()));
  }

}
```
###### src\main\raijin\logic\command\DoneCommandRunner.java
``` java

package raijin.logic.command;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.TreeSet;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.TaskUtils;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.UndoableRedoable;
import raijin.logic.parser.ParsedInput;

public class DoneCommandRunner extends CommandRunner implements UndoableRedoable {
	TreeSet<Integer> idsToDone = new TreeSet<Integer>();
	TreeSet<Integer> idsUndone = new TreeSet<Integer>();
	Queue<Integer> idsDone = new LinkedList<Integer>();
	Queue<Task> tasksDone = new LinkedList<Task>();
	String taskDescription;
	Task task;
	
  public Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {   
	idsToDone = input.getIds();
	taskDescription = "";
	
	if (idsToDone.isEmpty()) {       //If no id specified, use tags
	  idsToDone = getIdsFromTags(input.getTags());
	}
	
	if (idsToDone.isEmpty()) {
      return new Status(Constants.FEEDBACK_DONE_FAILURE, false);
    }

	logger.debug(idsToDone.toString());
    
	while(!idsToDone.isEmpty()) {
	  int id = idsToDone.pollFirst();
	  idsDone.offer(id);
	  try {
	    this.task = tasksManager.getPendingTask(id);
	    tasksDone.offer(task);
	  } catch (NoSuchTaskException e) {
	    wrapLowerLevelException(e, Constants.Command.DONE);
	  }
	  
	  /*
	  if (taskDescription == "" && idsToDone.isEmpty()) {
        taskDescription = "\""+ task.getName() + "\"";
      } else if (!idsToDone.isEmpty()) {
        taskDescription += "\""+ task.getName() +"\", ";
      } else {
        taskDescription += "& \""+ task.getName() +"\"";
      } */

	  taskDescription += String.format(Constants.FEEDBACK_DONE_SUCCESS, task.getName())+"\n";
	  
	  tasksManager.addCompletedTask(task);
	  
	}
    
	history.pushCommand(this);
    
    return new Status(taskDescription);
  }

  public void undo() throws UnableToExecuteCommandException {
    while (!idsDone.isEmpty()) {
      try {
        int id = idsDone.poll();
        task = tasksDone.poll();

        tasksManager.deleteCompletedTask(id);
        
        task.setId(idManager.getId());
        idsUndone.add(task.getId());
        tasksManager.addPendingTask(task);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DONE);
      }
    }
  }

  public void redo() throws UnableToExecuteCommandException {
    while (!idsUndone.isEmpty()) {
      int id = idsUndone.pollFirst();
      idsDone.offer(id);
      try {
        task = tasksManager.getPendingTask(id);
        tasksDone.offer(task);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DONE);
      }
	  tasksManager.addCompletedTask(task);
    }
  }
  
  TreeSet<Integer> getIdsFromTags(TreeSet<String> tags) {
    List<Task> filtered = TaskUtils.filterTaskWithTags(tasksManager.getPendingTasks(), 
        tags);
    return new TreeSet<Integer>(filtered.stream().map(
        t -> t.getId()).collect(Collectors.toList()));
  }

}
```
###### src\main\raijin\logic\command\ExitCommandRunner.java
``` java

package raijin.logic.command;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.logic.api.CommandRunner;
import raijin.logic.parser.ParsedInput;

public class ExitCommandRunner extends CommandRunner {

  public Status processCommand(ParsedInput cmd) {
      session.writeOnExit();
	  return new Status(Constants.FEEDBACK_EXIT_SUCCESS);
  }

}
```
###### src\main\raijin\logic\command\HelpCommandRunner.java
``` java

package raijin.logic.command;

import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;

import raijin.common.datatypes.Status;
import raijin.logic.api.CommandRunner;
import raijin.logic.parser.ParsedInput;
import raijin.common.datatypes.Constants;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.eventbus.RaijinEventBus;

import javafx.stage.*;


public class HelpCommandRunner extends CommandRunner {
 
  public Status processCommand(ParsedInput cmd) {
	
    return new Status(Constants.FEEDBACK_HELP_COMMAND);
  }

}
```
###### src\main\raijin\ui\InputController.java
``` java

package raijin.ui;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.common.eventbus.Subscribe;

import edu.emory.mathcs.backport.java.util.Collections;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;
import javafx.scene.text.TextFlow;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.eventbus.MainSubscriber;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.KeyPressEvent;
import raijin.common.eventbus.events.ScrollEvent;
import raijin.common.eventbus.events.SetFailureEvent;
import raijin.common.eventbus.events.SetFeedbackEvent;
import raijin.common.eventbus.events.SetGuideEvent;
import raijin.common.eventbus.events.SetInputEvent;
import raijin.common.eventbus.events.SetTimeSlotEvent;
import raijin.common.eventbus.events.UndoRedoEvent;

public class InputController extends BorderPane {
  private static final String INPUT_COMMAND_BAR_LAYOUT_FXML =
		      "resource/layout/InputController.fxml";
  private static final String INPUT_FONT = "resource/styles/DejaVuSans.ttf";
	
  @FXML
  public TextField inputCommandBar;

  @FXML
  private Label feedbackBar;

  @FXML
  private TextFlow helpBar;
  
  @FXML
  public HBox timeSlot;
  
  @FXML
  private VBox feedbackVBox;

  private Raijin mainApp;
  private RaijinEventBus eventbus = RaijinEventBus.getInstance();
  
  /* Stores previously entered command */
  private ArrayList<String> commandHistory = new ArrayList<String>();
  private static int upCount = 0; // Count number of UP pressed
  private javafx.scene.input.Clipboard fxClipboard;

  private Font inputFont;

  public InputController(Raijin mainApp) throws IOException {
    FXMLLoader loader = new FXMLLoader(getClass().getResource(INPUT_COMMAND_BAR_LAYOUT_FXML));
    loader.setController(this);
    loader.setRoot(this);
    try {
      loader.load();
    } catch (IOException e) {
      e.printStackTrace();
    }

    this.mainApp = mainApp;
    this.setStyle("-fx-background-color:white;");
    
    Toolkit.getDefaultToolkit().getSystemClipboard();
    fxClipboard = javafx.scene.input.Clipboard.getSystemClipboard();
    
    setupStyles();
    handleAllEvents();
    
    helpBar.setVisible(false);
  }

  public TextField getCommandBar() {
    return inputCommandBar;
  }

  public void clear() {
    inputCommandBar.clear();
  }

  @FXML
  public void onKeyPress(KeyEvent event) {
    handleIOEvent(event);
    handleScrollEvent(event);
    if (Constants.KEY_MINMAX.match(event)) {
      mainApp.resizeWindow();
    } else if (Constants.KEY_CLEAR.match(event)) {
      clear();
    } else if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN) {
      getPreviousCommands(event);
      event.consume();
    } else {
      upCount = 0;
    }
    mainApp.handleKeyPress(this, event.getCode(), inputCommandBar.getText());
  }

  public void setFeedback(String text) {
    // feedbackBar.setTextFill(Color.BLACK);
    feedbackBar.setText(text);
  }

  public void setInput(String text) {
    inputCommandBar.setText(text);
    inputCommandBar.positionCaret(text.length());
  }

  void handleSetFeedbackEvent() {
    MainSubscriber<SetFeedbackEvent> feedbackSubscriber =
        new MainSubscriber<SetFeedbackEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetFeedbackEvent event) {
            feedbackBar.setTextFill(Color.BLACK);
            setFeedback(event.output);
          }
        };
  }

  void handleSetTimeSlotEvent() {
    MainSubscriber<SetTimeSlotEvent> timeSlotSubscriber =
        new MainSubscriber<SetTimeSlotEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetTimeSlotEvent event) {
            if (event.isVisible) {
              generateTimeSlots(event.busySlots);
              timeSlot.setVisible(true);
            } else {
              timeSlot.setVisible(false);
            }
          }
        };
  }

  void handleSetHelpEvent() {
    MainSubscriber<SetGuideEvent> helpSubscriber =
        new MainSubscriber<SetGuideEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetGuideEvent event) {
            if (event.isVisible) {
              helpBar.getChildren().clear();
              HelpMessage msg = new HelpMessage(event.commandFormat, event.description);
              helpBar.getChildren().addAll(msg.helpMessage);
              helpBar.setVisible(true);
            } else {
              helpBar.setVisible(false);
            }
          }
        };
  }

  public void setFailureFeedback(String text) {
    // feedbackBar.setTextFill(Color.RED);
    setFeedback(text);
  }

  void handleSetFailureEvent() {
    MainSubscriber<SetFailureEvent> failureSubscriber =
        new MainSubscriber<SetFailureEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetFailureEvent event) {
            feedbackBar.setTextFill(Color.RED);
            setFailureFeedback(event.output);
          }
        };
  }

  void handleSetInputEvent() {
    MainSubscriber<SetInputEvent> inputSubscriber = new MainSubscriber<
        SetInputEvent>(eventbus.getEventBus()) {

      @Subscribe
      @Override
      public void handleEvent(SetInputEvent event) {
        setInput(event.output);
      }
    };
  }

  void handleTabEvent() {
    inputCommandBar.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
      if (event.getCode() == KeyCode.TAB) {
        eventbus.post(event);
        event.consume();
      }
    });
  }

  void handleHelpBar() {
    helpBar.visibleProperty().addListener(new ChangeListener<Boolean>() {

      @Override
      public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {
        if (t1.booleanValue()) { // If maximized
          helpBar.setMaxSize(inputCommandBar.getMaxWidth(), 
              inputCommandBar.getMaxHeight());
        } else {
          /*
          helpBar.setMaxSize(0, 0);
          helpBar.setMinSize(0, 0);
          */
          helpBar.getChildren().clear();
        }
      }
    });
  }

  void handleTimeSlot() {
    timeSlot.visibleProperty().addListener(new ChangeListener<Boolean>() {

      @Override
      public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {
        if (t1.booleanValue()) { // If maximized
          /*
          timeSlot.setMaxSize(inputCommandBar.getMaxWidth(), 
              timeSlot.getMaxHeight());
              */
          feedbackVBox.getChildren().clear();
          feedbackVBox.getChildren().addAll(feedbackBar, timeSlot);
        } else {
          /*
          timeSlot.setMaxSize(0, 0);
          timeSlot.setMinSize(0, 0);
          */
          feedbackVBox.getChildren().clear();
          feedbackVBox.getChildren().add(feedbackBar);
        }
      }
    });
  }

  /* This is needed because TextArea is not updated till keypress is shot */
  void handleKeyReleaseEvent() {
    inputCommandBar.setOnKeyReleased(new EventHandler<KeyEvent>() {

      @Override
      public void handle(KeyEvent event) {
        if (Constants.KEY_UNDO.match(event)) {
          eventbus.post(new UndoRedoEvent(true, false));
          event.consume();
        } else if (Constants.KEY_REDO.match(event)) {
          eventbus.post(new UndoRedoEvent(false, true));
          event.consume();
        } else {
          String userInput = inputCommandBar.getText();
          eventbus.post(new KeyPressEvent(event, userInput));
        }
        event.consume();
      }

    });
  }

  void handleAllEvents() {
    handleHelpBar();
    handleTimeSlot();
    handleSetTimeSlotEvent();
    handleSetHelpEvent();
    handleTabEvent();
    handleSetFailureEvent();
    handleSetFeedbackEvent();
    handleSetInputEvent();
    handleKeyReleaseEvent();
  }

  public void updateCommandHistory(String command) {
    commandHistory.add(command);
  }

  void getPreviousCommands(KeyEvent event) {
    int index;
    if (!commandHistory.isEmpty()) {
      if (event.getCode() == KeyCode.UP) {
        index = Math.floorMod((commandHistory.size() - (++upCount)), commandHistory.size());
      } else {
        index = Math.floorMod((commandHistory.size() - (--upCount)), commandHistory.size());
      }
      setInput(commandHistory.get(index));
    }
  }

  /**
   * Handles copy, cut, and paste operation
   * 
   * @param event
   */
  void handleIOEvent(KeyEvent event) {
    if (Constants.KEY_COPY.match(event)) {
      copyToClipboard(false);
    } else if (Constants.KEY_PASTE.match(event)) {
      getClipboardContent();
      event.consume();
    } else if (Constants.KEY_CUT.match(event)) {
      copyToClipboard(true);
    }
  }

  /**
   * Handles scroll event using keyboard
   * 
   * @param event
   */
  void handleScrollEvent(KeyEvent event) {
    if (Constants.SCROLL_UP.match(event)) {
      eventbus.post(new ScrollEvent(-1));
      event.consume();
    } else if (Constants.SCROLL_DOWN.match(event)) {
      eventbus.post(new ScrollEvent(1));
      event.consume();
    }
  }

  /**
   * Handles cut and copy operation
   * 
   * @param isCut determines whether selected text will be removed
   */
  public void copyToClipboard(boolean isCut) {
    /*
     * ClipboardContent content = new ClipboardContent();
     * content.putString(inputCommandBar.getSelectedText()); fxClipboard.setContent(content);
     */
    if (isCut) {
      inputCommandBar.cut();
    } else {
      inputCommandBar.copy();
    }
  }

  void getClipboardContent() {
    String data; // To be displayed message
    if (fxClipboard.hasString()) {
      data = fxClipboard.getString();
      int caretPosition = inputCommandBar.getCaretPosition();
      inputCommandBar.insertText(caretPosition, data);
    }
  }
  
  void generateTimeSlots(List<DateTime> slots) {
    timeSlot.getChildren().clear();
    Label intro = new Label("You are busy from: ");
    intro.setTextAlignment(TextAlignment.CENTER);
    intro.setPadding(new Insets(5, 5, 5, 5));
    intro.setStyle("-fx-font-size: 14");
    timeSlot.getChildren().add(intro);
    Collections.sort(slots);

    for (DateTime slot : slots) {
      timeSlot.getChildren().add(createTimeSlot(slot));
    }
  }

  Label createTimeSlot(DateTime slot) {
    String startTime = slot.getStartTime().toString();
    String endTime = slot.getEndTime().toString();
    String duration = startTime + " ~ " + endTime;
    Label timeSlot = new Label(duration);
    timeSlot.setPadding(new Insets(5, 5, 5, 5));
    timeSlot.setStyle("-fx-font-size: 14; -fx-background-color: #FF8000; "
        + "-fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5;");
    return timeSlot;
  }

  void setupStyles() {
    inputFont = Font.loadFont(getClass().getResource(INPUT_FONT).toString(), 18);
    inputCommandBar.setFont(inputFont);
  }

}
```
###### src\main\raijin\ui\Raijin.java
``` java

package raijin.ui;

import java.awt.AWTException;
import java.awt.Image;

import javafx.scene.image.*;

import java.awt.SystemTray;
import java.awt.TrayIcon;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.ImageIcon;

import org.jnativehook.GlobalScreen;
import org.jnativehook.NativeInputEvent;
import org.jnativehook.keyboard.NativeKeyEvent;
import org.jnativehook.keyboard.NativeKeyListener;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.control.ListView;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.text.TextFlow;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.WindowEvent;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.eventbus.events.SetFailureEvent;
import raijin.common.eventbus.events.SetFeedbackEvent;
import raijin.logic.api.Logic;

public class Raijin extends Application implements NativeKeyListener {
  
  //===========================================
  // Variables used in Raijin
  //===========================================
	
  //location of files used
  private static final String ROOT_LAYOUT_FXML_LOCATION = "resource/layout/RootLayout.fxml";
  private static final String TRAY_ICON_LOCATION = "resource/styles/raijin2.png";
  private static final String CSS_LOCATION = "resource/styles/RaijinStyle.css";
  private static final String CSS_LOCATION_HELP = "resource/styles/Help.css";
  /*
   * code eventually unused because images were not clear;
  private static final String HELP_ADD = "resource/styles/helpAdd.jpg";
  private static final String HELP_DELETE = "resource/styles/helpDelete.jpg";
  private static final String HELP_DISPLAY = "resource/styles/helpDisplay.jpg";
  private static final String HELP_DONE = "resource/styles/helpDone.jpg";
  private static final String HELP_EDIT = "resource/styles/helpEdit.jpg";
  private static final String HELP_SEARCH  = "resource/styles/helpSearch.jpg";
  private static final String HELP_SET = "resource/styles/helpSet.jpg";
  private static final String HELP_UNDOREDO = "resource/styles/helpUndoRedo.jpg";
  private static final String KEYBOARD_SHORTCUTS = "resource/styles/keyboardShort.jpg";
  private static final String[] helpImg = {"resource/styles/helpAdd.jpg",
		  "resource/styles/helpDelete.jpg",
		  "resource/styles/helpDisplay.jpg",
		  "resource/styles/helpDone.jpg",
		  "resource/styles/helpEdit.jpg",
		  "resource/styles/helpSearch.jpg",
		  "resource/styles/helpSet.jpg",
		  "resource/styles/helpUndoRedo.jpg",
		  "resource/styles/keyboardShort.jpg"};	
  */
  
  private static final double MIN_WIDTH = 600.0; // width values for stage
  private static final double MIN_HEIGTH = 650.0; // height values for stage
  private double dragX = 0; // values for dragging of help pane
  private double dragY = 0;
  
  static boolean isVisible = false; // boolean that checks if Raijin is currently being shown
  static boolean isHelpOn = false; // boolean that checks if help is currently being shown
  
  private SystemTray tray;
  final TrayIcon trayIcon = new TrayIcon(createImage(TRAY_ICON_LOCATION), "Raijin.java", null);
  
  BorderPane rootLayout, introLayout, inputController, displayController,
      sidebarController;
  
  private HBox hBox;
  private static Stage stage;
private Stage helpStage;
  private Logic logic;
  private RaijinEventBus eventbus = RaijinEventBus.getInstance();
  
  @FXML
  private TextFlow helpBar = new TextFlow();
  @FXML
  ListView<TextFlow> helpContain;
  
  //===========================================
  //Start of Raijin UI Methods
  //===========================================
  public static void main(String[] args) {
    launch(args);
  }

  public static Stage getStage() {
    return stage;
  }

  @Override
  public void start(Stage stage) throws Exception {
    /* Adding fxml */
	initPrimaryStage(stage);
    initLogic();
    setUpVariables();
    decideScene();
    bringUpHelpSection(); //set up help
    makeTray(stage); // listen out for any ctrl-h events
    Platform.setImplicitExit(false);

    GlobalScreen.registerNativeHook();
    GlobalScreen.addNativeKeyListener(this);
    turnOffLogger(); // Turn off JNativeHook Logging

    changeToMinimisedView();

    this.stage.show();
    this.isVisible = true;

    /*
     * this.stage.widthProperty().greaterThan(add750).addListener((obs, oldValue, newValue) -> { if
     * (!newValue) { changeToMinimisedView(); } else { changeToMaximisedView(); } });
     */

    handleMaximized();                      // Handle simple & advanced mode
    handleWindowResize();                   // Handle window resize
    stage.setOnCloseRequest(new EventHandler<WindowEvent>() {
      public void handle(WindowEvent we) {
        logic.executeCommand("exit");
        System.exit(0);
      }
    });

  }

  private void initPrimaryStage(Stage stage) {
    this.stage = stage;
    this.stage.getIcons().add(new javafx.scene.image.Image(getClass().getResourceAsStream(TRAY_ICON_LOCATION)));
    this.stage.setTitle("Welcome to Raijin");
    this.stage.setMinWidth(MIN_WIDTH);
    this.stage.setMinHeight(MIN_HEIGTH);
  }

  private void initLogic() throws FileNotFoundException {
    logic = new Logic();
  }

  private void setUpVariables() throws IOException {
	this.hBox = new HBox();
	hBox.setMaxWidth(Double.MAX_VALUE);
	    
	this.inputController = new InputController(this);
	((InputController) inputController).timeSlot.setVisible(false);
	    
	this.displayController = new DisplayController();
	this.sidebarController = new SidebarController(this.logic);
	    
	String CSS = getClass().getResource(CSS_LOCATION).toExternalForm();
	displayController.getStylesheets().add(CSS);
  }
  
  public void decideScene() {
	initRootLayout();
	changeToMinimisedView();
	this.stage.setScene(new Scene(rootLayout));
  }
  
  private void initRootLayout() {
	FXMLLoader loader = new FXMLLoader(getClass().getResource(ROOT_LAYOUT_FXML_LOCATION));
	try {
	  rootLayout = loader.load();
	} catch (IOException e) {
	  e.printStackTrace();
	}
 }
  
  public void changeToMinimisedView() {
    rootLayout.setCenter(displayController);
    rootLayout.setBottom(inputController);
    setFocusAtCommandBar();
  }

  private void changeToMaximisedView() {
    hBox.getChildren().clear();
    hBox.getChildren().addAll(sidebarController, displayController);
    rootLayout.setCenter(hBox);
    rootLayout.setBottom(inputController);
    setFocusAtCommandBar();
  }

  // =========================================
  // Methods to transfer to logic
  // =========================================

  public void handleKeyPress(InputController inputController, KeyCode key, String userInput) {
    if (key == KeyCode.ENTER) {
      inputController.updateCommandHistory(userInput); // Update list of user input
      inputController.clear();
      handleEnterPress(inputController, userInput);
    } else if (key == KeyCode.ESCAPE) {
      logic.loadCustomData(inputController.inputCommandBar.getText().trim());
    }
  }

  public void handleWindowResize() {
    stage.widthProperty().addListener(new ChangeListener<Number>() {

      @Override
      public void changed(ObservableValue<? extends Number> observable, Number oldValue,
          Number newValue) {
        eventbus.post(new SetCurrentDisplayEvent(eventbus.getDisplayedTasks()));
        
      }});
  }

  private void handleEnterPress(InputController inputController, String userInput) {
    Status result = logic.executeCommand(userInput);
    Boolean isSuccessful = result.isSuccess();
    String response = result.getFeedback();
    
    if (response.equals(Constants.FEEDBACK_EXIT_SUCCESS)) {
      System.exit(0);
    } else if (response.equals(Constants.FEEDBACK_HELP_COMMAND) && !isHelpOn) {
      isHelpOn = true;
      helpStage.show();	
  	} else if (response.equals(Constants.FEEDBACK_HELP_COMMAND)) {
  		isHelpOn = false;
  		helpStage.hide();
  	} else if (!isSuccessful) {
      eventbus.post(new SetFailureEvent(response));
    } else {
      eventbus.post(new SetFeedbackEvent(response));
    }
  }
  
  private void bringUpHelpSection() {
	  helpStage = new Stage();	  
	  StackPane helpBase = new StackPane();
	  initiateHelpBase(helpBase);
	  
	  helpContain = new ListView<TextFlow>();
	  
	  setUpHelpStage();
	  
	  ArrayList<String> allCommand = new ArrayList<String>();
	  addToAllCommandArray(allCommand);
	  
	  ArrayList<String> allDescription = new ArrayList<String>();
	  addToAllDescription(allDescription);

	  addAllMessagesToHelpDisplay(allCommand, allDescription);
	  
	  helpContain.setOnMouseDragged(new EventHandler<MouseEvent>() {
	         public void handle (MouseEvent me) {   
	        	 helpStage.setX(me.getScreenX() - dragX);
	             helpStage.setY(me.getScreenY() - dragY);
	         }
	      });
	  
	  helpContain.setOnMousePressed(new EventHandler<MouseEvent>() {
	  		public void handle (MouseEvent me) {
            dragX = me.getScreenX() - helpStage.getX();
            dragY = me.getScreenY() - helpStage.getY();
         }
      });
	  
	  Scene dialogScene = new Scene(helpBase, 800, 600);
	  
	  helpBase.getChildren().add(helpContain);
      
	  helpStage.setScene(dialogScene);
  }

  private void initiateHelpBase(StackPane helpBase) {
	  String CSS_HELP = getClass().getResource(CSS_LOCATION_HELP).toExternalForm();
	  helpBase.getStylesheets().add(CSS_HELP);
  }

  private void addAllMessagesToHelpDisplay(ArrayList<String> allCommand, 
		  			                       ArrayList<String> allDescription) {
	HelpMessage helpHeader = new HelpMessage("Help\n");
	helpBar.getChildren().addAll(helpHeader.helpMessage);
	  
	  for (int cmdAndDescripFormatId = 1; 
		       cmdAndDescripFormatId < allCommand.size(); 
			   cmdAndDescripFormatId++) {
		  if (allCommand.get(cmdAndDescripFormatId).equals("Keyboard Shortcuts")) {
			  HelpMessage keyboardHeader = new HelpMessage("Keyboard Shortcuts\n");
			  helpBar.getChildren().addAll(keyboardHeader.helpMessage);
		  } else {
			  HelpMessage fullMessage = new HelpMessage(allCommand.get(cmdAndDescripFormatId), 
					  									allDescription.get(cmdAndDescripFormatId));
			  helpBar.getChildren().addAll(fullMessage.helpMessage);  
		  }
     }
	  
	  helpContain.setItems(FXCollections.observableArrayList(helpBar));
  }

  private void setUpHelpStage() {
	  helpStage.initStyle(StageStyle.TRANSPARENT);
	  helpStage.initModality(Modality.NONE);
	  helpStage.initOwner(stage);
  }

  private void addToAllDescription(ArrayList<String> allDescription) {
	  allDescription.add(Constants.ADD_FLOATING_DESC + "\n\n");
	  allDescription.add(Constants.ADD_SPECIFIC_DESC + "\n\n");
	  allDescription.add(Constants.ADD_EVENT_SAME_DATE_DESC + "\n\n");
	  allDescription.add(Constants.ADD_EVENT_DIFFERENT_DATE_DESC + "\n\n");
	  allDescription.add(Constants.ADD_BATCH_DESC + "\n\n");
	  allDescription.add(Constants.EDIT_DESC + "\n\n");
	  allDescription.add(Constants.DISPLAY_DESC + "\n\n");
	  allDescription.add(Constants.DONE_DESC + "\n\n");
	  allDescription.add(Constants.DELETE_DESC + "\n\n");
	  allDescription.add(Constants.UNDO_DESC + "\n\n");
	  allDescription.add(Constants.REDO_DESC + "\n\n");
	  allDescription.add(Constants.SEARCH_DESC + "\n\n");
	  allDescription.add(Constants.SET_DESC + "\n\n");
	 
	  allDescription.add("  \n");
	  
	  allDescription.add(Constants.KEY_UNDO_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_REDO_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_CLEAR_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_COPY_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_CUT_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_PASTE_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_TAB_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_VIEW_DOWN_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_VIEW_UP_HELP_DESC + "\n\n");
	  allDescription.add(Constants.KEY_MINMAX_HELP_DESC + "\n\n");
	  allDescription.add(Constants.SCROLL_UP_HELP_DESC + "\n\n");
	  allDescription.add(Constants.SCROLL_DOWN_HELP_DESC + "\n\n");
  }

  private void addToAllCommandArray(ArrayList<String> allCommand) {
	  allCommand.add(Constants.ADD_FLOATING);
	  allCommand.add(Constants.ADD_SPECIFIC);
	  allCommand.add(Constants.ADD_EVENT_SAME_DATE);
	  allCommand.add(Constants.ADD_EVENT_DIFFERENT_DATE);
	  allCommand.add(Constants.ADD_BATCH);
	  allCommand.add(Constants.EDIT_FORMAT);
	  allCommand.add(Constants.DISPLAY_FORMAT);
	  allCommand.add(Constants.DONE_FORMAT);
	  allCommand.add(Constants.DELETE_FORMAT);
	  allCommand.add(Constants.UNDO_FORMAT);
	  allCommand.add(Constants.REDO_FORMAT);
	  allCommand.add(Constants.SEARCH_FORMAT);
	  allCommand.add(Constants.SET_FORMAT);
	 
	  allCommand.add("Keyboard Shortcuts");
	  
	  allCommand.add(Constants.KEY_UNDO_HELP);
	  allCommand.add(Constants.KEY_REDO_HELP);
	  allCommand.add(Constants.KEY_CLEAR_HELP);
	  allCommand.add(Constants.KEY_COPY_HELP);
	  allCommand.add(Constants.KEY_CUT_HELP);
	  allCommand.add(Constants.KEY_PASTE_HELP);
	  allCommand.add(Constants.KEY_TAB_HELP);
	  allCommand.add(Constants.KEY_VIEW_DOWN_HELP);
	  allCommand.add(Constants.KEY_VIEW_UP_HELP);
	  allCommand.add(Constants.KEY_MINMAX_HELP);
	  allCommand.add(Constants.SCROLL_UP_HELP);
	  allCommand.add(Constants.SCROLL_DOWN_HELP);
  }
  
  // ============================================
  // Methods for Eventbus
  // ============================================

  // Setting up Activate and Hide
  public void makeTray(final Stage stage) {
	  if (!SystemTray.isSupported()) {
		Status result = new Status("Looks like you don't have System Tray on your Operating System!:(",
									false);
	    String response = result.getFeedback();   
	    eventbus.post(new SetFailureEvent(response));
	  }

	  this.tray = SystemTray.getSystemTray();

	  trayIcon.setImageAutoSize(true);
  }

  private void hide(final Stage stage) {
	  Platform.runLater(new Runnable() {
		  @Override
	      public void run() {
	        if (SystemTray.isSupported()) {
	          stage.hide();
	        } else {
	          System.exit(0);
	        }
	      }
	  });
  }

  protected static Image createImage(String path) {
	    URL imageUrl = Raijin.class.getResource(path);
	
	    if (imageUrl == null) {
	      System.err.println("no image found: " + path);
	      return null;
	    } else {
	      return (new ImageIcon(imageUrl)).getImage();
	    }
  }

  @Override
  public void nativeKeyPressed(NativeKeyEvent arg0) {
	    // Enable user to start typing whenever the application is open
	    if (isVisible) {
	      Platform.runLater(new Runnable() {
	        @Override
	        public void run() {
	          setFocusAtCommandBar();
	        }
	      });
	    }

	    boolean isCtrlSpacePressed =
	        arg0.getKeyCode() == NativeKeyEvent.VC_SPACE
	            && NativeInputEvent.getModifiersText(arg0.getModifiers()).equals("Ctrl");
	
	    boolean isCtrlHPressed =
	        arg0.getKeyCode() == NativeKeyEvent.VC_H
	            && NativeInputEvent.getModifiersText(arg0.getModifiers()).equals("Ctrl");
	    
	    if (isCtrlSpacePressed && isVisible) { // for hide feature: to hide the program
	      hide(stage);
	      try {
	        tray.add(trayIcon);
	      } catch (AWTException e) {
	        System.out.println("TrayIcon could not be added.");
	      }
	      isVisible = false;
	    } else if (isCtrlSpacePressed) { // for hide feature: to bring up the program
	      Platform.runLater(new Runnable() {
	        @Override
	        public void run() {
	          stage.show();
	          tray.remove(trayIcon);
	        }
	      });
	      isVisible = true;
	    } else if(isCtrlHPressed && !isHelpOn) { // for help feature: to bring up the help menu
	    	isHelpOn = true;
	    	Platform.runLater(new Runnable() {
	            @Override
	            public void run() {
	            	helpStage.show();
	            }
	          });
	    } else if(isCtrlHPressed && isHelpOn) { // for help feature: to hide the help menu
	    	isHelpOn = false;
	    	hide(helpStage);
	    }
  }
 
  void setFocusAtCommandBar() {
    ((InputController) rootLayout.getBottom()).getCommandBar().requestFocus();
  }
  
  //compulsory & unremovable methods from jnativehook library
  @Override
  public void nativeKeyReleased(NativeKeyEvent arg0) {

  }
  
  //compulsory & unremovable methods from jnativehook library
  @Override
  public void nativeKeyTyped(NativeKeyEvent arg0) {
    // TODO Auto-generated method stub

  }

  void turnOffLogger() { //turn off jnativehook logger
    Logger logger = Logger.getLogger(GlobalScreen.class.getPackage().getName());
    logger.setLevel(Level.OFF);
  }

  void handleMaximized() {
    stage.maximizedProperty().addListener(new ChangeListener<Boolean>() {

      @Override
      public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {
        if (t1.booleanValue()) { // If maximized
          changeToMaximisedView();
        } else {
          changeToMinimisedView();
        }
      }
    });
  }

  //Toggle between minimize and maximize mode
  public void resizeWindow() {
    if (stage.isMaximized()) {
      stage.setMaximized(false);
    } else {
      stage.setMaximized(true);
    }
  }
  
  public void testTwoImage() {
    javafx.scene.image.Image fximg = new javafx.scene.image.Image("nonsense");
  }
}
```
###### src\main\raijin\ui\resource\layout\InputController.fxml
``` fxml

<?import javafx.scene.shape.*?>
<?import javafx.scene.image.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.text.*?>

<fx:root id="inputControllerBorderPane" opacity="1.0" prefHeight="82.0" prefWidth="271.0" type="BorderPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
  <center>
    <TextField fx:id="inputCommandBar" onKeyPressed="#onKeyPress" prefWidth="-1.0" promptText="What would you like to do?">
      <BorderPane.margin>
        <Insets bottom="5.0" left="5.0" right="5.0" />
      </BorderPane.margin>
         <font>
            <Font name="System Bold" size="18.0" />
         </font>
    </TextField>
  </center>
  <top>
      <VBox fx:id="feedbackVBox" alignment="CENTER">
         <children>
          <Label fx:id="feedbackBar" alignment="CENTER" focusTraversable="false" maxHeight="22.0" textFill="BLACK" BorderPane.alignment="CENTER">
            <font>
              <Font size="16.0" />
            </font>
            <BorderPane.margin>
              <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
            </BorderPane.margin>
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
          </Label>
            <HBox fx:id="timeSlot" prefHeight="33.0" prefWidth="271.0" spacing="5.0" style="-fx-border-width: 2; -fx-border-color: #eeeeee;">
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
               <padding>
                  <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
               </padding></HBox>
         </children>
      </VBox>
  </top>
   <bottom>
      <TextFlow fx:id="helpBar" lineSpacing="1.15" prefHeight="50.0" prefWidth="271.0" style="-fx-background-color: #333332;" BorderPane.alignment="CENTER" VBox.vgrow="ALWAYS">
         <padding>
            <Insets bottom="5.0" left="15.0" right="5.0" top="5.0" />
         </padding>
      </TextFlow>
   </bottom>
</fx:root>
```
###### src\main\raijin\ui\resource\layout\IntroLayout.fxml
``` fxml
This class is not used anymore because we decided
to go full keyboard in our program. This class
will make user do some clicking in order to set 
his directory. 
-->
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>

<fx:root type="BorderPane" prefHeight="700.0" prefWidth="750.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2">
  <center>
    <VBox alignment="CENTER" prefHeight="500.0" prefWidth="500.0">
      <children>
        <Label contentDisplay="CENTER" text="${'Hi, welcome to Raijin!\nPlease select the folder you wish to store your tasks at.'}" textAlignment="CENTER" wrapText="true">
          <VBox.margin>
            <Insets bottom="50.0" left="10.0" right="10.0" />
          </VBox.margin>
        </Label>
        <Button contentDisplay="CENTER" mnemonicParsing="false" onAction="#handleGettingStartedAction" text="Get Started!" textAlignment="CENTER" />
      </children>
    </VBox>
  </center>
</fx:root>
```
###### src\main\raijin\ui\resource\layout\RootLayout.fxml
``` fxml
<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<BorderPane bottom="$null" prefHeight="700.0" prefWidth="750.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" />
```
###### src\main\raijin\ui\resource\styles\Help.css
``` css

.list-cell, .list-cell:empty, .list-cell:even, .list-cell:odd {
	-fx-background-color: #333332;
}

.list-cell:selected .label{
	-fx-text-fill: black;
}
```
###### src\test\raijin\logic\command\DeleteCommandRunnerTest.java
``` java

  @Before
  public void setUp() throws Exception {
    addCommandRunner = new AddCommandRunner();
    deleteCommandRunner = new DeleteCommandRunner();
    tasksManager = TasksManager.getManager();
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
    addTask("Ice ice baby", new DateTime("31/08/2015"));
  }

  @Test
  public void processCommand_DeleteTask() throws UnableToExecuteCommandException {
    Status returnStatus = deleteTask(1);
    String expectedStatusLine = String.format
        (Constants.FEEDBACK_DELETE_SUCCESS, "Ice ice baby") +"\n";
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
  }

  @Test
  public void undo_DeleteTask() throws UnableToExecuteCommandException {
    deleteTask(1);
    deleteCommandRunner.undo();
    assertTrue(!tasksManager.isEmptyPendingTasks());
  }

  @Test
  public void redo_DeleteTask() throws UnableToExecuteCommandException, NoSuchTaskException {
    deleteTask(1);
    deleteCommandRunner.undo();
    deleteCommandRunner.redo();
    assertTrue(tasksManager.isEmptyPendingTasks());
  }

```
###### src\test\raijin\logic\command\DoneCommandRunnerTest.java
``` java
  
  @Before
  public void setUp() throws Exception {
    addCommandRunner = new AddCommandRunner();
    doneCommandRunner = new DoneCommandRunner();
    tasksManager = TasksManager.getManager();
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
    addTask("Ice ice baby", new DateTime("31/08/2015"));
  }

  @Test
  public void processCommand_DoneTask() throws UnableToExecuteCommandException {
    Status returnStatus = doneTask(1);
    String expectedStatusLine = "Nicely done! Give yourself a pat on the back!\n";
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
  }

  @Test
  public void undo_DoneTask() throws UnableToExecuteCommandException {
    doneTask(1);
    doneCommandRunner.undo();
    assertTrue(!tasksManager.isEmptyPendingTasks());
  }

  @Test
  public void redo_DoneTask() throws UnableToExecuteCommandException, NoSuchTaskException {
    doneTask(1);
    doneCommandRunner.undo();
    doneCommandRunner.redo();
    assertTrue(tasksManager.isEmptyPendingTasks());
  }

```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testHelpAppear() throws InterruptedException {
    Thread.sleep(500);
	raijin.push(KeyCode.CONTROL, KeyCode.H);
	assertTrue(Raijin.isHelpOn);
	raijin.push(KeyCode.CONTROL, KeyCode.H);
  }
  
  @Test
```
###### target\classes\raijin\ui\resource\layout\InputController.fxml
``` fxml

<?import javafx.scene.shape.*?>
<?import javafx.scene.image.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.text.*?>

<fx:root id="inputControllerBorderPane" opacity="1.0" prefHeight="82.0" prefWidth="271.0" type="BorderPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
  <center>
    <TextField fx:id="inputCommandBar" onKeyPressed="#onKeyPress" prefWidth="-1.0" promptText="What would you like to do?">
      <BorderPane.margin>
        <Insets bottom="5.0" left="5.0" right="5.0" />
      </BorderPane.margin>
         <font>
            <Font name="System Bold" size="18.0" />
         </font>
    </TextField>
  </center>
  <top>
      <VBox fx:id="feedbackVBox" alignment="CENTER">
         <children>
          <Label fx:id="feedbackBar" alignment="CENTER" focusTraversable="false" maxHeight="22.0" textFill="BLACK" BorderPane.alignment="CENTER">
            <font>
              <Font size="16.0" />
            </font>
            <BorderPane.margin>
              <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
            </BorderPane.margin>
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
          </Label>
            <HBox fx:id="timeSlot" prefHeight="33.0" prefWidth="271.0" spacing="5.0" style="-fx-border-width: 2; -fx-border-color: #eeeeee;">
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
               <padding>
                  <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
               </padding></HBox>
         </children>
      </VBox>
  </top>
   <bottom>
      <TextFlow fx:id="helpBar" lineSpacing="1.15" prefHeight="50.0" prefWidth="271.0" style="-fx-background-color: #333332;" BorderPane.alignment="CENTER" VBox.vgrow="ALWAYS">
         <padding>
            <Insets bottom="5.0" left="15.0" right="5.0" top="5.0" />
         </padding>
      </TextFlow>
   </bottom>
</fx:root>
```
###### target\classes\raijin\ui\resource\layout\IntroLayout.fxml
``` fxml
This class is not used anymore because we decided
to go full keyboard in our program. This class
will make user do some clicking in order to set 
his directory. 
-->
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>

<fx:root type="BorderPane" prefHeight="700.0" prefWidth="750.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2">
  <center>
    <VBox alignment="CENTER" prefHeight="500.0" prefWidth="500.0">
      <children>
        <Label contentDisplay="CENTER" text="${'Hi, welcome to Raijin!\nPlease select the folder you wish to store your tasks at.'}" textAlignment="CENTER" wrapText="true">
          <VBox.margin>
            <Insets bottom="50.0" left="10.0" right="10.0" />
          </VBox.margin>
        </Label>
        <Button contentDisplay="CENTER" mnemonicParsing="false" onAction="#handleGettingStartedAction" text="Get Started!" textAlignment="CENTER" />
      </children>
    </VBox>
  </center>
</fx:root>
```
###### target\classes\raijin\ui\resource\layout\RootLayout.fxml
``` fxml
<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<BorderPane bottom="$null" prefHeight="700.0" prefWidth="750.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" />
```
###### target\classes\raijin\ui\resource\styles\Help.css
``` css

.list-cell, .list-cell:empty, .list-cell:even, .list-cell:odd {
	-fx-background-color: #333332;
}

.list-cell:selected .label{
	-fx-text-fill: black;
}
```
