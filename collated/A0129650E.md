# A0129650E
###### src\main\raijin\logic\command\DeleteCommandRunner.java
``` java

package raijin.logic.command;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.TreeSet;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.UndoableRedoable;
import raijin.logic.parser.ParsedInput;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.TaskUtils;

public class DeleteCommandRunner extends CommandRunner implements  UndoableRedoable {

  TreeSet<Integer> idsToDelete = new TreeSet<Integer>();
  TreeSet<Integer> idsUndone = new TreeSet<Integer>();
  Queue<Integer> idsDeleted = new LinkedList<Integer>();
  Queue<Task> tasksDeleted = new LinkedList<Task>();
  String taskDescription;
  Task task;

  public Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {
    idsToDelete = input.getIds();
    taskDescription = "";
    
    if (idsToDelete.isEmpty()) {
      idsToDelete = getIdsFromTags(input.getTags());
    }

    if (idsToDelete.isEmpty()) {
      return new Status(Constants.FEEDBACK_DELETE_FAILURE, false);
    }

    while(!idsToDelete.isEmpty()) {
      int id = idsToDelete.pollFirst();
      try {
        this.task = tasksManager.getPendingTask(id);
        tasksDeleted.offer(task);
            
        tasksManager.deletePendingTask(id);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DELETE);
      }
      /*
      if (taskDescription == "" && idsToDelete.isEmpty()) {
        taskDescription = "\""+ task.getName() + "\"";
      } else if (!idsToDelete.isEmpty()) {
        taskDescription += "\""+ task.getName() +"\", ";
      } else {
        taskDescription += "& \""+ task.getName() +"\"";
      }*/
      
      taskDescription += String.format(Constants.FEEDBACK_DELETE_SUCCESS, task.getName())+"\n";
    }
    
    history.pushCommand(this);
    
    return new Status(taskDescription);
  }

  public void undo() {
    while (!tasksDeleted.isEmpty()) {
      task = tasksDeleted.poll();
      
      task.setId(idManager.getId());  
      idsUndone.add(task.getId());
      tasksManager.addPendingTask(task);
    }
  }

  public void redo() throws UnableToExecuteCommandException {
    while (!idsUndone.isEmpty()) {
      int id = idsUndone.pollFirst();
      idsDeleted.offer(id);
      try {
        task = tasksManager.getPendingTask(id);
        tasksDeleted.offer(task);
        tasksManager.deletePendingTask(id);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DELETE);
      }
    }
  }


  /**
   * Get id from filtered tasks when tag is chosen 
   * @param tags
   * @return
   */
  TreeSet<Integer> getIdsFromTags(TreeSet<String> tags) {
    List<Task> filtered = TaskUtils.filterTaskWithTags(tasksManager.getPendingTasks(), 
        tags);
    System.out.println(filtered.toString());
    return new TreeSet<Integer>(filtered.stream().map(
        t -> t.getId()).collect(Collectors.toList()));
  }

}
```
###### src\main\raijin\logic\command\DoneCommandRunner.java
``` java

package raijin.logic.command;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.TreeSet;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.TaskUtils;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.UndoableRedoable;
import raijin.logic.parser.ParsedInput;

public class DoneCommandRunner extends CommandRunner implements UndoableRedoable {
	TreeSet<Integer> idsToDone = new TreeSet<Integer>();
	TreeSet<Integer> idsUndone = new TreeSet<Integer>();
	Queue<Integer> idsDone = new LinkedList<Integer>();
	Queue<Task> tasksDone = new LinkedList<Task>();
	String taskDescription;
	Task task;
	
  public Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {   
	idsToDone = input.getIds();
	taskDescription = "";
	
	if (idsToDone.isEmpty()) {       //If no id specified, use tags
	  idsToDone = getIdsFromTags(input.getTags());
	}
	
	if (idsToDone.isEmpty()) {
      return new Status(Constants.FEEDBACK_DONE_FAILURE, false);
    }

	logger.debug(idsToDone.toString());
    
	while(!idsToDone.isEmpty()) {
	  int id = idsToDone.pollFirst();
	  idsDone.offer(id);
	  try {
	    this.task = tasksManager.getPendingTask(id);
	    tasksDone.offer(task);
	  } catch (NoSuchTaskException e) {
	    wrapLowerLevelException(e, Constants.Command.DONE);
	  }
	  
	  /*
	  if (taskDescription == "" && idsToDone.isEmpty()) {
        taskDescription = "\""+ task.getName() + "\"";
      } else if (!idsToDone.isEmpty()) {
        taskDescription += "\""+ task.getName() +"\", ";
      } else {
        taskDescription += "& \""+ task.getName() +"\"";
      } */

	  taskDescription += String.format(Constants.FEEDBACK_DONE_SUCCESS, task.getName())+"\n";
	  
	  tasksManager.addCompletedTask(task);
	  
	}
    
	history.pushCommand(this);
    
    return new Status(taskDescription);
  }

  public void undo() throws UnableToExecuteCommandException {
    while (!idsDone.isEmpty()) {
      try {
        int id = idsDone.poll();
        task = tasksDone.poll();

        tasksManager.deleteCompletedTask(id);
        
        task.setId(idManager.getId());
        idsUndone.add(task.getId());
        tasksManager.addPendingTask(task);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DONE);
      }
    }
  }

  public void redo() throws UnableToExecuteCommandException {
    while (!idsUndone.isEmpty()) {
      int id = idsUndone.pollFirst();
      idsDone.offer(id);
      try {
        task = tasksManager.getPendingTask(id);
        tasksDone.offer(task);
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.DONE);
      }
	  tasksManager.addCompletedTask(task);
    }
  }
  
  TreeSet<Integer> getIdsFromTags(TreeSet<String> tags) {
    List<Task> filtered = TaskUtils.filterTaskWithTags(tasksManager.getPendingTasks(), 
        tags);
    return new TreeSet<Integer>(filtered.stream().map(
        t -> t.getId()).collect(Collectors.toList()));
  }

}
```
###### src\main\raijin\logic\command\ExitCommandRunner.java
``` java

package raijin.logic.command;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.logic.api.CommandRunner;
import raijin.logic.parser.ParsedInput;

public class ExitCommandRunner extends CommandRunner {

  public Status processCommand(ParsedInput cmd) {
      session.writeOnExit();
	  return new Status(Constants.FEEDBACK_EXIT_SUCCESS);
  }

}
```
###### src\main\raijin\logic\command\HelpCommandRunner.java
``` java

package raijin.logic.command;

import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;

import raijin.common.datatypes.Status;
import raijin.logic.api.CommandRunner;
import raijin.logic.parser.ParsedInput;
import raijin.common.datatypes.Constants;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.eventbus.RaijinEventBus;

import javafx.stage.*;


public class HelpCommandRunner extends CommandRunner {
 
  public Status processCommand(ParsedInput cmd) {
	
    return new Status(Constants.FEEDBACK_HELP_COMMAND);
  }

}
```
###### src\main\raijin\ui\InputController.java
``` java

package raijin.ui;

import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.TextAlignment;
import javafx.scene.text.TextFlow;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;

import edu.emory.mathcs.backport.java.util.Collections;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.HelpMessage;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.KeyPressEvent;
import raijin.common.eventbus.events.ScrollEvent;
import raijin.common.eventbus.events.SetFeedbackEvent;
import raijin.common.eventbus.events.SetFailureEvent;
import raijin.common.eventbus.events.SetHelpCommandEvent;
import raijin.common.eventbus.events.SetInputEvent;
import raijin.common.eventbus.events.SetTimeSlotEvent;
import raijin.common.eventbus.events.UndoRedoEvent;
import raijin.common.eventbus.subscribers.MainSubscriber;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

public class InputController extends BorderPane {
  @FXML
  public TextField inputCommandBar;

  @FXML
  private Label feedbackBar;

  @FXML
  private TextFlow helpBar;
  
  @FXML
  public HBox timeSlot;
  
  @FXML
  private VBox feedbackVBox;

  private static final String INPUT_COMMAND_BAR_LAYOUT_FXML =
      "resource/layout/InputController.fxml";

  private static final String INPUT_FONT = "resource/styles/DejaVuSans.ttf";

  private Raijin mainApp;
  private RaijinEventBus eventbus = RaijinEventBus.getInstance();
  /* Stores previously entered command */
  private ArrayList<String> commandHistory = new ArrayList<String>();
  private static int upCount = 0; // Count number of UP pressed
  private Clipboard clipboard; // System clipboard
  private javafx.scene.input.Clipboard fxClipboard;

  private Font inputFont;

  public InputController(Raijin mainApp) throws IOException {
    FXMLLoader loader = new FXMLLoader(getClass().getResource(INPUT_COMMAND_BAR_LAYOUT_FXML));
    loader.setController(this);
    loader.setRoot(this);
    try {
      loader.load();
    } catch (IOException e) {
      e.printStackTrace();
    }

    this.mainApp = mainApp;
    this.setStyle("-fx-background-color:white;");
    clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
    fxClipboard = javafx.scene.input.Clipboard.getSystemClipboard();
    setupStyles();
    handleAllEvents();
    helpBar.setVisible(false);
  }

  public TextField getCommandBar() {
    return inputCommandBar;
  }

  public HBox getTimeSlot() {
    return timeSlot;
  }

  public void clear() {
    inputCommandBar.clear();
  }

  @FXML
  public void onKeyPress(KeyEvent event) {
    handleIOEvent(event);
    handleScrollEvent(event);
    if (Constants.KEY_MINMAX.match(event)) {
      mainApp.resizeWindow();
    } else if (Constants.KEY_CLEAR.match(event)) {
      clear();
    } else if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN) {
      getPreviousCommands(event);
      event.consume();
    } else {
      upCount = 0;
    }
    mainApp.handleKeyPress(this, event.getCode(), inputCommandBar.getText());
  }

  public void setFeedback(String text) {
    // feedbackBar.setTextFill(Color.BLACK);
    feedbackBar.setText(text);
  }

  public void setInput(String text) {
    inputCommandBar.setText(text);
    inputCommandBar.positionCaret(text.length());
  }

  void handleSetFeedbackEvent() {
    MainSubscriber<SetFeedbackEvent> feedbackSubscriber =
        new MainSubscriber<SetFeedbackEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetFeedbackEvent event) {
            feedbackBar.setTextFill(Color.BLACK);
            setFeedback(event.output);
          }
        };
  }

  void handleSetTimeSlotEvent() {
    MainSubscriber<SetTimeSlotEvent> timeSlotSubscriber =
        new MainSubscriber<SetTimeSlotEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetTimeSlotEvent event) {
            if (event.isVisible) {
              generateTimeSlots(event.busySlots);
              timeSlot.setVisible(true);
            } else {
              timeSlot.setVisible(false);
            }
          }
        };
  }

  void handleSetHelpEvent() {
    MainSubscriber<SetHelpCommandEvent> helpSubscriber =
        new MainSubscriber<SetHelpCommandEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetHelpCommandEvent event) {
            if (event.isVisible) {
              helpBar.getChildren().clear();
              HelpMessage msg = new HelpMessage(event.commandFormat, event.description);
              helpBar.getChildren().addAll(msg.helpMessage);
              helpBar.setVisible(true);
            } else {
              helpBar.setVisible(false);
            }
          }
        };
  }

  public void setFailureFeedback(String text) {
    // feedbackBar.setTextFill(Color.RED);
    setFeedback(text);
  }

  void handleSetFailureEvent() {
    MainSubscriber<SetFailureEvent> failureSubscriber =
        new MainSubscriber<SetFailureEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(SetFailureEvent event) {
            feedbackBar.setTextFill(Color.RED);
            setFailureFeedback(event.output);
          }
        };
  }

  void handleSetInputEvent() {
    MainSubscriber<SetInputEvent> inputSubscriber = new MainSubscriber<
        SetInputEvent>(eventbus.getEventBus()) {

      @Subscribe
      @Override
      public void handleEvent(SetInputEvent event) {
        setInput(event.output);
      }
    };
  }

  void handleTabEvent() {
    inputCommandBar.addEventFilter(KeyEvent.KEY_PRESSED, (KeyEvent event) -> {
      if (event.getCode() == KeyCode.TAB) {
        eventbus.post(event);
        event.consume();
      }
    });
  }

  void handleHelpBar() {
    helpBar.visibleProperty().addListener(new ChangeListener<Boolean>() {

      @Override
      public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {
        if (t1.booleanValue()) { // If maximized
          helpBar.setMaxSize(inputCommandBar.getMaxWidth(), 
              inputCommandBar.getMaxHeight());
        } else {
          /*
          helpBar.setMaxSize(0, 0);
          helpBar.setMinSize(0, 0);
          */
          helpBar.getChildren().clear();
        }
      }
    });
  }

  void handleTimeSlot() {
    timeSlot.visibleProperty().addListener(new ChangeListener<Boolean>() {

      @Override
      public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {
        if (t1.booleanValue()) { // If maximized
          /*
          timeSlot.setMaxSize(inputCommandBar.getMaxWidth(), 
              timeSlot.getMaxHeight());
              */
          feedbackVBox.getChildren().clear();
          feedbackVBox.getChildren().addAll(feedbackBar, timeSlot);
        } else {
          /*
          timeSlot.setMaxSize(0, 0);
          timeSlot.setMinSize(0, 0);
          */
          feedbackVBox.getChildren().clear();
          feedbackVBox.getChildren().add(feedbackBar);
        }
      }
    });
  }

  /* This is needed because TextArea is not updated till keypress is shot */
  void handleKeyReleaseEvent() {
    inputCommandBar.setOnKeyReleased(new EventHandler<KeyEvent>() {

      @Override
      public void handle(KeyEvent event) {
        if (Constants.KEY_UNDO.match(event)) {
          eventbus.post(new UndoRedoEvent(true, false));
          event.consume();
        } else if (Constants.KEY_REDO.match(event)) {
          eventbus.post(new UndoRedoEvent(false, true));
          event.consume();
        } else {
          String userInput = inputCommandBar.getText();
          eventbus.post(new KeyPressEvent(event, userInput));
        }
        event.consume();
      }

    });
  }

  void handleAllEvents() {
    handleHelpBar();
    handleTimeSlot();
    handleSetTimeSlotEvent();
    handleSetHelpEvent();
    handleTabEvent();
    handleSetFailureEvent();
    handleSetFeedbackEvent();
    handleSetInputEvent();
    handleKeyReleaseEvent();
  }

  public void updateCommandHistory(String command) {
    commandHistory.add(command);
  }

  void getPreviousCommands(KeyEvent event) {
    int index;
    if (!commandHistory.isEmpty()) {
      if (event.getCode() == KeyCode.UP) {
        index = Math.floorMod((commandHistory.size() - (++upCount)), commandHistory.size());
      } else {
        index = Math.floorMod((commandHistory.size() - (--upCount)), commandHistory.size());
      }
      setInput(commandHistory.get(index));
    }
  }

  /**
   * Handles copy, cut, and paste operation
   * 
   * @param event
   */
  void handleIOEvent(KeyEvent event) {
    if (Constants.KEY_COPY.match(event)) {
      copyToClipboard(false);
    } else if (Constants.KEY_PASTE.match(event)) {
      getClipboardContent();
      event.consume();
    } else if (Constants.KEY_CUT.match(event)) {

    }
  }

  /**
   * Handles scroll event using keyboard
   * 
   * @param event
   */
  void handleScrollEvent(KeyEvent event) {
    if (Constants.SCROLL_UP.match(event)) {
      eventbus.post(new ScrollEvent(-1));
      event.consume();
    } else if (Constants.SCROLL_DOWN.match(event)) {
      eventbus.post(new ScrollEvent(1));
      event.consume();
    }
  }

  /**
   * Handles cut and copy operation
   * 
   * @param isCut determines whether selected text will be removed
   */
  public void copyToClipboard(boolean isCut) {
    /*
     * ClipboardContent content = new ClipboardContent();
     * content.putString(inputCommandBar.getSelectedText()); fxClipboard.setContent(content);
     */
    if (isCut) {
      inputCommandBar.cut();
    } else {
      inputCommandBar.copy();
    }
  }

  void getClipboardContent() {
    String data; // To be displayed message
    if (fxClipboard.hasString()) {
      data = fxClipboard.getString();
      int caretPosition = inputCommandBar.getCaretPosition();
      inputCommandBar.insertText(caretPosition, data);
    }
  }
  
  void generateTimeSlots(List<DateTime> slots) {
    timeSlot.getChildren().clear();
    Label intro = new Label("You are busy from: ");
    intro.setTextAlignment(TextAlignment.CENTER);
    intro.setPadding(new Insets(5, 5, 5, 5));
    intro.setStyle("-fx-font-size: 14");
    timeSlot.getChildren().add(intro);
    Collections.sort(slots);

    for (DateTime slot : slots) {
      timeSlot.getChildren().add(createTimeSlot(slot));
    }
  }

  Label createTimeSlot(DateTime slot) {
    String startTime = slot.getStartTime().toString();
    String endTime = slot.getEndTime().toString();
    String duration = startTime + " ~ " + endTime;
    Label timeSlot = new Label(duration);
    timeSlot.setPadding(new Insets(5, 5, 5, 5));
    timeSlot.setStyle("-fx-font-size: 14; -fx-background-color: #FF8000; "
        + "-fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5;");
    return timeSlot;
  }

  void setupStyles() {
    inputFont = Font.loadFont(getClass().getResource(INPUT_FONT).toString(), 18);
    inputCommandBar.setFont(inputFont);
  }

}
```
###### src\main\raijin\ui\Raijin.java
``` java

package raijin.ui;

import com.google.common.eventbus.EventBus;

import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.SetFeedbackEvent;
import raijin.common.eventbus.events.SetFailureEvent;
import raijin.common.eventbus.events.SetTimeSlotEvent;

import java.awt.AWTException;
import java.awt.Image;
import java.awt.SystemTray;
import java.awt.TrayIcon;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URL;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.ImageIcon;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseEvent;
import javafx.scene.image.ImageView;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.stage.WindowEvent;

import org.jnativehook.GlobalScreen;
import org.jnativehook.NativeInputEvent;
import org.jnativehook.keyboard.NativeKeyEvent;
import org.jnativehook.keyboard.NativeKeyListener;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.logic.api.Logic;

public class Raijin extends Application implements NativeKeyListener {
  private static final String ROOT_LAYOUT_FXML_LOCATION = "resource/layout/RootLayout.fxml";
  private static final String INTRO_LAYOUT_FXML_LOCATION = "resource/layout/IntroLayout.fxml";
  private static final String TRAY_ICON_LOCATION = "resource/styles/raijin2.png";
  private static final String HELP_ADD = "resource/styles/helpAdd.jpg";
  private static final String HELP_DELETE = "resource/styles/helpDelete.jpg";
  private static final String HELP_DISPLAY = "resource/styles/helpDisplay.jpg";
  private static final String HELP_DONE = "resource/styles/helpDone.jpg";
  private static final String HELP_EDIT = "resource/styles/helpEdit.jpg";
  private static final String HELP_SEARCH  = "resource/styles/helpSearch.jpg";
  private static final String HELP_SET = "resource/styles/helpSet.jpg";
  private static final String HELP_UNDOREDO = "resource/styles/helpUndoRedo.jpg";
  private static final String KEYBOARD_SHORTCUTS = "resource/styles/keyboardShort.jpg";
  private static final String[] helpImg = {"resource/styles/helpAdd.jpg",
		  "resource/styles/helpDelete.jpg",
		  "resource/styles/helpDisplay.jpg",
		  "resource/styles/helpDone.jpg",
		  "resource/styles/helpEdit.jpg",
		  "resource/styles/helpSearch.jpg",
		  "resource/styles/helpSet.jpg",
		  "resource/styles/helpUndoRedo.jpg",
		  "resource/styles/keyboardShort.jpg"};	
  private static final String CSS_LOCATION = "resource/styles/RaijinStyle.css";
  private static final double MIN_WIDTH = 550.0;
  private static final double MIN_HEIGTH = 650.0;

  private static final String NO_DIRECTORY_SELECTED_FEEDBACK = "I'm sorry! You have not selected "
      + "a directory yet. Please try again!";
  
  private boolean isVisible = false;
  private boolean isHelpOn = false;
  BorderPane rootLayout, introLayout, inputController, displayController,
      sidebarController;
  private double dragX = 0;
  private double dragY = 0;
  private HBox hBox;
  private ImageView[] helpImg_ImageView = new ImageView[9];
  private static Stage stage, helpStage;
  private Logic logic;
  private IntroController introController;
  private RaijinEventBus eventbus = RaijinEventBus.getInstance();
  private SystemTray tray;
  final TrayIcon trayIcon = new TrayIcon(createImage(TRAY_ICON_LOCATION), "Raijin.java", null);


  public static void main(String[] args) {
    launch(args);
  }

  public static Stage getStage() {
    return stage;
  }

  @Override
  public void start(Stage stage) throws Exception {
    /* Adding fxml */
	initPrimaryStage(stage);
    initLogic();
    setUpVariables();
    decideScene();
    makeTray(stage); // listen out for any ctrl-h events
    Platform.setImplicitExit(false);

    GlobalScreen.registerNativeHook();
    GlobalScreen.addNativeKeyListener(this);
    turnOffLogger(); // Turn off JNativeHook Logging

    changeToMinimisedView();

    this.stage.show();
    this.isVisible = true;

    /*
     * this.stage.widthProperty().greaterThan(add750).addListener((obs, oldValue, newValue) -> { if
     * (!newValue) { changeToMinimisedView(); } else { changeToMaximisedView(); } });
     */

    handleMaximized(); // Handle simple & advanced mode
    stage.setOnCloseRequest(new EventHandler<WindowEvent>() {
      public void handle(WindowEvent we) {
        logic.executeCommand("exit");
        System.exit(0);
      }
    });

  }

  private void initPrimaryStage(Stage stage) {
    this.stage = stage;
    this.stage.setTitle("Welcome to Raijin");
    this.stage.setMinWidth(MIN_WIDTH);
    this.stage.setMinHeight(MIN_HEIGTH);
  }

  private void initRootLayout() {
    FXMLLoader loader = new FXMLLoader(getClass().getResource(ROOT_LAYOUT_FXML_LOCATION));
    try {
      rootLayout = loader.load();
    } catch (IOException e) {
      e.printStackTrace();
    }

    String CSS = getClass().getResource(CSS_LOCATION).toExternalForm();
    rootLayout.getStylesheets().add(CSS);
  }

  private void initLogic() throws FileNotFoundException {
    logic = new Logic();
  }

  public void changeToMinimisedView() {
    rootLayout.setCenter(displayController);
    rootLayout.setBottom(inputController);
    setFocusAtCommandBar();
  }

  private void changeToMaximisedView() {
    hBox.getChildren().clear();
    hBox.getChildren().addAll(sidebarController, displayController);
    rootLayout.setCenter(hBox);
    rootLayout.setBottom(inputController);
    setFocusAtCommandBar();
  }

  public void decideScene() {
    initRootLayout();
    changeToMinimisedView();
    this.stage.setScene(new Scene(rootLayout));
  }

  private void setUpVariables() throws IOException {
    this.hBox = new HBox();
    hBox.setMaxWidth(Double.MAX_VALUE);
    this.inputController = new InputController(this);
    this.displayController = new DisplayController();
    this.sidebarController = new SidebarController(this.logic);
    ((InputController) inputController).timeSlot.setVisible(false);
  }

  //
  // Methods to transfer to logic
  //

  public void handleKeyPress(InputController inputController, KeyCode key, String userInput) {
    if (key == KeyCode.ENTER) {
      //eventbus.post(new SetTimeSlotEvent(false));
      inputController.updateCommandHistory(userInput); // Update list of user input
      inputController.clear();
      handleEnterPress(inputController, userInput);
    } else if (key == KeyCode.ESCAPE) {
      logic.loadCustomData(inputController.inputCommandBar.getText().trim());
    }
  }

  private void handleEnterPress(InputController inputController, String userInput) {
    Status result = logic.executeCommand(userInput);
    Boolean isSuccessful = result.isSuccess();
    String response = result.getFeedback();
    if (response.equals(Constants.FEEDBACK_EXIT_SUCCESS)) {
      System.exit(0);
    } else if (response.equals(Constants.FEEDBACK_HELP_COMMAND) && !isHelpOn) {
      isHelpOn = true;
      bringUpHelpSection();	
  	} else if (!isSuccessful) {
      eventbus.post(new SetFailureEvent(response));
    } else {
      eventbus.post(new SetFeedbackEvent(response));
    }
  }
  
  private void bringUpHelpSection() {
	 
	  helpStage = new Stage();
	  helpStage.initStyle(StageStyle.TRANSPARENT);
	  
	  helpStage.initModality(Modality.NONE);
	  helpStage.initOwner(stage);
	  
	  StackPane helpRoot = new StackPane();
	  ScrollPane innerStage = new ScrollPane();
	  
	  VBox dialogVbox = new VBox(20);
	  
	  helpRoot.setOnMousePressed(new EventHandler<MouseEvent>() {
	  		public void handle (MouseEvent me) {
            dragX = me.getScreenX() - helpStage.getX();
            dragY = me.getScreenY() - helpStage.getY();
         }
      });
      
      helpRoot.setOnMouseDragged(new EventHandler<MouseEvent>() {
         public void handle (MouseEvent me) {   
             helpStage.setX(me.getScreenX() - dragX);
             helpStage.setY(me.getScreenY() - dragY);
         }
      });
      
      for(int i = 0; i < helpImg_ImageView.length; i++) {
    	  helpImg_ImageView[i] = new ImageView(getClass().getResource(helpImg[i])
    	     .toString());
    	  helpImg_ImageView[i].setFitWidth(800);
    	  helpImg_ImageView[i].setPreserveRatio(true);
    	  dialogVbox.getChildren().add(helpImg_ImageView[i]);
      }
      
	  innerStage.setContent(dialogVbox);
	  helpRoot.getChildren().add(innerStage);
	  
	  Scene dialogScene = new Scene(helpRoot, 800, 600);
	  helpStage.setScene(dialogScene);
	  helpStage.show();
  }
  //
  // Methods for Eventbus
  //

  //
  // Setting up Activate and Hide
  //
  public void makeTray(final Stage stage) {
    if (!SystemTray.isSupported()) {
      System.out.println("Looks like you don't have System Tray on your Operating System!:(");
    }

    this.tray = SystemTray.getSystemTray();

    trayIcon.setImageAutoSize(true);
  }

  private void hide(final Stage stage) {
    Platform.runLater(new Runnable() {
      @Override
      public void run() {
        if (SystemTray.isSupported()) {
          stage.hide();
        } else {
          System.exit(0);
        }
      }
    });
  }

  protected static Image createImage(String path) {
    URL imageUrl = Raijin.class.getResource(path);

    if (imageUrl == null) {
      System.err.println("no image found: " + path);
      return null;
    } else {
      return (new ImageIcon(imageUrl)).getImage();
    }
  }

  @Override
  public void nativeKeyPressed(NativeKeyEvent arg0) {

    // Enable user to start typing whenever the application is open
    if (isVisible) {
      Platform.runLater(new Runnable() {
        @Override
        public void run() {
          setFocusAtCommandBar();
        }
      });
    }

    boolean isCtrlSpacePressed =
        arg0.getKeyCode() == NativeKeyEvent.VC_SPACE
            && NativeInputEvent.getModifiersText(arg0.getModifiers()).equals("Ctrl");

    boolean isCtrlHPressed =
        arg0.getKeyCode() == NativeKeyEvent.VC_H
            && NativeInputEvent.getModifiersText(arg0.getModifiers()).equals("Ctrl");
    
    if (isCtrlSpacePressed && isVisible) {
      hide(stage);
      try {
        tray.add(trayIcon);
      } catch (AWTException e) {
        System.out.println("TrayIcon could not be added.");
      }
      isVisible = false;
    } else if (isCtrlSpacePressed) {
      Platform.runLater(new Runnable() {
        @Override
        public void run() {
          stage.show();
          tray.remove(trayIcon);
        }
      });
      isVisible = true;
    } else if(isCtrlHPressed && !isHelpOn) {
    	isHelpOn = true;
    	Platform.runLater(new Runnable() {
            @Override
            public void run() {
            	bringUpHelpSection();
            }
          });
    } else if(isCtrlHPressed && isHelpOn) {
    	isHelpOn = false;
    	hide(helpStage);
    }
  }

  @Override
  public void nativeKeyReleased(NativeKeyEvent arg0) {

  }

  @Override
  public void nativeKeyTyped(NativeKeyEvent arg0) {
    // TODO Auto-generated method stub

  }

  void turnOffLogger() {
    Logger logger = Logger.getLogger(GlobalScreen.class.getPackage().getName());
    logger.setLevel(Level.OFF);
  }

  void handleMaximized() {
    stage.maximizedProperty().addListener(new ChangeListener<Boolean>() {

      @Override
      public void changed(ObservableValue<? extends Boolean> ov, Boolean t, Boolean t1) {
        if (t1.booleanValue()) { // If maximized
          changeToMaximisedView();
        } else {
          changeToMinimisedView();
        }
      }
    });
  }

  void setFocusAtCommandBar() {
    ((InputController) rootLayout.getBottom()).getCommandBar().requestFocus();
  }
  
  //Toggle between minimize and maximize mode
  public void resizeWindow() {
    if (stage.isMaximized()) {
      stage.setMaximized(false);
    } else {
      stage.setMaximized(true);
    }
  }
  
}
```
###### src\main\raijin\ui\resource\layout\InputController.fxml
``` fxml
<?import javafx.scene.shape.*?>
<?import javafx.scene.image.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.text.*?>

<fx:root id="inputControllerBorderPane" opacity="1.0" prefHeight="82.0" prefWidth="271.0" type="BorderPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
  <center>
    <TextField fx:id="inputCommandBar" onKeyPressed="#onKeyPress" prefWidth="-1.0" promptText="What would you like to do?">
      <BorderPane.margin>
        <Insets bottom="5.0" left="5.0" right="5.0" />
      </BorderPane.margin>
         <font>
            <Font name="System Bold" size="18.0" />
         </font>
    </TextField>
  </center>
  <top>
      <VBox fx:id="feedbackVBox" alignment="CENTER">
         <children>
          <Label fx:id="feedbackBar" alignment="CENTER" focusTraversable="false" maxHeight="22.0" textFill="BLACK" BorderPane.alignment="CENTER">
            <font>
              <Font size="16.0" />
            </font>
            <BorderPane.margin>
              <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
            </BorderPane.margin>
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
          </Label>
            <HBox fx:id="timeSlot" prefHeight="33.0" prefWidth="271.0" spacing="5.0" style="-fx-border-width: 2; -fx-border-color: #000000;">
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
               <padding>
                  <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
               </padding></HBox>
         </children>
      </VBox>
  </top>
   <bottom>
      <TextFlow fx:id="helpBar" lineSpacing="1.15" prefHeight="50.0" prefWidth="271.0" style="-fx-background-color: #333332;" BorderPane.alignment="CENTER" VBox.vgrow="ALWAYS">
         <padding>
            <Insets bottom="5.0" left="15.0" right="5.0" top="5.0" />
         </padding>
      </TextFlow>
   </bottom>
</fx:root>
```
###### src\main\raijin\ui\resource\layout\IntroLayout.fxml
``` fxml
This class is not used anymore because we decided
to go full keyboard in our program. This class
will make user do some clicking in order to set 
his directory. 
-->

<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>

<fx:root type="BorderPane" prefHeight="700.0" prefWidth="750.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2">
  <center>
    <VBox alignment="CENTER" prefHeight="500.0" prefWidth="500.0">
      <children>
        <Label contentDisplay="CENTER" text="${'Hi, welcome to Raijin!\nPlease select the folder you wish to store your tasks at.'}" textAlignment="CENTER" wrapText="true">
          <VBox.margin>
            <Insets bottom="50.0" left="10.0" right="10.0" />
          </VBox.margin>
        </Label>
        <Button contentDisplay="CENTER" mnemonicParsing="false" onAction="#handleGettingStartedAction" text="Get Started!" textAlignment="CENTER" />
      </children>
    </VBox>
  </center>
</fx:root>
```
###### src\main\raijin\ui\resource\layout\RootLayout.fxml
``` fxml
<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<BorderPane bottom="$null" prefHeight="700.0" prefWidth="750.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" />
```
###### src\test\raijin\logic\command\DeleteCommandRunnerTest.java
``` java

  @Before
  public void setUp() throws Exception {
    addCommandRunner = new AddCommandRunner();
    deleteCommandRunner = new DeleteCommandRunner();
    tasksManager = TasksManager.getManager();
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
    addTask("Ice ice baby", new DateTime("31/08/2015"));
  }

  @Test
  public void processCommand_DeleteTask() throws UnableToExecuteCommandException {
    Status returnStatus = deleteTask(1);
    String expectedStatusLine = String.format
        (Constants.FEEDBACK_DELETE_SUCCESS, "Ice ice baby") +"\n";
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
  }

  @Test
  public void undo_DeleteTask() throws UnableToExecuteCommandException {
    deleteTask(1);
    deleteCommandRunner.undo();
    assertTrue(!tasksManager.isEmptyPendingTasks());
  }

  @Test
  public void redo_DeleteTask() throws UnableToExecuteCommandException, NoSuchTaskException {
    deleteTask(1);
    deleteCommandRunner.undo();
    deleteCommandRunner.redo();
    assertTrue(tasksManager.isEmptyPendingTasks());
  }

```
###### src\test\raijin\logic\command\DoneCommandRunnerTest.java
``` java
  
  @Before
  public void setUp() throws Exception {
    addCommandRunner = new AddCommandRunner();
    doneCommandRunner = new DoneCommandRunner();
    tasksManager = TasksManager.getManager();
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
    addTask("Ice ice baby", new DateTime("31/08/2015"));
  }

  @Test
  public void processCommand_DoneTask() throws UnableToExecuteCommandException {
    Status returnStatus = doneTask(1);
    String expectedStatusLine = "Nicely done! Give yourself a pat on the back!\n";
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
  }

  @Test
  public void undo_DoneTask() throws UnableToExecuteCommandException {
    doneTask(1);
    doneCommandRunner.undo();
    assertTrue(!tasksManager.isEmptyPendingTasks());
  }

  @Test
  public void redo_DoneTask() throws UnableToExecuteCommandException, NoSuchTaskException {
    doneTask(1);
    doneCommandRunner.undo();
    doneCommandRunner.redo();
    assertTrue(tasksManager.isEmptyPendingTasks());
  }

```
###### target\classes\raijin\ui\resource\layout\InputController.fxml
``` fxml
<?import javafx.scene.shape.*?>
<?import javafx.scene.image.*?>
<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.text.*?>

<fx:root id="inputControllerBorderPane" opacity="1.0" prefHeight="82.0" prefWidth="271.0" type="BorderPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
  <center>
    <TextField fx:id="inputCommandBar" onKeyPressed="#onKeyPress" prefWidth="-1.0" promptText="What would you like to do?">
      <BorderPane.margin>
        <Insets bottom="5.0" left="5.0" right="5.0" />
      </BorderPane.margin>
         <font>
            <Font name="System Bold" size="18.0" />
         </font>
    </TextField>
  </center>
  <top>
      <VBox fx:id="feedbackVBox" alignment="CENTER">
         <children>
          <Label fx:id="feedbackBar" alignment="CENTER" focusTraversable="false" maxHeight="22.0" textFill="BLACK" BorderPane.alignment="CENTER">
            <font>
              <Font size="16.0" />
            </font>
            <BorderPane.margin>
              <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
            </BorderPane.margin>
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
          </Label>
            <HBox fx:id="timeSlot" prefHeight="33.0" prefWidth="271.0" spacing="5.0" style="-fx-border-width: 2; -fx-border-color: #000000;">
               <VBox.margin>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </VBox.margin>
               <padding>
                  <Insets bottom="3.0" left="3.0" right="3.0" top="3.0" />
               </padding></HBox>
         </children>
      </VBox>
  </top>
   <bottom>
      <TextFlow fx:id="helpBar" lineSpacing="1.15" prefHeight="50.0" prefWidth="271.0" style="-fx-background-color: #333332;" BorderPane.alignment="CENTER" VBox.vgrow="ALWAYS">
         <padding>
            <Insets bottom="5.0" left="15.0" right="5.0" top="5.0" />
         </padding>
      </TextFlow>
   </bottom>
</fx:root>
```
###### target\classes\raijin\ui\resource\layout\IntroLayout.fxml
``` fxml
This class is not used anymore because we decided
to go full keyboard in our program. This class
will make user do some clicking in order to set 
his directory. 
-->

<?xml version="1.0" encoding="UTF-8"?>

<?import java.lang.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>

<fx:root type="BorderPane" prefHeight="700.0" prefWidth="750.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2">
  <center>
    <VBox alignment="CENTER" prefHeight="500.0" prefWidth="500.0">
      <children>
        <Label contentDisplay="CENTER" text="${'Hi, welcome to Raijin!\nPlease select the folder you wish to store your tasks at.'}" textAlignment="CENTER" wrapText="true">
          <VBox.margin>
            <Insets bottom="50.0" left="10.0" right="10.0" />
          </VBox.margin>
        </Label>
        <Button contentDisplay="CENTER" mnemonicParsing="false" onAction="#handleGettingStartedAction" text="Get Started!" textAlignment="CENTER" />
      </children>
    </VBox>
  </center>
</fx:root>
```
###### target\classes\raijin\ui\resource\layout\RootLayout.fxml
``` fxml
<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<BorderPane bottom="$null" prefHeight="700.0" prefWidth="750.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" />
```
