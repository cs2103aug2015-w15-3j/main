# A0112213E
###### src\main\raijin\common\datatypes\Constants.java
``` java

package raijin.common.datatypes;

import java.time.LocalDate;

import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;

public class Constants {
  

  //===========================================================================
  // Storage Constants
  //===========================================================================
  
  public static final String NAME_USER_DATA = "/data.json";      //Default name used to store data 
  public static final String NAME_USER_CONFIG = "/config.json";  //Default name used to store user config
  public static final String NAME_USER_FOLDER = "/data";         //Default folder name for storage
  public static final String NAME_BASE_CONFIG = "/base.cfg";     //Base config which stores location of storage
  public static final String NAME_TEMP_DATA = "RaijinData";

  //===========================================================================
  // Status and Exception messages
  //===========================================================================

  public static enum Error {
    NoSuchTask, IllegalCommand, IllegalCommandArgument, UnableToExecuteCommand, 
    FailedToParse
  }

  public static final String FEEDBACK_INFO_SUCCESS = "Operation is successful.";
  public static final String FEEDBACK_ADD_SUCCESS = "You have added the task(s) successfully";
  public static final String FEEDBACK_ADD_FAILURE = "Some task(s) already exist";
  public static final String FEEDBACK_EDIT_SUCCESS = "Task \"%s\" edited successfully.";
  public static final String FEEDBACK_DELETE_SUCCESS = "You have just deleted \"%s\" !";
  public static final String FEEDBACK_DELETE_FAILURE = "Failed to delete. Task(s) don't exist!";
  public static final String FEEDBACK_DONE_FAILURE = "Failed to mark as done. Task(s) don't exist!";
  public static final String FEEDBACK_DONE_SUCCESS = "Nicely done! Give yourself a pat on the back!";
  public static final String FEEDBACK_HELP_COMMAND = "Help";
  public static final String FEEDBACK_EXIT_SUCCESS = "Exiting";
  public static final String FEEDBACK_UNDO_SUCCESS = "Undo successfully";
  public static final String FEEDBACK_REDO_SUCCESS = "Redo successfully";
  public static final String FEEDBACK_ERROR_FAILEDPARSING = "Failed to parse \"%s\"";
  public static final String FEEDBACK_ERROR_FAILEDCOMMAND = "Failed to execute \"%s\" command";
  
```
###### src\main\raijin\common\datatypes\Constants.java
``` java
  public static final String DISPLAY_OVERDUE = "All overdue tasks";
  public static final String DISPLAY_COMPLETED = "Tasks completed as of today, %s";
  public static final String DISPLAY_FLOATING = "All floating tasks";
  public static final String DISPLAY_ALL = "All pending tasks";
  
  //===========================================================================
  // Datatypes Constants
  //===========================================================================

  public enum SORT_CRITERIA {
    DEADLINE, PRIORITY, NAME, TAG
  }

  public enum TYPE_TASK {
    FLOATING, EVENT, SPECIFIC, OVERDUE
  }
  
  /*Levels of priority supported*/
  public static final String PRIORITY_LOW = "l";
  public static final String PRIORITY_MID = "m";
  public static final String PRIORITY_HIGH = "h";

  /*Universal date format used*/
  public static final String FORMAT_DATE = "dd/MM/yyyy";
  public static final String FORMAT_TIME = "HHmm";
  
  /*Initial number of IDs created*/
  public static final int MAX_ID = 200;
  
  /*Max number of tasks displayed for a specific view*/
  public static final int MAX_TASKS = 20;

  //===========================================================================
  // Parser Constants
  //===========================================================================
```
###### src\main\raijin\common\datatypes\Constants.java
``` java
  
  public static final int MAX_NAME_LENGTH = 90;

  public enum CommandParam {
   ID, NAME, DATETIME, PRIORITY, HELPEROPTION, SUBTASKOF
  }

  //===================
  // Add command format
  //===================
```
###### src\main\raijin\common\datatypes\Constants.java
``` java
  
  public static final String ADD_FLOATING = "add ?[my_task] #tag !priority";
  public static final String ADD_FLOATING_DESC = "Adds a task without deadline";
  public static final String ADD_SPECIFIC = "add ?[my_task] by/on ?[end_date] ?[end_time] "
      + "#tag !priority";
  public static final String ADD_SPECIFIC_DESC = "Adds a task with a deadline. "
      + "If no time is given, it will be set to 11.59 pm";
  public static final String ADD_EVENT_SAME_DATE = "add ?[my_task] by/on ?[end_date] "
      + "?[start_time] to ?[end_time] #tag !priority";
  public static final String ADD_EVENT_SAME_DATE_DESC = "Adds an event for that "
      + "period of time";
  public static final String ADD_EVENT_DIFFERENT_DATE = "add ?[my_task] from ?[start_date] "
      + "?[start_time] to ?[end_date] ?[end_time] #tag !priority";
  public static final String ADD_EVENT_DIFFERENT_DATE_DESC = "Adds an event that "
      + "spans more than 1 day";

  public static final String ADD_BATCH = "add ?[task_1] ; ?[task_2] ; ?[task_3] ...";
  public static final String ADD_BATCH_DESC = "Adds multiple tasks followed "
      + "by details of the tasks";

  public static final String ADD_INVALID_DATE = "?Please enter a valid time format";
  public static final String ADD_INVALID_ID = "?Invalid task id(s) found. Please "
      + "enter only task id that appears on the screen";

  //====================
  // Edit command format
  //====================

  public static final String EDIT_FORMAT = "edit ?[task_id] ?[changes]";
  public static final String EDIT_DESC = "Edit any task given its task id";
  
  //=======================
  // Display command format
  //=======================

  public static final String DISPLAY_FORMAT = "display all | completed | overdue | floating";
  public static final String DISPLAY_DESC = "Show tasks based on different criteria";

  //====================
  // Done command format
  //====================

  public static final String DONE_FORMAT = "done ?[task_id] ?[task_id] ... #tag";
  public static final String DONE_DESC = "marks a task as done given the task id or tag";

  //======================
  // Delete command format
  //======================

  public static final String DELETE_FORMAT = "delete ?[task_id] ?[task_id] .... #tag";
  public static final String DELETE_DESC = "deletes a task that no longer needed to be "
      + "completed";

  //=============================
  // Undo and redo command format
  //=============================

  public static final String UNDO_FORMAT = "undo";
  public static final String UNDO_DESC = "Undo previous command. You can also use "
      + "Ctrl + Z to undo";
  public static final String REDO_FORMAT = "redo";
  public static final String REDO_DESC = "Redo previous command. You can also use "
      + "Ctrl + Y to undo";

  //======================
  // Search command format
  //======================

  public static final String SEARCH_FORMAT = "search ?[keyword] ?[keyword] ... #tag !priority";
  public static final String SEARCH_DESC = "searches all pending tasks that "
      + "matches given keywords";
  
  
  //===================
  // Set command format
  //===================

  public static final String SET_FORMAT = "set ?[directory_to_store_data]";
  public static final String SET_DESC = "Specifies directory to store your data";

  public static enum Command { 
    ADD(Constants.ADD_SPECIFIC, Constants.ADD_SPECIFIC_DESC), 
    EDIT(Constants.EDIT_FORMAT, Constants.EDIT_DESC), 
    DISPLAY(Constants.DISPLAY_FORMAT, Constants.DISPLAY_DESC), 
    SEARCH(Constants.SEARCH_FORMAT, Constants.SEARCH_DESC), 
    DELETE(Constants.DELETE_FORMAT, Constants.DELETE_DESC), 
    DONE(Constants.DONE_FORMAT, Constants.DONE_DESC), 
    UNDO(Constants.UNDO_FORMAT, Constants.UNDO_DESC), 
    REDO(Constants.REDO_FORMAT, Constants.REDO_DESC), 
    SET(Constants.SET_FORMAT, Constants.SET_DESC), HELP, EXIT;
    
    public String cmdFormat;                    //format when using the command
    public String cmdDescription;               //description of the command
    
    private Command() {}

    private Command(String cmdFormat, String cmdDescription) {
      this.cmdFormat = cmdFormat;
      this.cmdDescription = cmdDescription;
    }

  }
  
```
###### src\main\raijin\common\datatypes\Constants.java
``` java
 //===========================================================================
  // Keyboard shortcuts
  //===========================================================================
  
  public static final KeyCodeCombination KEY_UNDO = new KeyCodeCombination(KeyCode.Z,   //Undo shortcut
      KeyCombination.CONTROL_DOWN);

  public static final KeyCodeCombination KEY_REDO = new KeyCodeCombination(KeyCode.Y,   //Redo shortcut
      KeyCombination.CONTROL_DOWN);

  public static final KeyCodeCombination KEY_CLEAR = new KeyCodeCombination(KeyCode.R,  //Clear shortcut
      KeyCombination.CONTROL_DOWN);

  public static final KeyCodeCombination KEY_COPY = new KeyCodeCombination(KeyCode.C,  //Copy shortcut
      KeyCombination.CONTROL_DOWN);

  public static final KeyCodeCombination KEY_CUT = new KeyCodeCombination(KeyCode.X,  //Cut shortcut
      KeyCombination.CONTROL_DOWN);

  public static final KeyCodeCombination KEY_PASTE = new KeyCodeCombination(KeyCode.V,  //Paste shortcut
      KeyCombination.CONTROL_DOWN);

  public static final KeyCodeCombination KEY_TAB = new KeyCodeCombination(KeyCode.ENTER);

  public  static final KeyCodeCombination KEY_VIEW_DOWN = new KeyCodeCombination(KeyCode.F2);

  public  static final KeyCodeCombination KEY_VIEW_UP = new KeyCodeCombination(KeyCode.F1);

  public  static final KeyCodeCombination KEY_MINMAX = new KeyCodeCombination(KeyCode.M, 
      KeyCodeCombination.ALT_DOWN);

  public  static final KeyCodeCombination SCROLL_UP = new KeyCodeCombination(KeyCode.PAGE_UP);

  public  static final KeyCodeCombination SCROLL_DOWN = new KeyCodeCombination(KeyCode.PAGE_DOWN);

  //===========================================================================
  // Autocomplete 
  //===========================================================================
  
  private static final LocalDate today = LocalDate.now();
  private static final LocalDate tomorrow = LocalDate.now().plusDays(1L);

  /*Different default views supported*/
  public static enum View {

    INBOX(Constants.DISPLAY_ALL, null), 
    TODAY("Today", new DateTime(today, today)), 
    TOMORROW("Tomorrow", new DateTime(tomorrow, tomorrow)),
    FUTURE("Future", new DateTime(today.plusDays(2L), today.plusYears(1L)));

    private String message;
    private DateTime dateTime;
    
    private View(String message, DateTime dateTime) {
      this.message = message;
      this.dateTime = dateTime;
    }
    
    public String getMessage() {
      return message;
    }

    public DateTime getDateTime() {
      return dateTime;
    }
  }
}
```
###### src\main\raijin\common\datatypes\DateTime.java
``` java

package raijin.common.datatypes;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public class DateTime implements Comparable<DateTime> {

  private static DateTimeFormatter dateFormatter = DateTimeFormatter
      .ofPattern(Constants.FORMAT_DATE);
  private static DateTimeFormatter timeFormatter = DateTimeFormatter
      .ofPattern(Constants.FORMAT_TIME);

  private LocalDate startDate;
  private LocalDate endDate;
  private LocalTime startTime;
  private LocalTime endTime;

  // =========================
  // Constructors for testing
  // =========================

  public DateTime(LocalDate startDate, LocalDate endDate) {
    this.startDate = startDate;
    this.endDate = endDate;
  }

  public DateTime(LocalTime startTime, LocalTime endTime) {
    this.startTime = startTime;
    this.endTime = endTime;
  }

  public DateTime(LocalDate startDate, LocalTime startTime, LocalDate endDate, LocalTime endTime) {
    this.startDate = startDate;
    this.startTime = startTime;
    this.endDate = endDate;
    this.endTime = endTime;
  }


  // ============================
  // Constructors used by Parser
  // ============================

  /**
   * Constructs deadline when only end date is specified
   * @param endDate
   */
  public DateTime(String endDate) {
    this.startDate = LocalDate.parse(endDate, dateFormatter);
    this.endDate = LocalDate.parse(endDate, dateFormatter);
    /* Set time to 2359 when not specified by user */
    this.endTime = LocalTime.of(23, 59);
  }

  /**
   * Constructs deadline when both time and date is specified
   * @param endDate
   * @param endTime
   */
  public DateTime(String endDate, String endTime) {
    /* Set start date to end date to avoid deadling with null */
    this.startDate = LocalDate.parse(endDate, dateFormatter);
    this.endDate = LocalDate.parse(endDate, dateFormatter);
    this.endTime = LocalTime.parse(endTime, timeFormatter);
  }

  /**
   * Constructs deadline for task that spans certain duration on the same day
   * @param endDate
   * @param startTime
   * @param endTime
   */
  public DateTime(String endDate, String startTime, String endTime) {
    this.startDate = LocalDate.parse(endDate, dateFormatter);
    this.endDate = LocalDate.parse(endDate, dateFormatter);
    this.startTime = LocalTime.parse(startTime, timeFormatter);
    this.endTime = LocalTime.parse(endTime, timeFormatter);
  }

  /* Creates event that spans multiple days */
  public DateTime(String startDate, String startTime, String endDate, String endTime) {
    this.startDate = LocalDate.parse(startDate, dateFormatter);
    this.endDate = LocalDate.parse(endDate, dateFormatter);
    this.startTime = LocalTime.parse(startTime, timeFormatter);
    this.endTime = LocalTime.parse(endTime, timeFormatter);
  }

  public LocalDate getEndDate() {
    return endDate;
  }

  public LocalTime getEndTime() {
    return endTime;
  }

  public LocalDate getStartDate() {
    return startDate;
  }

  public LocalTime getStartTime() {
    return startTime;
  }

  /**
   * Handles comparison of null fields
   * @param source 
   * @param target
   * @return
   */
  boolean compare(Object source, Object target) {
    if (source == null) {
      return target == null;
    } else {
      return source.equals(target);
    }
  }

  @Override
  public boolean equals(Object ob2) {
    if (ob2 instanceof DateTime) {
      return compare(startDate, ((DateTime) ob2).getStartDate())
          && compare(endDate, ((DateTime) ob2).getEndDate())
          && compare(startTime, ((DateTime) ob2).getStartTime())
          && compare(endTime, ((DateTime) ob2).getEndTime());
    }
    return false;
  }


  /**
   * Compare time when both shared the same end time.
   * @param source
   * @param target
   * @return
   */
  int compareStartTime(LocalTime source, LocalTime target) {
    if (source == null && target == null) {
      return 0;
    } else if (source == null) {
      return 1;
    } else if (target == null) {
      return -1;
    } else {
      return source.compareTo(target);
    }
  }

  /**
   * Comparator for DateTime objects
   * 
   * @param DateTime compared
   * @return
   */

  @Override
  public int compareTo(DateTime compared) {
    int result = getStartDate().compareTo(compared.getStartDate());

    // When both end dates are different
    if (result != 0) {
      return result;
    } else {
      result = getEndDate().compareTo(compared.getEndDate());

      // When both start dates are different
      if (result != 0) {
        return result;
      } else {
        result = getEndTime().compareTo(compared.getEndTime());

        // When both end times are different
        if (result != 0) {
          return result;
        } else {
          return compareStartTime(getStartTime(), compared.getStartTime());
        }
      }
    }


  }


}
```
###### src\main\raijin\common\datatypes\Status.java
``` java

package raijin.common.datatypes;

public class Status {
  
  private boolean isSuccess = true;         //indicates success of a command execution
  private String displayText;               //text that will be shown on main display
  private String feedback;                  //feedback after execution of a command

  public Status(String feedback){
    this.feedback = feedback;
  }

  public Status(String feedback, String displayText){
    this.feedback = feedback;
    this.displayText = displayText;
  }

  public Status(String feedback, boolean isSuccess) {
    this.feedback = feedback;
    this.isSuccess = isSuccess;
  }

  public String getDisplayText() {
    return displayText;
  }

  public String getFeedback() {
    return feedback;
  }

  public boolean isSuccess() {
    return isSuccess;
  }

  public void setSuccess(boolean isSuccess) {
    this.isSuccess = isSuccess;
  }

}
```
###### src\main\raijin\common\datatypes\Task.java
``` java

package raijin.common.datatypes;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.TreeSet;
import java.util.stream.Collectors;

import raijin.logic.parser.ParsedInput;
import raijin.storage.api.TasksManager;


/**
 * Represents details of a task created by user
 * 
 * @author papa
 *
 */
public class Task implements Comparable<Task> {

  private int id; // unique id that describes a task
  private String name; // description of a task
  private DateTime dateTime;
  private String priority = Constants.PRIORITY_MID;
  private TreeSet<String> tags = new TreeSet<String>();
  private TreeSet<Integer> subTasks = new TreeSet<Integer>();
  private ArrayList<String> keywords;
  private Constants.TYPE_TASK type; // floating, event or normal task


  /* Creates a floating task */
  public Task(String name, int id) {
    init(name, id);
    setTypeOfTask();
  }

  /* Creates a normal task with deadline */
  public Task(String name, int id, ParsedInput input) {
    init(name, id);
    initExtra(input);
    setTypeOfTask();
  }


  void setTypeOfTask() {
    if (dateTime == null) {
      type = Constants.TYPE_TASK.FLOATING;
    } else {

      if (dateTime.getStartTime() == null || dateTime.getStartTime().equals(dateTime.getEndTime())
          && dateTime.getStartDate().equals(dateTime.getEndDate())) {
        type = Constants.TYPE_TASK.SPECIFIC;
      } else {
        type = Constants.TYPE_TASK.EVENT;
      }
    }
  }

  void extractTags(ParsedInput input) {
    if (input.getTags() != null) {
      addTags(input.getTags());
    }
  }

  /* Initialise most basic fields */
  void init(String name, int id) {
    assert (id > 0);
    this.name = name;
    this.id = id;
    this.keywords = new ArrayList<String>(Arrays.asList(name.split(" ")));
  }

  /* Initialise non-mandatory fields for task */
  void initExtra(ParsedInput input) {
    dateTime = input.getDateTime();
    priority = input.getPriority() == null ? "m" : input.getPriority();
    extractTags(input);
  }

  void lazyUpdateSubTasks() {
    HashMap<Integer, Task> pendingTasks = TasksManager.getManager().getPendingTasks();
    List<Integer> filtered =
        subTasks.stream().filter(x -> pendingTasks.containsKey(x)).collect(Collectors.toList());
    subTasks = new TreeSet<Integer>(filtered);
  }

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public DateTime getDateTime() {
    return dateTime;
  }


  public String getPriority() {
    return priority;
  }

  public TreeSet<String> getTags() {
    return tags;
  }

  public void addTags(TreeSet<String> input) {
    tags.addAll(input);
  }

  /* Returns keywords from task description */
  public ArrayList<String> getKeywords() {
    return keywords;
  }

  public TreeSet<Integer> getSubTasks() {
    lazyUpdateSubTasks(); // Update status of subtasks
    return subTasks;
  }

  public void addSubTask(int taskID) {
    subTasks.add(taskID);
  }

  public void removeSubTask(int taskID) {
    subTasks.remove(taskID);
  }

  public Constants.TYPE_TASK getType() {
    return type;
  }

  boolean compareDateTime(DateTime target) {
    if (getDateTime() == null) {
      return target == null;
    } else {
      return getDateTime().equals(target);
    }
  }

  @Override
  public boolean equals(Object ob2) {
    return ob2 instanceof Task && ((Task) ob2).getName().equals(getName())
        && compareDateTime(((Task) ob2).getDateTime());
  }

  @Override
  public int compareTo(Task other) {

    if (this.getType().equals(Constants.TYPE_TASK.FLOATING)) {

      // Case #1: both tasks being compared are floating tasks.
      if (other.getType().equals(Constants.TYPE_TASK.FLOATING)) {
        return this.getName().compareToIgnoreCase(other.getName());
      }

      // Case #2: this task is floating while the other is not.
      else {
        return 1;
      }

    } else {

      // Case #3: this task is not floating, the other is floating.
      if (other.getType().equals(Constants.TYPE_TASK.FLOATING)) {
        return -1;
      }

      // Case #4: both tasks are not floating.
      else {
        return this.getDateTime().compareTo(other.getDateTime());
      }
    }
  }

}
```
###### src\main\raijin\common\eventbus\events\ChangeViewEvent.java
``` java

package raijin.common.eventbus.events;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.filter.DateFilter;

/**
 * Indicates change of view to fixed set of supported views.
 * Supported views include today, tomorrow, future, all
 * @author papa
 *
 */
public class ChangeViewEvent {

  private static final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("EEEE, d MMM yyyy");
  private static final String HEAD_FORMAT = "%s (%s)";
  private LocalDate today;
  private RaijinEventBus eventbus = RaijinEventBus.getInstance();
  public List<Task> focusView;                                                  //list of tasks to be displayed
  public Constants.View typeOfView;                                             //designated view to be displayed
  public String viewMessage;                                                    //heading of current view

  public ChangeViewEvent(List<Task> pendingTasks, Constants.View view) {

    DateFilter dateFilter = new DateFilter(pendingTasks);
    today = LocalDate.now();
    typeOfView = view;

    switch (view) {

      case INBOX:
        viewMessage = view.getMessage();
        break;

      case TODAY:
        dateFilter.setDateTime(new DateTime(null, today));
        viewMessage = String.format(HEAD_FORMAT, view.getMessage(), view
            .getDateTime().getEndDate().format(dateFormatter));
        break;

      case TOMORROW:
        dateFilter.setDateTime(new DateTime(null, today.plusDays(1)));
        viewMessage = String.format(HEAD_FORMAT, view.getMessage(), view
            .getDateTime().getEndDate().format(dateFormatter));
        break;

      case FUTURE:
        dateFilter.setDateTime(new DateTime(today.plusDays(2), null));
        viewMessage = view.getMessage();
        break;

      default:
        dateFilter.setDateTime(new DateTime(null, today));
        viewMessage = String.format(HEAD_FORMAT, view.getMessage(), view
            .getDateTime().getEndDate().format(dateFormatter));
        break;

    }
    focusView = dateFilter.filter(pendingTasks);
    eventbus.setDisplayedTasks(focusView);                                      //Update displayed tasks
  }

}
```
###### src\main\raijin\common\eventbus\events\KeyPressEvent.java
``` java

package raijin.common.eventbus.events;

import javafx.scene.input.KeyEvent;

public class KeyPressEvent {

  public String currentUserInput;
  public KeyEvent keyEvent;
  
  public KeyPressEvent(KeyEvent keyEvent, String currentUserInput) {
    this.keyEvent = keyEvent;
    this.currentUserInput = currentUserInput;
  }
  
}
```
###### src\main\raijin\common\eventbus\events\ScrollEvent.java
``` java

package raijin.common.eventbus.events;

public class ScrollEvent {
  
  public int scrollDelta = 10;        //Scroll through 10 items at a time
  
  public ScrollEvent(int direction) {
    scrollDelta*=direction;
  }

}
```
###### src\main\raijin\common\eventbus\events\SetCurrentDisplayEvent.java
``` java

package raijin.common.eventbus.events;

import java.util.List;

import raijin.common.datatypes.Task;
import raijin.common.eventbus.RaijinEventBus;

/**
 * Populate current view with given list of tasks
 * @author papa
 *
 */
public class SetCurrentDisplayEvent {

  private RaijinEventBus eventbus = RaijinEventBus.getInstance();
  public List<Task> tasks;
  public String headMessage;                        //title of view
  public String bodyMessage;                        //content of view will be replaced with this message
  
  public SetCurrentDisplayEvent(List<Task> tasks) {
    this.tasks = tasks;
  }

  public SetCurrentDisplayEvent(String bodyMessage, String headMessage) {
    this.bodyMessage = bodyMessage;
    this.headMessage = headMessage;
  }

  public SetCurrentDisplayEvent(List<Task> tasks, String headMessage) {
    this.tasks = tasks;
    this.headMessage = headMessage;
    eventbus.setDisplayedTasks(tasks);              //Update dispayed tasks
  }
}
```
###### src\main\raijin\common\eventbus\events\SetFeedbackEvent.java
``` java

package raijin.common.eventbus.events;

/**
 * Set feedback bar with output message
 * @author papa
 *
 */
public class SetFeedbackEvent {

  public String output;

  public SetFeedbackEvent(String output) {
    this.output = output;
  }

}
```
###### src\main\raijin\common\eventbus\events\SetGuideEvent.java
``` java

package raijin.common.eventbus.events;

public class SetGuideEvent {

  public String commandFormat;                  //Displayed command format
  public String description;                    //Description of the command
  public boolean isVisible = true;
  public boolean isError = false;
  
  public SetGuideEvent(String commandFormat, String description) {
    this.commandFormat = commandFormat;
    this.description = description;
  }
  
  public SetGuideEvent(boolean isVisible) {
    this.isVisible = isVisible;
  }
}
```
###### src\main\raijin\common\eventbus\events\SetInputEvent.java
``` java

package raijin.common.eventbus.events;

/**
 * Set text of input bar. Used for autocomplete
 * @author papa
 *
 */
public class SetInputEvent {

  public String output;
  
  public SetInputEvent(String output) {
    this.output = output;
  }

}
```
###### src\main\raijin\common\eventbus\events\SetTimeSlotEvent.java
``` java

package raijin.common.eventbus.events;

import java.util.List;

import raijin.common.datatypes.DateTime;

/**
 * Show list of occupied time slots on the date specified by user
 * @author papa
 *
 */
public class SetTimeSlotEvent {
  
  public List<DateTime> busySlots;
  public boolean isVisible = true;

  public SetTimeSlotEvent(List<DateTime> busySlots) {
    this.busySlots = busySlots;
    if (busySlots.size() == 0) {
      isVisible = false;
    }
  }
  
  public SetTimeSlotEvent(boolean isVisible) {
    this.isVisible = isVisible;
  }

}
```
###### src\main\raijin\common\eventbus\events\TasksChangedEvent.java
``` java

package raijin.common.eventbus.events;

import java.util.List;

import com.google.common.collect.Multiset;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.filter.DateFilter;
import raijin.common.filter.TypeFilter;
import raijin.common.utils.TaskUtils;
import raijin.storage.api.Session;
import raijin.storage.api.TasksManager;

public class TasksChangedEvent {

  public List<Task> pendingToday;                 
  public List<Task> pendingTomorrow;             
  public List<Task> pendingNextWeek;              
  public List<Task> overdue;                     
  public Multiset<String> tags;                                                 //tags that exist in storage
  public String storageDirectory;
  DateFilter dateFilter;
  TypeFilter overdueFilter;
  
  public List<Task> pendingTasks;
  public List<Task> completedTasks;
  
  public TasksChangedEvent() {
    pendingTasks = TaskUtils.getTasksList(TasksManager.getManager().getPendingTasks());
    completedTasks = TaskUtils.getTasksList(TasksManager.getManager().getCompletedTasks());
    dateFilter = new DateFilter(pendingTasks);
    overdueFilter = new TypeFilter(Constants.TYPE_TASK.OVERDUE);
    init();
  }
  
  /**
   * Initialise different categories of tasks
   */
  void init() {
    pendingToday = dateFilter.filter(pendingTasks, Constants.View.TODAY);
    pendingTomorrow = dateFilter.filter(pendingTasks, Constants.View.TOMORROW);
    pendingNextWeek= dateFilter.filter(pendingTasks, Constants.View.FUTURE);
    overdue = overdueFilter.filter(pendingTasks);
    tags = TaskUtils.getTagMultiSet(pendingTasks);
    storageDirectory = Session.getSession().storageDirectory;
  }

}
```
###### src\main\raijin\common\eventbus\events\UndoRedoEvent.java
``` java

package raijin.common.eventbus.events;

/**
 * Trigger undo and redo command when shortcut is pressed
 * @author papa
 *
 */
public class UndoRedoEvent {

  public boolean canUndo = false;
  public boolean canRedo = false;
  
  public UndoRedoEvent(boolean canUndo, boolean canRedo) {
    this.canUndo = canUndo;
    this.canRedo = canRedo;
  }
  
  
}
```
###### src\main\raijin\common\eventbus\MainSubscriber.java
``` java

package raijin.common.eventbus;

import java.util.ArrayList;
import java.util.List;

import com.google.common.eventbus.EventBus;

public abstract class MainSubscriber<E> {

  private List<E> events = new ArrayList<E>();

  public MainSubscriber(EventBus eventBus) {
    eventBus.register(this);
  }

  public abstract void handleEvent(E event);
  
  public List<E> getListenedEvents() {
    return events;
  }
    
}
```
###### src\main\raijin\common\eventbus\RaijinEventBus.java
``` java

package raijin.common.eventbus;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import raijin.common.datatypes.Task;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.utils.TaskUtils;
import raijin.storage.api.TasksManager;

import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;

/**
 * Wrapper for Google event bus
 * @author papa
 *
 */
public class RaijinEventBus {
  
  public static RaijinEventBus instance = null;
  private EventBus eventbus;
  private List<Task> displayedTasks = new ArrayList<Task>();
  
  private RaijinEventBus() {
    eventbus = new EventBus();
    HashMap<Integer, Task> pendingTasks = TasksManager.getManager().getPendingTasks();
    if (!pendingTasks.isEmpty()) {
      displayedTasks = TaskUtils.initTasks(pendingTasks);
    }
  }
  
  public static RaijinEventBus getInstance() {
    if (instance == null) {
      instance = new RaijinEventBus();
    }
    return instance;
  }
  
  public void post(Object event) {
    eventbus.post(event);
  }
  
  public EventBus getEventBus() {
    return eventbus;
  }

  public List<Task> getDisplayedTasks() {
    return displayedTasks;
  }
  
  public void setDisplayedTasks(List<Task> displayedTasks) {
    this.displayedTasks = displayedTasks;
  }

}
```
###### src\main\raijin\common\exception\FailedToParseException.java
``` java

package raijin.common.exception;

import raijin.common.datatypes.Constants;

@SuppressWarnings("serial")
public class FailedToParseException extends RaijinException {

  private String userInput;

  public FailedToParseException(String message, String userInput, Throwable cause) {
    super(message, Constants.Error.FailedToParse, cause);
    this.userInput = userInput;                                                 //User input that causes this exception
  }
  
  public String getUserInput() {
    return userInput;
  }
}
```
###### src\main\raijin\common\exception\IllegalCommandArgumentException.java
``` java

package raijin.common.exception;

import raijin.common.datatypes.Constants;

@SuppressWarnings("serial")
public class IllegalCommandArgumentException extends RaijinException {
  
  private Constants.CommandParam argument;

  public IllegalCommandArgumentException(String message, Constants.CommandParam arg) {
    super(message, Constants.Error.IllegalCommandArgument);
    this.argument = arg;                                                        //Type of argument that is invalid
  }

  public Constants.CommandParam getArgument() {
    return argument;
  }
}
```
###### src\main\raijin\common\exception\IllegalCommandException.java
``` java

package raijin.common.exception;

import raijin.common.datatypes.Constants;

@SuppressWarnings("serial")
public class IllegalCommandException extends RaijinException {

  private String command;

  public IllegalCommandException(String message, String command) {
    super(message, Constants.Error.IllegalCommand);
    this.command = command;                                                     //Type of command that is invalid
  }
  
  public String getCommand() {
    return command;
  }
}
```
###### src\main\raijin\common\exception\NoSuchTaskException.java
``` java

package raijin.common.exception;

import raijin.common.datatypes.Constants;

@SuppressWarnings("serial")
public class NoSuchTaskException extends RaijinException {

 private int taskID;

 public NoSuchTaskException(String message, int id) {
    super(message, Constants.Error.NoSuchTask);
    taskID = id;                                //Task id that does not exists
 }
 
 public int getID() {
   return taskID;
 }

}
```
###### src\main\raijin\common\exception\RaijinException.java
``` java

package raijin.common.exception;

import raijin.common.datatypes.Constants;

@SuppressWarnings("serial")
public class RaijinException extends Exception {
  
    /*Setup logger for error recording*/
    private Constants.Error errorCode;

    public RaijinException() {
        super();
    }

    public RaijinException(String message, Constants.Error errorCode) {
        super(message);
        this.errorCode = errorCode;
    }
    
    public RaijinException(String message, Constants.Error errorCode, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
    }

    public Constants.Error getErrorCode() {
      return errorCode;
    }
    
}
```
###### src\main\raijin\common\exception\StorageFailureException.java
``` java

package raijin.common.exception;

@SuppressWarnings("serial")
public class StorageFailureException extends RuntimeException {

  public StorageFailureException(String message, Throwable cause) {
    super(message, cause);
  }
}
```
###### src\main\raijin\common\exception\UnableToExecuteCommandException.java
``` java

package raijin.common.exception;

import raijin.common.datatypes.Constants;

@SuppressWarnings("serial")
public class UnableToExecuteCommandException extends RaijinException {
  
  private Constants.Command command;
  
  public UnableToExecuteCommandException(String message, Throwable cause) {
    super(message, Constants.Error.UnableToExecuteCommand, cause);
  }

  public UnableToExecuteCommandException(String message, Constants.Command command, Throwable cause) {
    super(message, Constants.Error.UnableToExecuteCommand, cause);
    this.command = command;
  }
  
  public Constants.Command getCommand() {
    return command;
  }

}
```
###### src\main\raijin\common\filter\DateFilter.java
``` java

package raijin.common.filter;

import java.util.List;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.utils.TaskUtils;

/**
 * Filter tasks based on dates 
 * @author papa
 *
 */
public class DateFilter extends TaskFilter {

  /*Date and time used to filter tasks provided*/
  private DateTime limit;

  public DateFilter(List<Task> tasks, DateTime limit) {
    inputTasks = tasks;
    this.limit = limit;
  }

  public DateFilter(List<Task> tasks) {
    inputTasks = tasks;
  }

  public void setDateTime(DateTime dateTime) {
    limit = dateTime;
  }

  boolean isMatchedDate(DateTime target) {
    if (limit.getStartDate() == null) {
      /*compares specific deadline*/
      return limit.getEndDate().equals(target.getEndDate());
    } else {
      /*compare for bounded period of date*/
      return target.getStartDate() != null 
          && limit.getStartDate().compareTo(target.getStartDate()) <= 0
          && limit.getEndDate().compareTo(target.getEndDate()) >= 0;
    }
  }
  
  boolean isMatchedTime(DateTime target) {
    if (limit.getStartTime() == null) {
      /*compares specific time*/ 
      return limit.getEndTime().equals(target.getEndTime());
    } else {
      /*compare for bounded period of time*/
      return target.getStartTime() != null 
          && limit.getStartTime().compareTo(target.getStartTime()) <= 0
          && limit.getEndTime().compareTo(target.getEndTime()) >= 0;
    }
  }

  boolean isMatched(DateTime target) {
    if (limit == null) {               //If no limit provided, returns all tasks
      return true;
    } else if (limit.getEndTime() == null) {
      return isMatchedDate(target);
    } else if (limit.getEndDate() == null) {
      return isMatchedTime(target);
    } else {
      return isMatchedDate(target) && isMatchedTime(target);
    }
  }

  boolean isMatchedFutureTasks(DateTime target) {
    return target.getEndDate().compareTo(limit.getStartDate()) >= 0;
  }
  
  /**
   * Returns MAX number of tasks after tomorrow 
   * @param pendingTasks
   * @return
   */
  List<Task> getFutureTasks(List<Task> pendingTasks, int MAX) {
     List<Task> result = pendingTasks.stream().filter(t -> isMatchedFutureTasks(
         t.getDateTime())).collect(Collectors.toList());
     if (result.size() > MAX) {
       return result.subList(0, MAX);
     } else {
       return result;
     }
  }

  @Override
  public List<Task> filter(List<Task> tasks) {
    if (limit == null) {
      return inputTasks;
    }
    tasks = TaskUtils.getOnlyNormalTasks(tasks);
    if (limit.getEndDate() == null) {
      return getFutureTasks(tasks, Constants.MAX_TASKS);
    }
    return tasks.stream().filter(task -> isMatched(task.getDateTime())).
        collect(Collectors.toList());
  }
  
  /**
   * Filter tasks based on common dates such as tomorrow and today
   * @param tasks
   * @param view
   * @return tasks filtered with given view
   */
  public List<Task> filter(List<Task> tasks, Constants.View view) {
    limit = view.getDateTime();
    tasks = TaskUtils.getOnlyNormalTasks(tasks);
    if (view == Constants.View.FUTURE) {
      return getFutureTasks(tasks, Constants.MAX_TASKS);
    }
    return tasks.stream().filter(task -> isMatched(task.getDateTime())).
        collect(Collectors.toList());
  }

}
```
###### src\main\raijin\common\filter\PriorityFilter.java
``` java

package raijin.common.filter;

import java.util.List;
import java.util.stream.Collectors;

import raijin.common.datatypes.Task;

/**
 * Filter tasks based on priority
 * @author papa
 *
 */
public class PriorityFilter extends TaskFilter {

  private String priority;
  
  public PriorityFilter(String priority) {
    this.priority = priority;
  }

  @Override
  public List<Task> filter(List<Task> tasks) {
    return tasks.stream().filter(task -> task.getPriority().equals(priority)).
        collect(Collectors.toList());
  }

}
```
###### src\main\raijin\common\filter\SortFilter.java
``` java

package raijin.common.filter;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;

/**
 * Sorts tasks according to specified criteria
 * @author papa
 *
 */
public class SortFilter extends TaskFilter {

  //Sort by comparing deadlines
  Comparator<Task> byDeadline = (t1, t2) -> t1.getDateTime().compareTo(
      t2.getDateTime());

  //Sort by comparing number of tags
  Comparator<Task> byTag = (t1, t2) -> t1.getTags().size() - t2.getTags().size();

  //Sort lexicographically sort case insensitive
  Comparator<Task> byName = (t1, t2) -> t1.getName().toLowerCase().compareTo(
      t2.getName().toLowerCase());

  //Sort by priority
  Comparator<Task> byPriority = (t1, t2) -> comparePriority(t2.getPriority()
      , t1.getPriority());


  Comparator<Task> sortCriteria;

  boolean isReversed = false;

  public SortFilter(Constants.SORT_CRITERIA criteria) {
     switch(criteria) {

      case DEADLINE:
        sortCriteria = byDeadline;
        break;

      case NAME:
        sortCriteria = byName;
        break;

      case PRIORITY:
        sortCriteria = byPriority;
        break;

      case TAG:
        sortCriteria = byTag;
        break;

      default:
        sortCriteria = byDeadline;                                              //resolve to sorting by deadline 
        break;
       
     }
  }

  int getPriorityValue(String priority) {
    int result = 1;
    if (priority.equals("m")) {
      return result;
    } else {
      result = priority.equals("l") ? 0 : 2;
      return result;
    }
  }
  
  int comparePriority(String source, String target) {
    int sourceVal = getPriorityValue(source);
    int targetVal = getPriorityValue(target);
    return sourceVal - targetVal;
  }

  @Override
  public List<Task> filter(List<Task> tasks) {
    List<Task> sorted = tasks.stream().sorted(sortCriteria).collect(Collectors.toList());
    if (isReversed) {
      Collections.reverse(sorted);
    }
    return sorted;
  }
  
  /*sorts in reverse order */
  public void setReverse() {
    isReversed = true;
  }

}
```
###### src\main\raijin\common\filter\TagFilter.java
``` java

package raijin.common.filter;

import java.util.List;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.collections4.CollectionUtils;

import raijin.common.datatypes.Task;

/**
 * Filter tasks based on tags specified 
 * @author papa
 *
 */
public class TagFilter extends TaskFilter {

  private TreeSet<String> limitTags;

  public TagFilter(TreeSet<String> tags) {
    limitTags = tags;
  }

  @Override
  public List<Task> filter(List<Task> tasks) {
    return tasks.stream().filter(
        task -> CollectionUtils.intersection(limitTags, task.getTags()).
        size() == limitTags.size()).collect(Collectors.toList());
  }

}
```
###### src\main\raijin\common\filter\TaskFilter.java
``` java

package raijin.common.filter;

import java.util.List;

import raijin.common.datatypes.Task;

public abstract class TaskFilter {
  
  protected List<Task> inputTasks;
  
  protected List<Task> and(TaskFilter other) {
    return filter(other.filter(inputTasks));
  }
  public abstract List<Task> filter(List<Task> tasks);
  
}
```
###### src\main\raijin\common\filter\TypeFilter.java
``` java

package raijin.common.filter;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.List;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;

/**
 * Filter by type of task
 * @author papa
 *
 */
public class TypeFilter extends TaskFilter {

  private Constants.TYPE_TASK limit;                                            //type of task to be filtered
  
  public TypeFilter(Constants.TYPE_TASK limit) {
    this.limit = limit;             
  }

  @Override
  public List<Task> filter(List<Task> tasks) {
    if (limit == Constants.TYPE_TASK.OVERDUE) {
      return getOverdueTasks(tasks);
    }
    return getFloatingTasks(tasks);
  }
  
  List<Task> getOverdueTasks(List<Task> tasks) {
    /*current date and time used for comparison*/
    DateTime current = new DateTime(LocalDate.now(), null, LocalDate.now(), 
        LocalTime.now());

    List<Task> result = tasks.stream().filter(t -> t.getType() != Constants.TYPE_TASK.FLOATING
        && t.getDateTime().compareTo(current) < 0)
        .collect(Collectors.toList());
    return result;
  }

  List<Task> getFloatingTasks(List<Task> tasks) {
    List<Task> floating = tasks.stream().filter(t -> t.getType() == limit).collect(Collectors
        .toList());
    return new SortFilter(Constants.SORT_CRITERIA.PRIORITY).filter(floating);
  }

}
```
###### src\main\raijin\common\utils\IDManager.java
``` java

package raijin.common.utils;

import java.util.HashMap;
import java.util.TreeSet;

import raijin.common.datatypes.Task;

/**
 * Manages ids associated with a task
 * @author papa
 *
 */
public class IDManager {

  private static IDManager idManager = new IDManager();
  private int MAX_ID = 200;                                                     //Set maximum number of todos
  private TreeSet<Integer> idPool = new TreeSet<Integer>();
  
  public IDManager() {
    initIdPool(1);
  }
  
  public static IDManager getIdManager(){
    return idManager;
  }

  void initIdPool(int initial) {
    for (int i = initial; i <= MAX_ID; i++) {
      idPool.add(i);
    }
  }

  /*Used with care because refreshes all id pools*/
  public void flushIdPool(){
    idPool.clear();
    initIdPool(1);
  }

  void increaseLimit() {
    int OLD_MAX_ID = MAX_ID;
    MAX_ID += MAX_ID*2;
    initIdPool(OLD_MAX_ID+1);
  }

  public int getId() {
    if (idPool.isEmpty()) {                                                     
      increaseLimit();                                                          //Add more ids to current pool
    }
    return idPool.pollFirst();
  }

  /**
   * 
   * @param id
   * recycle unused id into the idPool
   */
  public void returnId(int id) {
    idPool.add(id);
  }


  /**
   * Removes id that already exists in storage when application is launched
   * @param pendingTasks 
   */
  public void updateIdPool(HashMap<Integer, Task> pendingTasks) {
    if (pendingTasks.size() >= MAX_ID) {
      int initial = MAX_ID;
      MAX_ID += pendingTasks.size();
      initIdPool(initial+1);
    }

    for (int id : pendingTasks.keySet()) {
      idPool.remove(id);
    }
  }

  public TreeSet<Integer> getIdPool(){
    return idPool;
  }
  
  public void setIdPool(TreeSet<Integer> idPool) {
    this.idPool = idPool;
  }

  void setMaxId(int MAX_ID) {
    this.MAX_ID = MAX_ID;
  }

  int getMaxId() {
    return MAX_ID;
  }

}
```
###### src\main\raijin\common\utils\RaijinLogger.java
``` java

package raijin.common.utils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import raijin.ui.Raijin;

/**
 * Wrapper for logback logger
 * @author papa
 *
 */
public class RaijinLogger {

  private static final Logger logger = LoggerFactory.getLogger(Raijin.class);
  private RaijinLogger() {}
  
  public static Logger getLogger() {
    return logger;
  }
}
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  // ===========================================================================
  // Helper functions to retrieve different properties of task
  // ===========================================================================

  /**
   * Get set of tags created by user
   * @param pendingTasks
   * @return set of tags
   */
  public static TreeSet<String> getTags(HashMap<Integer, Task> pendingTasks) {
    TreeSet<String> tags = new TreeSet<String>();

    for (Task task : pendingTasks.values()) {
      tags.addAll(task.getTags());
    }
    return tags;
  }

  /**
   * Keep track of tasks associated with a tag for display on sidebar
   * @param pendingTasks
   * @return
   */
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  public static Multiset<String> getTagMultiSet(List<Task> pendingTasks) {
    Multiset<String> tags = HashMultiset.create();
    for (Task task : pendingTasks) {
      tags.addAll(task.getTags());
    }
    return tags;
  }

  /**
   * Retrieves set of task names
   * @return set of task names
   */
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  public static TreeSet<String> getTaskNames(HashMap<Integer, Task> pendingTasks) {
    List<String> names =
        pendingTasks.entrySet().stream().map(e -> e.getValue().getName())
            .collect(Collectors.toList());
    return new TreeSet<String>(names);
  }
  
 
  /**
   * Get tasks that matches name provided
   * @param pendingTasks
   * @param name
   * @return
   */
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  public static List<Task> filterTaskWithName(HashMap<Integer, Task> pendingTasks, 
      String name) {
    List<Task> filtered = pendingTasks.values().stream().filter(
        t -> t.getName().equals(name)).collect(Collectors.toList());
    return filtered;
  }

  /**
   * Get a list of tasks that matches these tags 
   * @param pendingTasks    
   * @param tags            tags that will be matched with
   * @return filtered       tasks associated with all the tags 
   */
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  public static List<Task> filterTaskWithTags(HashMap<Integer, Task> pendingTasks,
      TreeSet<String> tags) {
      
      List<String> sanitizedTags = getSanitizedTags(tags);
      List<Task> filtered = pendingTasks.values().stream().filter(
            t -> !CollectionUtils.intersection(t.getTags(), sanitizedTags).isEmpty())
            .collect(Collectors.toList());
      return filtered;
  }
  
  /*Sanitize tag input*/
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  static String removeHashTag(String tag) {
    if (tag.startsWith("#")) {
      return tag.substring(1);
    }
    return tag;
  }
  
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  public static List<String> getSanitizedTags(TreeSet<String> tags) {
    return tags.stream().map(tag -> removeHashTag(tag)).collect(Collectors.toList());
  }
  

  /**
   * Returns sorted pending tasks without ids attached
   * @param tasks
   * @return
   */
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  public static List<Task> getTasksList(HashMap<Integer, Task> tasks) {
    List<Task> result = new ArrayList<Task>(tasks.values());
    Collections.sort(result);
    return result;
  }

  /**
   * Get only tasks that has a deadline
   * @param tasks
   * @return
   */
```
###### src\main\raijin\common\utils\TaskUtils.java
``` java
  public static List<Task> getOnlyNormalTasks(List<Task> tasks) {
    return tasks.stream().filter(t -> t.getType() != Constants.TYPE_TASK.FLOATING).
        collect(Collectors.toList());
  }
}
```
###### src\main\raijin\logic\api\CommandRunner.java
``` java

package raijin.logic.api;


import java.util.TreeSet;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.exception.RaijinException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.IDManager;
import raijin.common.utils.RaijinLogger;
import raijin.logic.parser.ParsedInput;
import raijin.storage.api.History;
import raijin.storage.api.Session;
import raijin.storage.api.TasksManager;

public abstract class CommandRunner {

  protected Logger logger = RaijinLogger.getLogger();
  protected TasksManager tasksManager = TasksManager.getManager();
  protected History history = History.getHistory();
  protected Session session = Session.getSession();
  protected RaijinEventBus eventbus = RaijinEventBus.getInstance();
  //protected raijin.common.utils.EventBus eventBus = raijin.common.utils.EventBus.getEventBus();
  protected IDManager idManager = IDManager.getIdManager();

  protected abstract Status processCommand(ParsedInput input) throws UnableToExecuteCommandException;

  public final Status execute(ParsedInput input) throws UnableToExecuteCommandException {
    return handleCommandException(input);
  }
  
  /**
   * Template method to handle exception thrown by execution of a command
   * @param input       parsed input
   * @return
   * @throws UnableToExecuteCommandException 
   */
  public Status handleCommandException(ParsedInput input) throws UnableToExecuteCommandException {
      translateIds(input);
      return processCommand(input);
  }

  int getRealId(int displayedId) throws UnableToExecuteCommandException {
    try {
      return eventbus.getDisplayedTasks().get(displayedId-1).getId();
    } catch (IndexOutOfBoundsException e) {
      throw new UnableToExecuteCommandException("Does not match displayed task", e);
    }
  }

  /**
   * Translate virtual id on view to real task id for multiple ids
   * @param input
   * @throws UnableToExecuteCommandException
   */
  public void translateIds(ParsedInput input) throws UnableToExecuteCommandException {
    TreeSet<Integer> translated = new TreeSet<Integer>();
    if (input.getId() != 0) {
      for (int id : input.getIds()) {
        translated.add(getRealId(id));
      }
      input.setId(translated);
    }
  }
  
  protected void wrapLowerLevelException(RaijinException e, 
    Constants.Command typeOfCommand) throws UnableToExecuteCommandException {
    throw new UnableToExecuteCommandException(e.getMessage(), typeOfCommand, e);
  }
  
  /*trim task name to fit max length*/
  protected String normalizeTaskName(String taskName) {
    if (taskName.length() > Constants.MAX_NAME_LENGTH) {
      return StringUtils.left(taskName, Constants.MAX_NAME_LENGTH) + "...";
    }
    return taskName;
  }

}
```
###### src\main\raijin\logic\api\CommandRunnerFactory.java
``` java

package raijin.logic.api;

import raijin.common.datatypes.Constants;
import raijin.logic.command.AddCommandRunner;
import raijin.logic.command.DeleteCommandRunner;
import raijin.logic.command.DisplayCommandRunner;
import raijin.logic.command.DoneCommandRunner;
import raijin.logic.command.EditCommandRunner;
import raijin.logic.command.ExitCommandRunner;
import raijin.logic.command.RedoCommandRunner;
import raijin.logic.command.SearchCommandRunner;
import raijin.logic.command.SetCommandRunner;
import raijin.logic.command.UndoCommandRunner;
import raijin.logic.command.HelpCommandRunner;

/**
 * Factory to create CommandRunner objects based on available commands
 * @author papa
 */
public class CommandRunnerFactory {

  private CommandRunnerFactory() {}

  public static CommandRunner getCommandRunner(Constants.Command cmd) {
    switch (cmd) {

      case ADD:
        return new AddCommandRunner();

      case EDIT:
        return new EditCommandRunner();

      case SEARCH:
        return new SearchCommandRunner();

      case DELETE:
        return new DeleteCommandRunner();

      case DISPLAY:
        return new DisplayCommandRunner();

      case UNDO:
        return new UndoCommandRunner();
        
      case REDO:
        return new RedoCommandRunner();

      case EXIT:
        return new ExitCommandRunner();

      case DONE:
        return new DoneCommandRunner();
        
      case HELP:
        return new HelpCommandRunner();

      case SET:
        return new SetCommandRunner();

      default:
        throw new IllegalArgumentException();
    }
  }

}
```
###### src\main\raijin\logic\api\Logic.java
``` java

package raijin.logic.api;

import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.List;

import org.slf4j.Logger;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.FailedToParseException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.RaijinLogger;
import raijin.common.utils.TaskUtils;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.ParserInterface;
import raijin.logic.parser.SimpleParser;
import raijin.logic.realtime.AutoComplete;
import raijin.storage.api.Session;
import raijin.storage.api.TasksManager;


/**
 * Main class that handles communication with other components
 * @author papa
 */
public class Logic {

  private ParserInterface parser;
  private Session session;
  private Logger logger;
  private AutoComplete autoComplete;
  private HashMap<Constants.Command, CommandRunner> commandRunners;
  
  public Logic() throws FileNotFoundException {
    initAssets();                              
  }
  
  /*Initialiaze required assets*/
  private void initAssets() {
    parser = new SimpleParser();
    session = Session.getSession();
    logger = RaijinLogger.getLogger();
    autoComplete = new AutoComplete(TasksManager.getManager());
    commandRunners = new HashMap<Constants.Command, CommandRunner>();
    setupCommandRunners();

  }

  /**
   * Invokes command runner based on user input
   * @param userInput       
   * @return Status         status of executing the command
   */
  public Status executeCommand(String userInput) {
    try {
      ParsedInput parsed = parser.parse(userInput);
      CommandRunner cmdRunner = CommandRunnerFactory.getCommandRunner(parsed.getCommand());
      return cmdRunner.execute(parsed);
    } catch (UnableToExecuteCommandException | FailedToParseException e) {
      logger.error(e.getMessage(), e);
      return new Status(e.getMessage(), false);
    } 
  }
  

  //===========================================================================
  // Session methods
  //===========================================================================

  public void setChosenUserStorage(String userPath) {
    /*Append data folder to the path*/
    String storagePath = userPath + Constants.NAME_USER_FOLDER;
    session.setStorageDirectory(storagePath, session.baseConfigPath);
  }

  /*for UI to save on closing when exiting*/
  public Session getSession() {
	  return this.session;
  }
  
  //===========================================================================
  // Auxilliary commands
  //===========================================================================
  
  public void exit() {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.EXIT)
      .createParsedInput();
    try {
      CommandRunner cmdRunner = CommandRunnerFactory.getCommandRunner(
          Constants.Command.EXIT);
      cmdRunner.execute(input);
    } catch (UnableToExecuteCommandException e) {
      logger.error(e.getMessage());
    }
  }

  /*Initialise all command runners*/
  void setupCommandRunners() {
    for (Constants.Command cmd : Constants.Command.values()) {
      commandRunners.put(cmd, CommandRunnerFactory.getCommandRunner(cmd));
    }
  }
  
  public List<Task> getPendingTasks() {
    return TaskUtils.getTasksList(TasksManager.getManager().getPendingTasks());
  }

  public List<Task> getCompletedTasks() {
    return TaskUtils.getTasksList(TasksManager.getManager().getCompletedTasks());
  }

  /**
   * Used by developers to load custom JSON file 
   * @param fileName
   */
  public void loadCustomData(String fileName) {
    String dataPath = session.programDirectory + "/" + fileName + ".json";
    session.loadCustomJSON(dataPath);
  }
  
}
```
###### src\main\raijin\logic\api\UndoableRedoable.java
``` java

package raijin.logic.api;

import raijin.common.exception.UnableToExecuteCommandException;

/**
 * 
 * Indicates that a command supports undo and redo
 * @author papa
 */
public interface UndoableRedoable {
  
  public void undo() throws UnableToExecuteCommandException;
  public void redo() throws UnableToExecuteCommandException;

}
```
###### src\main\raijin\logic\command\AddCommandRunner.java
``` java

package raijin.logic.command;

import java.util.ArrayList;

import org.apache.commons.lang.StringUtils;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.UndoableRedoable;
import raijin.logic.parser.ParsedInput;

/**
 * Command to add task(s)
 * @author papa
 *
 */
public class AddCommandRunner extends CommandRunner implements UndoableRedoable {

  static final String SUCCESS_SINGLE_MSG = "You have added \"%s\" successfully";
  static final String SUCCESS_MSG = "You have added the tasks successfully";
  static final String FAILURE_MSG = "Duplicate task(s) not added";
  private ArrayList<Task> listOfTasks = new ArrayList<Task>();
  private int addedTasks = 0;

  /*Generates task object from parsed user input*/
  void createTasks(ParsedInput input) {
    listOfTasks.clear();
    for (String name : input.getNames()) {
      listOfTasks.add(new Task(name, idManager.getId(), input));
    }
  }

  /*Generates status for single task*/
  Status createSingleStatus(String taskName) {
    taskName = normalizeTaskName(taskName);
    return new Status(String.format(SUCCESS_SINGLE_MSG, taskName));
  }

  /*Generates status of command execution*/
  Status createStatus() {
    /*Compares number of tasks added with those specified by user*/
    if (addedTasks == listOfTasks.size()) {                 
      if (listOfTasks.size() == 1) {
        return createSingleStatus(listOfTasks.get(0).getName());
      }
      return new Status(SUCCESS_MSG);
    } else {
      return new Status(FAILURE_MSG, false);
    }
  }

  public Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {
    createTasks(input);

    for (Task task : listOfTasks) {
      /*Adds a task if it is not a duplicate*/
      if (!tasksManager.getPendingTasks().containsValue(task)) {
        addedTasks++;
        tasksManager.addPendingTask(task);
      }
    }

    /*Push command to undo stack provided one task can be added successfully*/
    if (addedTasks > 0) {
      history.pushCommand(this);
    }

    return createStatus();
  }

  public void undo() throws UnableToExecuteCommandException {
    for (Task task : listOfTasks) {
      logger.info("Undoing task id {} with content {}", task.getId(), task.getName());

      try {
        tasksManager.deletePendingTask(task.getId());
      } catch (NoSuchTaskException e) {
        wrapLowerLevelException(e, Constants.Command.ADD);
      }
    }
  }

  public void redo() {
    for (Task task : listOfTasks) {
      /*Need to get new id as previous id may be used by other task*/
      task.setId(idManager.getId()); 
      logger.info("Re-adding task id {} with content {}", task.getId(),
          task.getName());
      tasksManager.addPendingTask(task);
    }
  }

}
```
###### src\main\raijin\logic\command\RedoCommandRunner.java
``` java

package raijin.logic.command;

import com.google.common.eventbus.Subscribe;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.eventbus.MainSubscriber;
import raijin.common.eventbus.events.SetFeedbackEvent;
import raijin.common.eventbus.events.UndoRedoEvent;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.CommandShortcut;
import raijin.logic.parser.ParsedInput;

/**
 * Executes redo command of a command runner
 * @author papa
 *
 */
public class RedoCommandRunner extends CommandRunner implements CommandShortcut {

  public RedoCommandRunner() {
    handleKeyEvent();
  }

  @Override
  protected Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {
    history.redo();
    return new Status(Constants.FEEDBACK_REDO_SUCCESS);
  }

  /*Update feedback bar*/
  void sendFeedbackEvent(String msg) {
    eventbus.post(new SetFeedbackEvent(msg));
  }

  /*Handles shortcut to call redo*/
  public void handleKeyEvent() {
    MainSubscriber<UndoRedoEvent> redoKeySubscriber = new MainSubscriber<
        UndoRedoEvent>(eventbus.getEventBus()) {

      @Subscribe
      @Override
      public void handleEvent(UndoRedoEvent event) {
        if (event.canRedo) {
          try {
            history.redo();
            sendFeedbackEvent(Constants.FEEDBACK_REDO_SUCCESS);
          } catch (UnableToExecuteCommandException e) {
            logger.error(e.getMessage());
          }
        }
      }};
  }

}
```
###### src\main\raijin\logic\command\SearchCommandRunner.java
``` java

package raijin.logic.command;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.TreeSet;
import java.util.stream.Collectors;

import org.apache.commons.collections4.CollectionUtils;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.TaskUtils;
import raijin.logic.api.CommandRunner;
import raijin.logic.parser.ParsedInput;

/**
 * Searches tasks based on keywords, tags and priority
 * @author papa
 *
 */
public class SearchCommandRunner extends CommandRunner {

  private static final String DISPLAY_MESSAGE = "Search results: %d found";
  private static final String INITIAL_FEEDBACK_MESSAGE = "Search: ";
  private static final String MESSAGE_TEMPLATE = "\"%s\", ";
  String displayMessageSent;            //Search result message displayed  

  private Task currentTask;
  private String inputPriority;
  /**
   * Additional filter to search. If no priority given, default to true
   * @param task
   * @return
   */
  boolean handlePriority(Task task, String priority) {
    if (priority == null) {
      return true;
    } else {
      return task.getPriority().equals(inputPriority);
    }
  }


  void createTask(ParsedInput input) {
    currentTask = new Task(input.getName(), idManager.getId(), input);
  }

  public void appendKeywords(ArrayList<String> keywords, StringBuilder strBuilder) {
    for (String keyword : keywords) {
      if (!keyword.equals("")) {
        strBuilder.append(String.format(MESSAGE_TEMPLATE, keyword));
      }
    }
  }

  public void appendTags(StringBuilder strBuilder) {
    for (String tag : currentTask.getTags()) {
      strBuilder.append(String.format(MESSAGE_TEMPLATE, "#" + tag));
    }
  }

  /**
   * Get full string representation of a priority
   * @param priority
   * @return
   */
  String getFullPriority(String priority) {
    String fullPriority = "Medium priority";
    if (priority.equals(Constants.PRIORITY_HIGH)) {
      fullPriority = "High priority";
    } else if (priority.equals(Constants.PRIORITY_LOW)) {
      fullPriority = "Low priority";
    }
    return fullPriority;
  }

  String appendPriority(String feedback) {
    if (inputPriority != null) {
      return feedback + " " + getFullPriority(inputPriority);
    }
    return feedback;
  }

  String createFeedbackMessage(ArrayList<String> keywords, StringBuilder strBuilder) {
    appendKeywords(keywords, strBuilder);
    appendTags(strBuilder);
    String result = strBuilder.toString();
    /*Checks if any message is added to string builder*/
    if (!result.equals(INITIAL_FEEDBACK_MESSAGE)) {
      /*Removes hanging comma*/
      result = result.substring(0, result.length()-2);
    }
    result = appendPriority(result);
    return normalizeTaskName(result);
  }


  Status createSuccessfulStatus(ArrayList<String> keywords) {
    StringBuilder strBuilder = new StringBuilder(INITIAL_FEEDBACK_MESSAGE);
    /*Generates feedback message*/
    String feedback = createFeedbackMessage(keywords, strBuilder);
    return new Status(feedback);
  }




  /*checks if the task matches tag query*/
  public boolean matchOnlyTags(Task task, TreeSet<String> tags) {
    return handlePriority(task, inputPriority) && CollectionUtils.intersection(
        tags, task.getTags()).size() == tags.size();
  }

  /*checks if the task matched keyword(s) query*/
  public boolean matchOnlyKeyword(ArrayList<String> source, Task task) {
    ArrayList<String> target = task.getKeywords();
    target = (ArrayList<String>) target.stream().map(k -> k.toLowerCase())
        .collect(Collectors.toList());
    source = (ArrayList<String>) source.stream().map(k -> k.toLowerCase())
        .collect(Collectors.toList());
    return handlePriority(task, inputPriority) && CollectionUtils.intersection(
        target,source).size() == source.size();
  }

  boolean isMatchedKeywords(ArrayList<String> source, Task task) {
    if (source.get(0) == "") {                                                  //Checks if keywords are empty
      return matchOnlyTags(task, currentTask.getTags());                        
    } else if (currentTask.getTags().isEmpty()) {                               //Checks if tags are empty
      return matchOnlyKeyword(source, task);
    } else {
      return matchOnlyKeyword(source, task) && matchOnlyTags(task, currentTask.getTags());
    }

  }

  List<Task> getTasksWithMatchedKeyword(ArrayList<Task> pendingTasks) {
    ArrayList<String> keywords = currentTask.getKeywords();
    List<Task> filtered = pendingTasks.stream().filter(
        x -> isMatchedKeywords(keywords, x)).collect(Collectors.toList());
    return filtered;
  }

  @Override
  protected Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {
    inputPriority = input.getPriority();            //Update priority
    List<Task> filtered = new ArrayList<Task>();

    HashMap<Integer, Task> pendingTasks = tasksManager.getPendingTasks();
    createTask(input);
    ArrayList<Task> tempList = (ArrayList<Task>) TaskUtils.getTasksList(pendingTasks);
    filtered = getTasksWithMatchedKeyword(tempList);
    displayMessageSent = String.format(DISPLAY_MESSAGE,filtered.size());
    eventbus.post(new SetCurrentDisplayEvent(filtered, displayMessageSent));
    return createSuccessfulStatus(currentTask.getKeywords());
  }



}
```
###### src\main\raijin\logic\command\SetCommandRunner.java
``` java

package raijin.logic.command;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.logic.api.CommandRunner;
import raijin.logic.parser.ParsedInput;
import raijin.storage.handler.StorageHandler;

/**
 * Sets storage directory specified by user
 * @author papa
 *
 */
public class SetCommandRunner extends CommandRunner {

  static final String SUCCESS_MESSAGE = "Your data is now safe at %s";
  static final String FAIL_MESSAGE = "You have provided an invalid path. Please"
      + " make sure that the folder exists";

  @Override
  protected Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {
    /*Obtain path of directory*/
    String storagePath = input.getHelperOption();

    if (StorageHandler.isDirectory(storagePath)) {          
      storagePath = input.getHelperOption() + Constants.NAME_USER_FOLDER;
      session.setStorageDirectory(storagePath, session.baseConfigPath);
      return new Status(String.format(SUCCESS_MESSAGE, storagePath));
    }
    return new Status(FAIL_MESSAGE, false);            
  }

}
```
###### src\main\raijin\logic\command\UndoCommandRunner.java
``` java

package raijin.logic.command;

import com.google.common.eventbus.Subscribe;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.eventbus.MainSubscriber;
import raijin.common.eventbus.events.SetFeedbackEvent;
import raijin.common.eventbus.events.UndoRedoEvent;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.CommandShortcut;
import raijin.logic.parser.ParsedInput;

/**
 * Executes undo of a command runner
 * @author papa
 *
 */
public class UndoCommandRunner extends CommandRunner implements CommandShortcut {

  public UndoCommandRunner() {
    handleKeyEvent();
  }

  @Override
  public Status processCommand(ParsedInput cmd) throws UnableToExecuteCommandException {
    history.undo();
    return new Status(Constants.FEEDBACK_UNDO_SUCCESS);
  }

  /*Update feedback bar*/
  void sendFeedbackEvent(String msg) {
    eventbus.post(new SetFeedbackEvent(msg));
  }

  /*handles shortcut to call undo*/
  public void handleKeyEvent() {
    MainSubscriber<UndoRedoEvent> undoKeySubscriber = new MainSubscriber<
        UndoRedoEvent>(eventbus.getEventBus()) {

      @Subscribe
      @Override
      public void handleEvent(UndoRedoEvent event) {
        if (event.canUndo) {
          try {
            Thread.sleep(500);
          } catch (InterruptedException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
          }
          try {
            history.undo();
            sendFeedbackEvent(Constants.FEEDBACK_UNDO_SUCCESS);
          } catch (UnableToExecuteCommandException e) {
            logger.error(e.getMessage());
          }
        }
      }};
  }
  
}
```
###### src\main\raijin\logic\parser\ParsedInput.java
``` java

package raijin.logic.parser;

import java.util.Collection;
import java.util.TreeSet;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Status;

public class ParsedInput {
  
  //===========================================================================
  // Properties of Parsed Input 
  //===========================================================================
  
  private Constants.Command command;            
  private TreeSet<Integer> id = new TreeSet<Integer>();
  private TreeSet<String> name = new TreeSet<String>();
  private DateTime dateTime;
  private String displayOptions;                  
  private TreeSet<String> tags = new TreeSet<String>();
  private int subTaskOf = 0;                                     //Default to sentinel value 0
  private String priority;              
  private String helperOption;                                   //Stores argument for helper command
  private String project;

  //===========================================================================
  // Private constructor
  //===========================================================================
  
  /*Private contructor because only used by nested Builder class*/
  private ParsedInput(
    final Constants.Command command,
    final TreeSet<Integer> id,
    final TreeSet<String> name,
    final DateTime dateTime, 
    final String displayOptions, 
    final TreeSet<String> tags,
    final int subTaskOf,
    final String priority,
    final String helperOption,
    final String project) {

    this.command = command;
    this.id = id;
    this.name = name;
    this.dateTime = dateTime;
    this.displayOptions = displayOptions;
    this.tags = tags;
    this.subTaskOf = subTaskOf;
    this.priority = priority;
    this.helperOption = helperOption;
    this.project = project;
  }

  //===========================================================================
  // Getters 
  //===========================================================================

  public Constants.Command getCommand() {
    return command;
  }

  public int getId() {
    if (id.isEmpty()) {
      return 0;                     // If not assigned, default to 0
    }
    return id.first();
  }
  
  /*Returns a group of ids for bulk processing*/
  public TreeSet<Integer> getIds() {
    return id;
  }

  public void setId(TreeSet<Integer> ids) {
    this.id = ids;
  }

  public String getName() {
    if (name.isEmpty()) {           // If not assigned, default to empty string
      return "";
    }
    return name.first();
  }

  /*Returns a group of names for bulk processing*/
  public TreeSet<String> getNames() {
    return name;
  }

  public DateTime getDateTime() {
    return dateTime;
  }

  public String getDisplayOptions() {
    return displayOptions;
  }
  
  public void setTags(TreeSet<String> tags) {
    this.tags = tags;
  }

  public TreeSet<String> getTags() {
    return tags;
  }

  public int getSubTaskOf() {
    return subTaskOf;
  }

  public String getPriority() {
    return priority;
  }
  
  public String getHelperOption() {
    return helperOption;
  }

  public String getProject() {
    return project;
  }

  //===========================================================================
  // Builder Class
  //===========================================================================

  public static class ParsedInputBuilder {
    private final Constants.Command command;
    private TreeSet<Integer> id = new TreeSet<Integer>();
    private TreeSet<String> name = new TreeSet<String>();
    private DateTime dateTime;
    private String displayOptions;
    private TreeSet<String> tags = new TreeSet<String>();
    private int subTaskOf;
    private String priority;
    private String helperOption;
    private String project;
    
    public ParsedInputBuilder(final Constants.Command command) {
      this.command = command;
    }
    
    public ParsedInputBuilder id(final int id) {
      this.id.add(id);
      return this;
    }
    
    public ParsedInputBuilder id(final Collection<Integer> ids) {
      this.id.addAll(ids);
      return this;
    }

    public ParsedInputBuilder name(final String name) {
      this.name.add(name);
      return this;
    }
    
    public ParsedInputBuilder name(final Collection<String> names) {
      this.name.addAll(names);
      return this;
    }

    public ParsedInputBuilder dateTime(final DateTime dateTime) {
      this.dateTime = dateTime;
      return this;
    }
    
    public ParsedInputBuilder displayOptions(final String displayOptions) {
      this.displayOptions = displayOptions;
      return this;
    }
    
    public ParsedInputBuilder tag(final TreeSet<String> tags) {
      this.tags = tags;
      return this;
    }
    
    public ParsedInputBuilder subTaskOf(final int subTaskOf) {
      this.subTaskOf = subTaskOf;
      return this;
    }

    public ParsedInputBuilder priority(final String priority) {
      this.priority = priority;
      return this;
    }

    public ParsedInputBuilder helperOption(final String helperOption) {
      this.helperOption = helperOption;
      return this;
    }

    public ParsedInputBuilder project(final String project) {
      this.project = project;
      return this;
    }

    /*Generate parsedinput when client is done building the object*/
    public ParsedInput createParsedInput() {
      return new ParsedInput(command, id, name, dateTime, displayOptions, 
                             tags, subTaskOf, priority, helperOption,
                             project);
    }

  }

}
```
###### src\main\raijin\logic\parser\ParserInterface.java
``` java

package raijin.logic.parser;

import raijin.common.exception.FailedToParseException;

public interface ParserInterface {

  public ParsedInput parse(String userInput) throws FailedToParseException;

}
```
###### src\main\raijin\logic\realtime\AutoComplete.java
``` java

package raijin.logic.realtime;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.slf4j.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.MainSubscriber;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.ChangeViewEvent;
import raijin.common.eventbus.events.KeyPressEvent;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.eventbus.events.SetGuideEvent;
import raijin.common.eventbus.events.SetInputEvent;
import raijin.common.eventbus.events.SetTimeSlotEvent;
import raijin.common.exception.FailedToParseException;
import raijin.common.exception.IllegalCommandArgumentException;
import raijin.common.utils.RaijinLogger;
import raijin.common.utils.TaskUtils;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.SimpleParser;
import raijin.storage.api.TasksManager;

/**
 * Supports auto-completion of several elements such as commands, task names, tags, projects
 * 
 * @author papa
 *
 */
public class AutoComplete {

  private int tabCount = 0;
  private int viewCount = 0;
  private SetTrie commandList;                              //list of commands
  private SetTrie tagList;                                  //list of tags
  private SetTrie taskList;                                 //list of task names
  private TasksManager tasksManager;
  private SimpleParser parser;
  private Logger logger;
  private RaijinEventBus eventbus;
  private TreeSet<String> taskNames;
  private TreeSet<String> tags;
  public List<String> suggestions;
  public List<Task> selectedTasks;

  public AutoComplete(TasksManager tasksManager) {
    this.tasksManager = tasksManager;
    this.eventbus = RaijinEventBus.getInstance();
    this.logger = RaijinLogger.getLogger();
    this.parser = new SimpleParser();

    commandList = new SetTrie();
    tagList = new SetTrie();
    taskList = new SetTrie();
    tags = new TreeSet<String>();
    taskNames = new TreeSet<String>();
    suggestions = new ArrayList<String>();
    selectedTasks = new ArrayList<Task>();

    updateWithStorage();
    handleKeyEvent();
    handleTabEvent();
  }

  //===========================================================================
  // Helper
  //===========================================================================

  String getArguments(String input) {
    int index = input.trim().indexOf(" ");
    return input.substring(index + 1, input.length());
  }

  String getLastWord(String[] tokens) {
    if (tokens.length == 0) {
      return "";
    } else {
      return tokens[tokens.length - 1];
    }
  }

  String[] getTokens(String userInput) {
    return userInput.trim().split(" ");
  }


  //===========================================================================
  // Initialization
  //===========================================================================

  /* Update to latest pending task names */
  void updateTasks() {
    taskNames = TaskUtils.getTaskNames(tasksManager.getPendingTasks());
  }

  /* Update any to any recently updated tags */
  void updateTags() {
    tags = TaskUtils.getTags(tasksManager.getPendingTasks());
  }

  void loadCommandList() {
    for (Constants.Command cmd : Constants.Command.values()) {
      commandList.add(cmd.toString().toLowerCase()); // Convert enum to string and lowercase
    }
  }

  void loadTagList(TreeSet<String> tagList) {
    this.tagList.addAll(tagList);
  }

  void loadTaskList(TreeSet<String> tasks) {
    this.taskList.addAll(tasks);
  }

  /**
   * Setup database for auto completion
   * 
   * @param tagList
   * @param tasks
   */
  public void setupList(TreeSet<String> tagList, TreeSet<String> tasks) {
    loadCommandList();
    loadTagList(tagList);
    loadTaskList(tasks);
  }
  /* Overall update with states of application */
  void updateWithStorage() {
    updateTags();
    updateTasks();
    setupList(tags, taskNames);
  }

  boolean isValidCommand(String input) {
    String command = input.toUpperCase(); // To create enum command
    try {
      return Arrays.asList(Constants.Command.values()).contains(Constants.Command.valueOf(command));
    } catch (IllegalArgumentException e) {
      return false;
    }
  }

  /**
   * Update task name suggestions 
   * @param input           keywords thats will be added to suggestions
   */
  void updateTaskSuggestion(String input) {
    String[] tokens = getTokens(input);
    String command = tokens[0];

    /*Update only if command is supported*/
    if (isValidCommand(command)) {
      selectedTasks =
          TaskUtils.filterTaskWithName(tasksManager.getPendingTasks(), 
              getArguments(input));
      suggestions =
          taskList.getSuggestions(getArguments(input)).stream().map(
              str -> command + " " + str).collect(Collectors.toList());
    }
  }

  /**
   * Update tag suggestions given input
   * @param input           tags that will be added to suggetions
   */
  void updateTagSuggestion(String input) {
    String[] tokens = getTokens(input);
    String prefix = getLastWord(tokens);
    int lastTagIndex = input.lastIndexOf("#");
    String previousString = input.substring(0, lastTagIndex - 1);
    String tag = prefix.substring(1, prefix.length()); // Get tag from last word

    suggestions =
        tagList.getSuggestions(tag).stream().map(str -> previousString + " #" + str)
            .collect(Collectors.toList());
  }

  /*Checks if there is at least one word in input bar*/
  boolean isCommand(String[] tokens) {
    return tokens.length == 1;
  }

  /*Checks for presence of tag in user input*/
  boolean isTag(String[] tokens) {
    return tokens.length > 1 && getLastWord(tokens).substring(0, 1).equals("#");
  }

  /*Update suggestions lists as user is typing*/
  void updateSuggestions(String input) {
    updateWithStorage();
    String[] tokens = getTokens(input);
    String prefix = getLastWord(tokens);

    if (isCommand(tokens)) {                      //Get suggestions from commandList
      suggestions = commandList.getSuggestions(prefix);
      eventbus.post(new SetGuideEvent(false));
    } else if (isTag(tokens)) {                   //Get suggestions from tagList
      updateTagSuggestion(input);
    } else { // Get suggestions from task
      updateTaskSuggestion(input);
    }

  }

  /*Update display view with implicit search result for certain commands*/
  void updateDisplayWithTasks(String userInput) {
    System.out.println("called " + userInput);
    String command = userInput.trim().split(" ")[0];
    String prefix = getArguments(userInput);
    List<Task> filtered =
        tasksManager.getPendingTasks().values().stream()
            .filter(t -> t.getName().startsWith(prefix)).collect(Collectors.toList());
    if (!filtered.isEmpty()) {
      suggestions =
          IntStream.rangeClosed(1, filtered.size())
              .mapToObj(i -> command + " " + Integer.toString(i)).collect(Collectors.toList());
      eventbus.post(new SetCurrentDisplayEvent(filtered, "Search results:"));
    }
  }

  /**
   * Checks if the given user input contains command that needs ID field
   * 
   * @return true if command uses ID field
   */
  public boolean isCommandWithID(String userInput) {
    String[] tokens = userInput.trim().split(" ");
    if (isValidCommand(tokens[0])) {
      handleHelpForCommand(tokens[0], userInput);
      return tokens[0].equals("done") || tokens[0].equals("edit") || tokens[0].equals("delete");
    }
    return false;

  }

  /**
   * Rotate through different types of view
   * @param event   KeyEvent will be triggered every time a key is pressed
   */
  void updateDisplayView(KeyEvent event) {
    if (Constants.KEY_VIEW_DOWN.match(event) || Constants.KEY_VIEW_UP.match(event)) {
      viewCount = Constants.KEY_VIEW_DOWN.match(event) ? viewCount++ : viewCount--;
      /*Get next view index*/
      int next = Math.floorMod((viewCount), Constants.View.values().length);
      /*Get view associated with the index*/
      Constants.View view = Constants.View.values()[next];
      eventbus.post(new ChangeViewEvent(TaskUtils.getTasksList(
          tasksManager.getPendingTasks()), view));
    } 
  }

  //===========================================================================
  // Handlers
  //===========================================================================

  /**
   *  Invoke changes and perform update on suggestions
   */
  void handleKeyEvent() {
    MainSubscriber<KeyPressEvent> updateSuggestion = new MainSubscriber<
        KeyPressEvent>(eventbus.getEventBus()) {

      @Subscribe
      @Override
      public void handleEvent(KeyPressEvent event) {
        updateDisplayView(event.keyEvent);
        if (event.keyEvent.getCode() != KeyCode.TAB && event.keyEvent.getCode() != KeyCode.SPACE) {
          tabCount = 0;
          String userInput = event.currentUserInput;
          updateSuggestions(userInput);
          if (isCommandWithID(userInput)) {
            updateDisplayWithTasks(userInput);
          }
        }

      }

    };
  }

  /**
   * Set input bar with suggestion when TAB is pressed
   */
  public void handleTabEvent() {
    MainSubscriber<KeyEvent> completeOnPress = new MainSubscriber<
        KeyEvent>(eventbus.getEventBus()) {

      @Subscribe
      @Override
      public void handleEvent(KeyEvent event) {
        try {

          if (event.getCode() == KeyCode.TAB) {
            String result = suggestions.get((tabCount++) % suggestions.size());
            eventbus.post(new SetInputEvent(result));
          }

        } catch (ArithmeticException e) {
          logger.error(e.getMessage());
        }

      }
    };
  }

  /*Checks for date error so feedback can provided to user at realtime*/
  boolean isInvalidDate(FailedToParseException e) {
    return e.getCause() instanceof IllegalCommandArgumentException
        && ((IllegalCommandArgumentException) e.getCause()).getArgument().equals(
            Constants.CommandParam.DATETIME);
  }

  /*Checks for id error so feedback can provided to user at realtime*/
  boolean isInvalidId(ParsedInput input) {
    if (input.getId() != 0) {                         //Checks if id is entered

      for (int displayedId : input.getIds()) {

        try {
          eventbus.getDisplayedTasks().get(displayedId - 1).getId();
        } catch (IndexOutOfBoundsException e) {
          return true;
        }
      }
    }
    return false;
  }

  /*Checks parsed input for existence of date*/
  public boolean isDateEntered(ParsedInput parsed) {
    return parsed.getDateTime() != null && parsed.getDateTime().getEndDate() != null;
  }

  /**
   * Trigger occupied time slots if end date exists
   * @param parsed
   */
  public void handleTimeSlot(ParsedInput parsed) {
    if (isDateEntered(parsed)) {
      TimeSlot slots = new TimeSlot(parsed.getDateTime()
          .getEndDate(), TaskUtils.getTasksList(tasksManager.getPendingTasks()));
      eventbus.post(new SetTimeSlotEvent(slots.getOccupiedSlots()));
    } else {
      eventbus.post(new SetTimeSlotEvent(false));
    }
  }

  /**
   * Make guide bar visible and populate with relevant information
   * @param userInput
   * @param commandFormat
   * @param description
   */
  public void activateGuideBar(String userInput, String commandFormat, String description) {
    try {
      ParsedInput parsed = parser.parse(userInput);

      if (isInvalidId(parsed)) {
        description = Constants.ADD_INVALID_ID;
      }

      handleTimeSlot(parsed);

    } catch (FailedToParseException e) {
      if (isInvalidDate(e)) {
        description = Constants.ADD_INVALID_DATE;
      }
    }
    eventbus.post(new SetGuideEvent(commandFormat, description));
  }

  /*Handles different variations of add command format*/
  String[] handleAddHelpCommand(String userInput) {
    String[] result = new String[2];
    /*By default shows format and descripton of adding specific task*/
    result[0] = Constants.ADD_SPECIFIC;
    result[1] = Constants.ADD_SPECIFIC_DESC;

    if (userInput.contains(";")) {
      result[0] = Constants.ADD_BATCH;
      result[1] = Constants.ADD_BATCH_DESC;
    }

    if (userInput.contains("from")) {
      result[0] = Constants.ADD_EVENT_DIFFERENT_DATE;
      result[1] = Constants.ADD_EVENT_DIFFERENT_DATE_DESC;
    }

    if (userInput.contains("to")) {
      result[0] = Constants.ADD_EVENT_SAME_DATE;
      result[1] = Constants.ADD_EVENT_SAME_DATE_DESC;
    }

    return result;
  }

  /**
   * Determines format and description that will be populated in guide bar
   * @param command         
   * @param userInput       
   */
  void handleHelpForCommand(String command, String userInput) {
    /*Creates enum object from userInput*/
    Constants.Command inputCommand = Constants.Command.valueOf(command.toUpperCase());

    String commandFormat = inputCommand.cmdFormat;
    String description = inputCommand.cmdDescription;

    if (inputCommand == Constants.Command.ADD) {
      String[] result = handleAddHelpCommand(userInput);
      commandFormat = result[0];
      description = result[1];
    } 
    activateGuideBar(userInput, commandFormat, description);
  }
}
```
###### src\main\raijin\logic\realtime\SetTrie.java
``` java

package raijin.logic.realtime;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

/**
 * This is a derivative work of Sujit Pal http://sujitpal.blogspot.sg
 * Stores strings in a trie to be used for prefix searching 
 * @author papa
 *
 */
public class SetTrie {

  private TreeSet<String> wordList;

  public SetTrie() {
    wordList = new TreeSet<String>();
  }

  /**
   * Inserts word that can be autocompleted
   * @param word
   */
  public void add(String word) {
    wordList.add(word);
  }

  public void addAll(Collection<String> collection) {
    wordList.addAll(collection);
  }

  /**
   * Checks if a prefix exists in the supported word list
   * @param prefix
   * @return boolean
   */
  public boolean contains(String prefix) {
    Set<String> tailSet = wordList.tailSet(prefix);
    for (String tail : tailSet) {
      if (tail.startsWith(prefix)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Obtain list of words that matched given prefix
   * @param prefix
   * @return matched words
   */
  public List<String> getSuggestions(String prefix) {
    ArrayList<String> suggestions = new ArrayList<String>(); // Stores matched words
    Set<String> tailSet = wordList.tailSet(prefix);

    for (String tail : tailSet) {

      if (tail.startsWith(prefix)) {
        suggestions.add(tail);
      } else {
        break;
      }
    }

    return suggestions;
  }
  
  public TreeSet<String> getWordList() {
    return wordList;
  }
}
```
###### src\main\raijin\logic\realtime\TimeSlot.java
``` java

package raijin.logic.realtime;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.datatypes.Constants.TYPE_TASK;
import raijin.common.filter.DateFilter;

/**
 * Shows occupied time slot for a given date
 * @author papa
 *
 */
public class TimeSlot {
  
  /*Compares duration of a task*/
  private Comparator<DateTime> durationComparator = (d1, d2) -> 
    (int) (getDuration(d2.getStartTime(), d2.getEndTime()) 
    - getDuration(d1.getStartTime(), d1.getEndTime()));

  private DateTime dateTime;
  private DateFilter dateFilter;
  private List<Task> events;                                                    //list of events on given date 
  private List<DateTime> occupiedSlots;                                         //list of occupied time slots

  public TimeSlot(LocalDate endDate, List<Task> pendingTasks) {
    this.dateTime = new DateTime(endDate, endDate);
    dateFilter = new DateFilter(pendingTasks, dateTime);
    events = filterEvents(pendingTasks);
    occupiedSlots = events.stream().map(t -> t.getDateTime()).collect(
        Collectors.toList());
    /*sort time slots by duration*/
    Collections.sort(occupiedSlots, durationComparator);
    occupiedSlots = combineAllTimeSlots();
  }

  long getDuration(LocalTime start, LocalTime end) {
    long minute = start.until(end, ChronoUnit.MINUTES);
    return minute;
  }

  /**
   * Filters tasks for event that spans only for one day 
   * @param pendingTasks
   * @return result
   */
  List<Task> filterEvents(List<Task> pendingTasks) {
    List<Task> result = dateFilter.filter(pendingTasks).stream().filter(
        t -> t.getType().equals(Constants.TYPE_TASK.EVENT) 
        && t.getDateTime().getStartDate().equals(
           t.getDateTime().getEndDate())
        && t.getDateTime().getStartTime() != null).collect(Collectors.toList());

    return result;
  }

  /**
   * Merge two time slots based on result of comparing start time and end time
   * @param compareStartWithStart
   * @param compareEndWithEnd
   * @param source
   * @param target
   * @return
   */
  DateTime handleOverlapEvents(int compareStartWithStart, int compareEndWithEnd,
      DateTime source, DateTime target) {
    LocalTime startTime = source.getStartTime();
    LocalTime endTime = source.getEndTime();

    if (compareStartWithStart > 0) {
      startTime = target.getStartTime();
    } 

    if (compareEndWithEnd < 0) {
      endTime = target.getEndTime();
    }
    return new DateTime(source.getStartDate(), startTime, source.getEndDate(), endTime);
  }

  /*Check if there is any overlap between two events*/
  boolean isNoOverlap(int compareStartWithEnd, int compareEndWithStart) {
    return compareStartWithEnd > 0 || compareEndWithStart < 0;
  }
  
  /*Checks if the event lies within another event*/
  boolean isWithinDuration(int compareStartWithStart, int compareEndWithEnd) {
    return compareStartWithStart <= 0 && compareEndWithEnd >= 0;
  }

  /*Merge overlap two time slots into one single slot*/
  DateTime extendDuration(DateTime source, DateTime target) {

    int compareStartWithEnd = source.getStartTime().compareTo(target.getEndTime());
    int compareEndWithStart = source.getEndTime().compareTo(target.getStartTime());
    int compareStartWithStart = source.getStartTime().compareTo(target.getStartTime());
    int compareEndWithEnd = source.getEndTime().compareTo(target.getEndTime());

    if (isNoOverlap(compareStartWithEnd, compareEndWithStart)) {
      return source;
    } else if (isWithinDuration(compareStartWithStart, compareEndWithEnd)) {
      occupiedSlots.set(occupiedSlots.indexOf(target), null);
      return source;
    } else {
      DateTime merged = handleOverlapEvents(compareStartWithStart, compareEndWithEnd, source, target);
      occupiedSlots.set(occupiedSlots.indexOf(target), null);
      return merged;
    }
  }

  /*Merge iteratively with other time slots*/
  DateTime consolidateTimeSlots(DateTime source) {
    DateTime result = source;
    int index = occupiedSlots.indexOf(source);

    for (int i = index + 1 ; i < occupiedSlots.size() ; i++) {
      DateTime target = occupiedSlots.get(i);
      if (target != null) {
        result = extendDuration(result, target);
      }
    }
    return result;
  }

  /*Merge all occupied time slots*/
  List<DateTime> combineAllTimeSlots() {
    if (occupiedSlots.size() > 1) {
      List<DateTime> filtered = new ArrayList<DateTime>();

      for (DateTime source : occupiedSlots) {
        if (source != null && occupiedSlots.indexOf(source) != occupiedSlots.size() - 1) {
          filtered.add(consolidateTimeSlots(source));
        } else if (source != null) {
          filtered.add(source);
        }
      }
      return filtered;
    }
    return occupiedSlots;
  }

  public List<Task> getEvents() {
    return events;
  }
  
  public List<DateTime> getOccupiedSlots() {
    return occupiedSlots;
  }


}
```
###### src\main\raijin\storage\api\History.java
``` java

package raijin.storage.api;

import java.util.EmptyStackException;
import java.util.Stack;

import org.slf4j.Logger;

import raijin.common.datatypes.Constants;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.eventbus.events.TasksChangedEvent;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.RaijinLogger;
import raijin.common.utils.TaskUtils;
import raijin.logic.api.UndoableRedoable;

public class History {

  private RaijinEventBus eventbus;
  private static History history = new History();
  private TasksManager tasksManager;
  private Stack<UndoableRedoable> undoStack;   
  private Stack<UndoableRedoable> redoStack;   
  private Logger logger;
  
  private History() {
    undoStack = new Stack<UndoableRedoable>();
    redoStack = new Stack<UndoableRedoable>();
    tasksManager = TasksManager.getManager();
    logger = RaijinLogger.getLogger();
    eventbus = RaijinEventBus.getInstance();
  }
  
  /*Helper to write changes to file and trigger view change*/
  void reflectChanges() {
    eventbus.post(new SetCurrentDisplayEvent(TaskUtils
        .getTasksList(tasksManager.getPendingTasks()), "All pending tasks"));
    //Notify tasks changed
    eventbus.post(new TasksChangedEvent());
    Session.getSession().commit();
  }

  public static History getHistory() {
    return history;
  }

  /*Checks if there are no commands executed by users*/
  public boolean isEmptyUndoStack() {
    return undoStack.isEmpty();
  }

  /*Checks if there are no undos executed by users*/
  public boolean isEmptyRedoStack() {
    return redoStack.isEmpty();
  }
  
  /*Clears both undo and redo stacks*/
  public void clear() {
    undoStack.clear();
    redoStack.clear();
  }

  /*Add a command runner to undo stack*/
  public void pushCommand(UndoableRedoable commandRunner) {
    logger.info("{} is added to undo stack", commandRunner.getClass());
    undoStack.push(commandRunner);
    reflectChanges();
  }

  /**
   * Invoke undo of a command and update view
   * @throws UnableToExecuteCommandException
   */
  public void undo() throws UnableToExecuteCommandException {
    try {
      UndoableRedoable undoCommand = undoStack.pop();
      undoCommand.undo();
      reflectChanges();
      redoStack.add(undoCommand); // Add removed command to redo stack
    } catch(EmptyStackException e) {
      throw new UnableToExecuteCommandException("Nothing to undo", 
          Constants.Command.UNDO, e);
    }
  }

  /**
   * Invoke redo of a command and update view
   * @throws UnableToExecuteCommandException
   */
  public void redo() throws UnableToExecuteCommandException {
    try {
      UndoableRedoable redoCommand = redoStack.pop();
      redoCommand.redo();
      reflectChanges();
      undoStack.add(redoCommand); // Add command to redo stack
    } catch(EmptyStackException e) {
      throw new UnableToExecuteCommandException("Nothing to redo", 
          Constants.Command.REDO, e);
    }
  }
  
}
```
###### src\main\raijin\storage\api\Session.java
``` java

package raijin.storage.api;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;


import com.google.common.reflect.TypeToken;
import com.google.gson.JsonParseException;
import com.google.gson.stream.JsonReader;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.exception.StorageFailureException;
import raijin.common.utils.IDManager;
import raijin.common.utils.TaskUtils;
import raijin.storage.handler.StorageHandler;

public class Session {

  private static final String ERROR_FAIL_GET_STORAGE = "Cannot get storage "
      + "directory from file %s";
  private static final String ERROR_ENCODING = "Unsupported Encoding while "
      + "getting program path"; 
  private static final String ERROR_COPY_FILES = "Unable to copy temp file from "
      + "%s to overwrite %s";
  private static final String ERROR_WRITING_FILES = "Failed to write \"%s\" to %s";
  private static final String ERROR_CREATING_FILE = "Cannot create file %s";
  private static final String ERROR_CORRUPTED_JSON = "Corrupted JSON file. New "
      + "JSON file is created";
  private static final String ERROR_MISSING_JSON = "Missing JSON file. New "
      + "JSON file is created";
  private static final String ERROR_READING_JSON = "Failed to read JSON file. New "
      + "JSON file is created";

  private static Session session = new Session();
  private TasksManager tasksManager;
  private RaijinEventBus eventbus = RaijinEventBus.getInstance();

  String userConfigPath;
  String dataPath;
  String tempPath;                                 
  public String programDirectory;
  public String storageDirectory;
  public String baseConfigPath;
  public boolean isFirstTime; 

  private Session() {
    init();
  }

  public static Session getSession() {
    return session;
  }

  /**
   * Creates base config file that stores desired storage directory
   * @param baseConfigPath
   */
  void setupBaseConfig(String baseConfigPath) {
    boolean isSuccessful = createNewFile(baseConfigPath);
    if (isSuccessful) {
      writeToFile(programDirectory, baseConfigPath);
    }
  }

  /**
   * Creates folder to store application's data.
   * This may not be the same with storage directory.
   * @param basePath
   */
  public void setupBase(String basePath) {
    programDirectory = basePath;
    isFirstTime = StorageHandler.createDirectory(programDirectory); // Create working folder
    baseConfigPath = programDirectory + Constants.NAME_BASE_CONFIG;
    setupBaseConfig(baseConfigPath);
  }

  /**
   * Read storage directory from base.cfg file
   * @param baseConfigPath
   * @return
   */
  String getStorageDirectory(String baseConfigPath) {
    try {
      return StorageHandler.getStorageDirectory(baseConfigPath);
    } catch (IOException e) {
      throw new StorageFailureException(String.format(ERROR_FAIL_GET_STORAGE,
          baseConfigPath), e);
    }
  }

  /*Creates data folder at storage directory*/
  void setupDataFolder() {
    createNewFile(userConfigPath);
    createNewFile(dataPath);
  }

  void generateNewFile(String filePath) {
    StorageHandler.deleteFile(filePath);
    createNewFile(filePath);
  }

  /*Initializes tasks manager with external user data stored in JSON*/
  void initTasksManager() {
    TasksManager retrievedData = getDataFromJson(dataPath);
    if (retrievedData != null) {
      tasksManager.sync(retrievedData);
      IDManager.getIdManager().updateIdPool(tasksManager.getPendingTasks());
      eventbus.setDisplayedTasks(TaskUtils.getTasksList(tasksManager.getPendingTasks()));
    }
    generateNewFile(dataPath);                                                  
  }

  /*Setup temporary file that records all changes*/
  void setupTempPath(String tempPath) {
    this.tempPath = tempPath;
  }

  /* Needed to be separated from init to ensure user has chosen a storage location */
  public void setupStorage() {
    /* Always read from baseConfigPath to get path to ensure consistency */
    storageDirectory = getStorageDirectory(baseConfigPath);
    dataPath = storageDirectory + Constants.NAME_USER_DATA;
    userConfigPath = storageDirectory + Constants.NAME_USER_CONFIG;
    StorageHandler.createDirectory(storageDirectory);
    setupDataFolder();
    initTasksManager();
    setupTempPath(StorageHandler.createTempFile(Constants.NAME_TEMP_DATA));
  }

  /*Initialise basic paths where application is ran*/
  void init() {
    tasksManager = TasksManager.getManager();
    try {
      String basePath = StorageHandler.getJarPath() + Constants.NAME_USER_FOLDER;
      setupBase(basePath);
      setupStorage();
    } catch (UnsupportedEncodingException e) {
      throw new StorageFailureException(ERROR_ENCODING, e);
    }
  }

  /* Checks if this is the first time a user use the program */
  public boolean isFirstTime() {
    return !StorageHandler.isDirectory(programDirectory);
  }

  public void setStorageDirectory(String desiredPath, String baseConfigPath) {
    String sanitizedPath = StorageHandler.sanitizePath(desiredPath);
    writeToFile(sanitizedPath, baseConfigPath);
    setupStorage(); // trigger setup of storage after deciding storage path
  }

  /* Commit changes to a temp file */
  public void commit() {
    writeToFile(StorageHandler.convertToJson(TasksManager.getManager()), tempPath);
  }

  // ===========================================================================
  // IOException Handling
  // ===========================================================================

  public void writeOnExit() {
    commit();
    Path source = Paths.get(tempPath);
    Path target = Paths.get(dataPath);
    System.out.println(dataPath);
    try {
      StorageHandler.copyFiles(source, target);
    } catch (IOException e) {
      throw new StorageFailureException(String.format(ERROR_COPY_FILES, 
          tempPath, dataPath), e);
    }
  }

  void writeToFile(String output, String filePath) {
    try {
      StorageHandler.writeToFile(output, filePath);
    } catch (IOException e) {
      throw new StorageFailureException(String.format(ERROR_WRITING_FILES, output,
          filePath), e);
    }
  }

  /* Create new file with exception handling */
  boolean createNewFile(String filePath) {
    try {
      return StorageHandler.createFile(filePath);
    } catch (IOException e) {
      throw new StorageFailureException(String.format(ERROR_CREATING_FILE, filePath), e);
    }
  }

  @SuppressWarnings("serial")
  TasksManager getDataFromJson(String dataPath) throws StorageFailureException {
    JsonReader reader = StorageHandler.getJsonReaderFromFile(dataPath);
    try {
      TasksManager retrievedData =
          StorageHandler.readFromJson(reader, new TypeToken<TasksManager>() {}.getType());
      return retrievedData;

    } catch (JsonParseException e) {                                            // JSON file is corrupted
      generateNewFile(dataPath);                                                // Create empty JSON file
      throw new StorageFailureException(ERROR_CORRUPTED_JSON, e);

    } catch (NullPointerException e) { // JSON file is missing
      createNewFile(dataPath);
      throw new StorageFailureException(ERROR_MISSING_JSON, e);

    } catch (IOException e) {
      throw new StorageFailureException(ERROR_READING_JSON, e);
    }
  }

  //===========================================================================
  // Methodss used by developers 
  //===========================================================================

  /*Quickly load your own json file*/
  public void loadCustomJSON(String dataPath) {
    TasksManager retrievedData = getDataFromJson(dataPath);
    if (retrievedData != null) {
      tasksManager.sync(retrievedData);
      IDManager.getIdManager().updateIdPool(tasksManager.getPendingTasks());
      List<Task> result = TaskUtils.getTasksList(tasksManager.getPendingTasks());
      RaijinEventBus.getInstance().post(new SetCurrentDisplayEvent(result));
    }
  }

  public void setDataPath(String dataPath) {
    this.dataPath = dataPath;
  }

}
```
###### src\main\raijin\storage\api\TasksManager.java
``` java

package raijin.storage.api;

import java.util.HashMap;

import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.utils.IDManager;

/**
 * Manages tasks and perform operation on task needed by Command Runners
 * @author papa
 */
public class TasksManager {

  private static TasksManager tasksManager;
  private HashMap<Integer, Task> pendingTasks = new HashMap<Integer, Task>();
  private HashMap<Integer, Task> completedTasks = new HashMap<Integer, Task>();

  private TasksManager() {}

  public static TasksManager getManager() {
    if (tasksManager == null) {
      tasksManager = new TasksManager();
    }
    return tasksManager;
  }
  
  public HashMap<Integer, Task> getPendingTasks() {
    return pendingTasks;
  }

  public void setPendingTasks(HashMap<Integer, Task> pendingTasks) {
    this.pendingTasks = pendingTasks;
  }
  
  public HashMap<Integer, Task> getCompletedTasks() {
    return completedTasks;
  }

  public void setCompletedTasks(HashMap<Integer, Task> completedTasks) {
    this.completedTasks = completedTasks;
  }

  public boolean isEmptyPendingTasks() {
    return pendingTasks.isEmpty();
  }

  public boolean isEmptyCompletedTasks() {
    return completedTasks.isEmpty();
  }

  /*Sync pending and completed tasks to target tasksManager retrieved from Json file*/
  public void sync(TasksManager target) {
    if (null != target) {
      pendingTasks = target.getPendingTasks();
      completedTasks = target.getCompletedTasks();
    }
  }

  //===========================================================================
  // Command related functions
  //===========================================================================

  public void addPendingTask(Task task) {
    pendingTasks.put(task.getId(), task);
  }

  public void addCompletedTask(Task task) {
    completedTasks.put(task.getId(), task);
    IDManager.getIdManager().returnId(task.getId());
    pendingTasks.remove(task.getId());
  }

  public Task getPendingTask(int id) throws NoSuchTaskException {
    handleUnknownTask(pendingTasks, id);
    return pendingTasks.get(id);
  }

  public void deletePendingTask(int id) throws NoSuchTaskException {
    handleUnknownTask(pendingTasks, id);
    pendingTasks.remove(id);
    IDManager.getIdManager().returnId(id);
  }
  
  public void editPendingTask(int id) throws NoSuchTaskException {
    handleUnknownTask(pendingTasks, id);
    pendingTasks.remove(id);
  }

  public void deleteCompletedTask(int id) throws NoSuchTaskException {
    handleUnknownTask(completedTasks, id);
    completedTasks.remove(id);
  }
  
  void handleUnknownTask(HashMap<Integer, Task> tasks, int id) throws NoSuchTaskException {
    if (!tasks.containsKey(id)) {
      throw new NoSuchTaskException("Task ID does not match", id);
    }
  }
  

}
```
###### src\main\raijin\storage\handler\StorageHandler.java
``` java

package raijin.storage.handler;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Type;
import java.net.URLDecoder;
import java.nio.file.CopyOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

import org.slf4j.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.stream.JsonReader;

import raijin.common.utils.RaijinLogger;

/**
 * Utility static class to handle low level I/O operations
 * @author papa
 *
 */
public class StorageHandler {

  private static Logger logger = RaijinLogger.getLogger();
  private StorageHandler() {}   

  //===========================================================================
  //Regular File Operations
  //===========================================================================

  /*make paths os independent*/
  public static String sanitizePath(String path) {
    return path.replaceFirst("^/(.:/)", "$1");
  }

  /*Retrieves parent directory where the program is being executed by user*/
  public static String getJarPath() throws UnsupportedEncodingException {
    String path = StorageHandler.class.getProtectionDomain().
        getCodeSource().getLocation().getPath();
    String decodedPath = URLDecoder.decode(path, "UTF-8");
    String sanitizedPath = sanitizePath(decodedPath.substring(0, decodedPath.length()-1));    
    return Paths.get(sanitizedPath).getParent().toString();         
  }

  public static boolean createDirectory(String dirPath){
    File directory = new File(dirPath);
    return directory.mkdir();  //If directory does not exist, create one
  }
  
  public static boolean createFile(String filePath) throws IOException {
    File file = new File(filePath);
    boolean isCreated = false;
    isCreated = file.createNewFile();
    return isCreated;
  }

  public static String createTempFile(String fileName) {
    File tempFile = null;
    try {
      tempFile = File.createTempFile(fileName, ".tmp");
      /*delete temporary file after JVM exited*/
      tempFile.deleteOnExit();                                                
    } catch (IOException e) {
      logger.error("Temp file is not created");
    }
    return tempFile.getAbsolutePath();
  }
  /*Will replace file if it exists in target*/
  public static void copyFiles(Path src, Path target) throws IOException {
    /*Copy attribute such as last-modified-time from source*/
    CopyOption[] options = new CopyOption[] {
        StandardCopyOption.COPY_ATTRIBUTES,
        StandardCopyOption.REPLACE_EXISTING
    };
    Files.copy(src, target, options);
  }

  public static boolean isDirectory(String dirPath) {
    return new File(dirPath).isDirectory();
  }


  public static void writeToFile(String output, String filePath) throws IOException {
    try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
        new FileOutputStream(filePath)))) {
      bw.append(output);
    } 
  }

  public static boolean deleteFile(String path) {
    return new File(path).delete();
  }

  /**
   * Obtains storage path from base config file
   * @param absolutePath
   * @return path of storage directory
   * @throws IOException 
   */
  public static String getStorageDirectory(String absolutePath) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(absolutePath))) {
      return br.readLine();
    } 
  }

  //===========================================================================
  //JSON Functions
  //===========================================================================

  public static JsonReader getJsonReaderFromFile(String filePath) {
    JsonReader jsonReader = null;
    try {
      jsonReader = new JsonReader(new FileReader(filePath));
    } catch (IOException e1) {
      e1.printStackTrace();
    }
    return jsonReader;
  }

  /*Deserializes object from JSON*/
  public static <T> T readFromJson(JsonReader jsonReader, Type typeOfSrc) 
    throws JsonParseException, IOException {
    T deserializedObject = new Gson().fromJson(jsonReader, typeOfSrc);
    jsonReader.close();
    return deserializedObject;
  }


  /*Returns JSON String given an object*/
  public static <T> String convertToJson(T targetObject) {
    Gson gson = new GsonBuilder().setPrettyPrinting().create();
    return gson.toJson(targetObject);
  }
  

}
```
###### src\main\raijin\ui\HelpMessage.java
``` java

package raijin.ui;

import java.util.ArrayList;
import java.util.List;

import javafx.scene.paint.Color;
import javafx.scene.text.Text;

/**
 * Represents help message that will pop out depending on typed command
 * @author papa
 *
 */
public class HelpMessage {

  private static final Color HELP_FORMAT_COLOR = Color.rgb(142, 0, 214);
  private static final Color COMMAND_FORMAT_COLOR = Color.rgb(51, 153, 255);
  private static final Color USER_INPUT_COLOR = Color.rgb(224, 224, 224);
  private static final Color ERROR_COLOR = Color.rgb(255, 55, 55);
  private static final Color DESCRIPTION_COLOR = Color.WHITE;
  private static final String DEFAULT_FONT_SIZE = "15";
  private static final String HELP_HEADER_FONT_SIZE = "25";

  /*acceptable format for a command*/
  public Text commandFormat;    
  /*function of a command or error message when there is an error with parsing*/
  public Text description;
  /*Text for help header in help Menu*/
  public Text help;
  
  public List<Text> helpMessage = new ArrayList<Text>();
  
  public HelpMessage(String help) {
	  this.help = createText(help, HELP_FORMAT_COLOR);
	  this.help.setStyle("-fx-font-size: " + HELP_HEADER_FONT_SIZE + ";");
	  helpMessage.add(this.help);
  }
  
  public HelpMessage(String commandFormat, String description) {
    this.commandFormat = createText(commandFormat, COMMAND_FORMAT_COLOR);
    this.description = createText("\n" + description, DESCRIPTION_COLOR);
    initializeCommandFormat(commandFormat);
    initializeDescription(description);
  }
  
  /**
   * Generates Text object with customized color 
   * @param input
   * @param fillColor
   */
  Text createText(String input, Color fillColor) {
    Text output = new Text(input);
    output.setFill(fillColor);
    output.setStyle("-fx-font-size: " + DEFAULT_FONT_SIZE + ";");
    return output;
  }
  
  private Text generateTextFromString(String token) {
    if (token.substring(0, 1).equals("?")) {                                    //Checks delimiter for user input 
      String trimmed = token.substring(1);
      return createText(trimmed + " ", USER_INPUT_COLOR);
    } else {
      return createText(token + " ", COMMAND_FORMAT_COLOR);
    }
  }

  /**
   * Creates individual text node
   * @param commandFormat
   * @return
   */
  void initializeCommandFormat(String commandFormat) {
    String[] tokens = commandFormat.split(" ");
    
    for (String token : tokens) {
      helpMessage.add(generateTextFromString(token));
    }
  }

  void initializeDescription(String description) {
    if (description.substring(0, 1).equals("?")) {                              //Checks for delimiter for error message
      helpMessage.add(createText("\n" + description.substring(1), ERROR_COLOR));
    } else {
      helpMessage.add(createText("\n" + description, DESCRIPTION_COLOR));
    }
  }

}
```
###### src\main\raijin\ui\resource\layout\SidebarController.fxml
``` fxml

<?import javafx.scene.image.*?>
<?import javafx.scene.shape.*?>
<?import javafx.scene.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.text.*?>
<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<fx:root maxWidth="-Infinity" prefHeight="-1.0" prefWidth="170.0" type="BorderPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
  <center>
    <VBox prefHeight="185.0" prefWidth="200.0" spacing="15.0" style="-fx-background-color: #ffffff; -fx-border-color: #ffffff #eeeeee  #ffffff #ffffff; -fx-border-width: 2px;">
      <children>
            <ImageView fitHeight="40.0" fitWidth="104.0" pickOnBounds="true" preserveRatio="true" translateX="30.0">
               <image>
                  <Image url="@../styles/RaijinLogo.png" />
               </image>
               <VBox.margin>
                  <Insets bottom="25.0" top="10.0" />
               </VBox.margin>
            </ImageView>
            <HBox fx:id="inboxHBox">
               <children>
                  <Button fx:id="inbox" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleInboxButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ccf8ff;" text="all" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfPending" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="18.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="todayHBox">
               <children>
              <Button fx:id="today" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleTodayButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="today" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                     <opaqueInsets>
                        <Insets />
                     </opaqueInsets>
                  </Button>
                  <Label fx:id="numOfToday" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="18.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="tomorrowHBox">
               <children>
              <Button fx:id="tomorrow" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleTomorrowButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="tomorrow" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfTomorrow" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="nextWeekHBox">
               <children>
              <Button fx:id="future" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleFutureButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="future" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfNextTasks" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <Separator prefWidth="200.0" />
            <HBox fx:id="overdueHBox">
               <children>
              <Button fx:id="overdue" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleOverdueButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="overdue" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfOverdue" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-background-color: #eeeeee; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5;" text="0" textFill="#e16363">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="completedHBox">
               <children>
              <Button fx:id="completed" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleCompletedButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="completed" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfCompleted" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0" textFill="#0ba9f2">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="completedHBox1">
               <children>
                  <Button fx:id="floating" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleFloatingButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="floating" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfFloating" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
      </children>
         <opaqueInsets>
            <Insets />
         </opaqueInsets>
    </VBox>
  </center>
</fx:root>
```
###### src\main\raijin\ui\SidebarController.java
``` java

package raijin.ui;

import java.io.IOException;
import java.util.List;

import com.google.common.eventbus.Subscribe;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.MainSubscriber;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.ChangeViewEvent;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.eventbus.events.TasksChangedEvent;
import raijin.common.filter.DateFilter;
import raijin.common.filter.TypeFilter;
import raijin.logic.api.Logic;

/**
 * Contains useful information such number of pending tasks for 
 * different categories of views
 * @author papa
 *
 */
public class SidebarController extends BorderPane {
  
  //============
  // UI elements
  //============

  @FXML
  Button inbox;
  @FXML
  Label numOfPending;
  @FXML
  Button overdue;
  @FXML
  Label numOfOverdue;
  @FXML
  Button completed;
  @FXML
  Label numOfCompleted;
  @FXML
  Button floating;
  @FXML
  Label numOfFloating;
  @FXML
  Button today;
  @FXML
  Label numOfToday;
  @FXML
  Button tomorrow;
  @FXML
  Label numOfTomorrow;
  @FXML
  Button future;
  @FXML
  Label numOfNextTasks;

  /*Reference to button focused by user*/
  Button currentFocusedButton;               


  private static final String SIDEBAR_LAYOUT_FXML = "resource/layout/SidebarController.fxml";
  private RaijinEventBus eventbus;
  
  //===============
  // Domain objects
  //===============
  
  private Logic logic;
  private List<Task> pendingTasks;
  private List<Task> overdueTasks;
  private List<Task> completedTasks;
  private List<Task> floatingTasks;
  private List<Task> pendingToday;
  private List<Task> pendingTomorrow;
  private List<Task> pendingNextWeek;
  private TypeFilter floatingFilter;

  public SidebarController(Logic logic) {
    FXMLLoader loader = new FXMLLoader(getClass().getResource(SIDEBAR_LAYOUT_FXML));
    loader.setController(this);
    loader.setRoot(this);
    try {
      loader.load();
    } catch (IOException e) {
      e.printStackTrace();
    }

    this.logic = logic;
    eventbus = RaijinEventBus.getInstance();
    init();
  }

  void init() {
    //Initialize states
    pendingTasks = logic.getPendingTasks();
    pendingToday = new DateFilter(pendingTasks, Constants.View.TODAY.getDateTime()).
        filter(pendingTasks);
    pendingTomorrow = new DateFilter(pendingTasks, Constants.View.TOMORROW.getDateTime()).
        filter(pendingTasks);
    pendingNextWeek = new DateFilter(pendingTasks, Constants.View.FUTURE.getDateTime()).
        filter(pendingTasks, Constants.View.FUTURE);
    overdueTasks = new TypeFilter(Constants.TYPE_TASK.OVERDUE).filter(pendingTasks);
    completedTasks = logic.getCompletedTasks();
    floatingFilter = new TypeFilter(Constants.TYPE_TASK.FLOATING);
    floatingTasks = floatingFilter.filter(pendingTasks);
    
    /*initialize labels*/
    updateLabels();
    
    /*initialize handlers*/
    handleTaskChanged();
    handleChangeView();
    
    /*Set current focused button*/
    currentFocusedButton = inbox;
  }

  /**
   * Update number of pending tasks when change occur to application 
   */
  void updateLabels() {
    numOfPending.setText(Integer.toString(pendingTasks.size()));
    numOfOverdue.setText(Integer.toString(overdueTasks.size()));
    numOfCompleted.setText(Integer.toString(completedTasks.size()));
    numOfFloating.setText(Integer.toString(floatingTasks.size()));

    numOfToday.setText(Integer.toString(pendingToday.size()));
    numOfTomorrow.setText(Integer.toString(pendingTomorrow.size()));
    numOfNextTasks.setText(Integer.toString(pendingNextWeek.size()));
  }

  /**
   * Sync domain object whenever any changes occur
   * @param event
   */
  void updateState(TasksChangedEvent event) {
    pendingTasks = event.pendingTasks;
    overdueTasks = event.overdue;
    completedTasks = event.completedTasks;
    floatingTasks = floatingFilter.filter(pendingTasks);

    pendingToday = event.pendingToday;
    pendingTomorrow = event.pendingTomorrow;
    pendingNextWeek = event.pendingNextWeek;
    updateLabels();
  }
  

  /**
   * Sets focus button to the one holding current view
   * @param event
   */
  void updateFocus(ChangeViewEvent event) {
    switch (event.typeOfView) {

      case INBOX:
        setNewFocus(inbox);
        break;

      case FUTURE:
        setNewFocus(future);
        break;

      case TODAY:
        setNewFocus(today);
        break;

      case TOMORROW:
        setNewFocus(tomorrow);
        break;

      default:
        break;
      
    }
  }

  /*sets button color when view changes*/
  void setNewFocus(Button newFocusedButton) {
    if (!newFocusedButton.equals(currentFocusedButton)) {
      currentFocusedButton.setStyle("-fx-background-color: #ffffff;");
      newFocusedButton.setStyle("-fx-background-color: #ccf8ff;");
      currentFocusedButton = newFocusedButton;
    }
  }

  /**
   * Fire change view event to trigger change in display
   * @param view        view that will be displayed to user
   */
  void triggerViewChange(Constants.View view) {
    eventbus.post(new ChangeViewEvent(pendingTasks, view));
  }
  
  /**
   * Fire overdue view event to trigger change in display
   * @param view        view that will be displayed to user
   */
  void triggerOverdueViewChange() {
    eventbus.post(new SetCurrentDisplayEvent(overdueTasks, Constants.DISPLAY_OVERDUE));
  }

  // ========
  // Handlers
  // ========

  @FXML
  protected void handleInboxButtonAction(ActionEvent event) {
    triggerViewChange(Constants.View.INBOX);
    setNewFocus(inbox);
  }

  @FXML
  protected void handleOverdueButtonAction(ActionEvent event) {
    setNewFocus(overdue);
    triggerOverdueViewChange();
  }

  @FXML
  protected void handleCompletedButtonAction(ActionEvent event) {
    logic.executeCommand("display c");
    setNewFocus(completed);
  }

  @FXML
  protected void handleTodayButtonAction(ActionEvent event) {
    triggerViewChange(Constants.View.TODAY);
    setNewFocus(today);
  }

  @FXML
  protected void handleTomorrowButtonAction(ActionEvent event) {
    triggerViewChange(Constants.View.TOMORROW);
    setNewFocus(tomorrow);
  }

  @FXML
  protected void handleFutureButtonAction(ActionEvent event) {
    triggerViewChange(Constants.View.FUTURE);
    setNewFocus(future);
  }


  @FXML
  protected void handleFloatingButtonAction(ActionEvent event) {
    logic.executeCommand("display f");
    setNewFocus(floating);
  }

  public void handleChangeView() {
    MainSubscriber<ChangeViewEvent> changeViewHandler =
        new MainSubscriber<ChangeViewEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(ChangeViewEvent event) {
            updateFocus(event);
          }
    };
  }

  public void handleTaskChanged() {
    MainSubscriber<TasksChangedEvent> tasksChangedHandler =
        new MainSubscriber<TasksChangedEvent>(eventbus.getEventBus()) {

          @Subscribe
          @Override
          public void handleEvent(TasksChangedEvent event) {
            updateState(event);
          }
    };
  }
  
}
```
###### src\main\raijin\ui\TaskPane.java
``` java
  public double calculateCentreWidth() {
    Stage stage = Raijin.getStage();
    double stageWidth = stage.getWidth();
    /*Handles NaN upon launch*/
    if (Double.isNaN(stageWidth)) {
      stageWidth = 750;
    }
    double width = stageWidth - ID_WIDTH - OVERDUE_WIDTH - 35;
    if (stage.isMaximized()) {
      width -= 200;
    }
    return width;
  }

  

  float getWidthOfTimeSlot(DateTime dateTime) {
    long duration = dateTime.getStartTime().until(dateTime.getEndTime(), ChronoUnit.MINUTES);
    float width = duration / MAX_EVENT_DURATION * MAX_TIMESLOT_WIDTH;
    width = width > MAX_TIMESLOT_WIDTH ? MAX_TIMESLOT_WIDTH : width;
    return width;
  }

  String getTimeSlotColor(String priority) {
    if (priority.equals(Constants.PRIORITY_HIGH)) {
      return highPriorityTimeSlot;
    } else if (priority.equals(Constants.PRIORITY_LOW)) {
      return lowPriorityTimeSlot;
    } else {
      return midPriorityTimeSlot;
    }
  }

  void setSingleDayEvent(Task task, HBox datesBox) {
    DateTime dateTime = task.getDateTime();
    String endDate = dateTime.getEndDate().format(dateFormat).toString();
    String startTime = dateTime.getStartTime().toString();
    String endTime = dateTime.getEndTime().toString();

    Label eventDate = new Label(endDate);
    eventDate.setPrefWidth(222);
    eventDate.setPadding(new Insets(0, 50, 0, 0));
    Label startTimeLabel = new Label(startTime);
    startTimeLabel.setPadding(new Insets(0, 10, 0, 0));
    Label timeSlot = new Label();
    timeSlot.setPrefHeight(10);
    timeSlot.setPrefWidth(getWidthOfTimeSlot(dateTime));
    String color = getTimeSlotColor(task.getPriority());
    timeSlot.setStyle("-fx-border-radius: 5 5 5 5; "
                    + "-fx-background-radius: 5 5 5 5; " 
                    + "-fx-background-color: " + color);
    Label endTimeLabel = new Label(endTime);
    endTimeLabel.setPadding(new Insets(0, 0, 0, 10));
    datesBox.getChildren().addAll(startByOn, eventDate, startTimeLabel,
                                  timeSlot, endTimeLabel);
  }

}
```
###### src\test\raijin\common\datatypes\DateTimeTest.java
``` java

package raijin.common.datatypes;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalTime;

import org.junit.Before;
import org.junit.Test;

public class DateTimeTest {

  private DateTime date;

  @Before
  public void setUp() throws Exception {
    date = new DateTime("19/09/2015");
  }

  @Test
  public void testSpecificDate() {
    assertEquals(date.getStartDate().toString(), "2015-09-19");
    assertEquals("23:59", date.getEndTime().toString());
  }

  @Test
  public void testSpecificDateAndTime() {
    DateTime date = new DateTime("19/09/2013", "1900");
    assertEquals(date.getEndDate().toString(), "2013-09-19");
    assertEquals("19:00", date.getEndTime().toString());
  }

  @Test
  public void testSpecificEvent() {
    DateTime date = new DateTime("19/09/2013", "1900", "2100");
    assertEquals(date.getStartDate().toString(), "2013-09-19");
    assertEquals("19:00", date.getStartTime().toString());
    assertEquals("21:00", date.getEndTime().toString());
  }

  @Test
  public void testSpanEvent() {
    DateTime date = new DateTime("19/09/2013", "1900", "21/09/2013", "2100");
    assertEquals( "2013-09-19", date.getStartDate().toString());
    assertEquals( "2013-09-21", date.getEndDate().toString());
    assertEquals("19:00", date.getStartTime().toString());
    assertEquals("21:00", date.getEndTime().toString());
  }
  
  //===========================================================================
  // Compare Start Time
  //===========================================================================
  
  @Test
  public void compareStartTime_EqualTimes() {
    //Same start time, same end time
    LocalTime sourceEnd = LocalTime.of(12, 0);
    LocalTime targetEnd = LocalTime.of(12, 0);
    DateTime source = new DateTime(sourceEnd, null);
    
    assertEquals(0, source.compareStartTime(sourceEnd, targetEnd));
  }
  
  @Test
  public void compareStartTime_EarlierThan() {
    //Same start time, earlier end time
    LocalTime sourceEnd = LocalTime.of(11, 59);
    LocalTime targetEnd = LocalTime.of(12, 0);
    DateTime source = new DateTime(sourceEnd, null);
    
    assertEquals(-1, source.compareStartTime(sourceEnd, targetEnd));
  }

  @Test
  public void compareStartTime_LaterThan() {
    //Same start time, earlier end time
    LocalTime sourceEnd = LocalTime.of(11, 1);
    LocalTime targetEnd = LocalTime.of(11, 0);
    DateTime source = new DateTime(sourceEnd, null);
    
    assertEquals(1, source.compareStartTime(sourceEnd, targetEnd));
  }

  @Test
  public void compareStartTime_NullSource() {
    //Same start time, no end time
    LocalTime targetEnd = LocalTime.of(12, 0);
    DateTime source = new DateTime(null, targetEnd);
    
    assertEquals(1, source.compareStartTime(null, targetEnd));
  }

  @Test
  public void compareStartTime_NullTarget() {
    //Same start time, no end time
    LocalTime sourceEnd = LocalTime.of(12, 0);
    DateTime source = new DateTime(null, sourceEnd);
    
    assertEquals(-1, source.compareStartTime(sourceEnd, null));
  }
  
  //===========================================================================
  // Compare Date & Time
  //===========================================================================
  
  @Test
  public void compareTo_EarlierEndDate() {
    DateTime source = new DateTime("18/10/2015", "1000", "20/10/2015", "1200");
    DateTime target = new DateTime("18/10/2015", "1000", "21/10/2015", "1200");
    assertEquals(-1, source.compareTo(target));
  }
  

  @Test
  public void compareTo_SameEndDate_EarlierTime() {
    DateTime source = new DateTime("18/10/2015", "1000", "20/10/2015", "1200");
    DateTime target = new DateTime("18/10/2015", "1001", "20/10/2015", "1200");
    assertEquals(-1, source.compareTo(target));
  }

  @Test
  public void compareTo_SameEndDate_EarlierEndTime() {
    DateTime source = new DateTime("18/10/2015", "1000", "20/10/2015", "1159");
    DateTime target = new DateTime("18/10/2015", "1000", "20/10/2015", "1200");
    assertEquals(-1, source.compareTo(target));
  }

  @Test
  public void compareTo_SameEndDate_LaterEndTime() {
    DateTime source = new DateTime("18/10/2015", "1000", "20/10/2015", "1200");
    DateTime target = new DateTime("18/10/2015", "1000", "20/10/2015", "1159");
    assertEquals(1, source.compareTo(target));
  }

  @Test
  public void compareTo_SameDate_EarlierEndTime() {
    DateTime source = new DateTime("25/10/2015", "1200");
    DateTime target = new DateTime(LocalDate.now(), null, LocalDate.now(), 
          LocalTime.now());
    assertTrue(source.compareTo(target) < 0);
  }
}
```
###### src\test\raijin\common\datatypes\SetTrieTest.java
``` java

package raijin.common.datatypes;

import static org.junit.Assert.*;

import java.util.List;

import org.junit.Before;
import org.junit.Test;

import raijin.logic.realtime.SetTrie;

public class SetTrieTest {

  private SetTrie taskList;

  @Before
  public void setUp() throws Exception {
    taskList = new SetTrie();
  }

  @Test
  public void testStringsWithSpace() {
    taskList.add("I am cute");
    taskList.add("I am batu");
    List<String> result = taskList.getSuggestions("I am");
    assertEquals(2, result.size());
  }

}
```
###### src\test\raijin\common\datatypes\StatusTest.java
``` java

package raijin.common.datatypes;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

public class StatusTest {

  @Test
  public void testCreateStatusWithoutResult() {
    Status status = new Status("added successfully");
    assertNull(status.getDisplayText());
  }

  @Test
  public void testCreateStatusWithResult() {
    Status status = new Status("added successfully", "1. Submit OP1 19/9 2359");
    assertEquals("1. Submit OP1 19/9 2359", status.getDisplayText());
  }
}
```
###### src\test\raijin\common\datatypes\TaskTest.java
``` java

package raijin.common.datatypes;


import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import edu.emory.mathcs.backport.java.util.Arrays;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.utils.IDManager;
import raijin.logic.parser.ParsedInput;
import raijin.storage.api.TasksManager;

public class TaskTest {
  

  private Task flexibleTask;
  private Task task;
  private TasksManager tasksManager;
  private static IDManager idManager;

  @BeforeClass
  public static void setUpClass() {
    idManager = IDManager.getIdManager();
  }

  @Before
  public void setUp(){
    tasksManager = TasksManager.getManager();
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
    task = new Task("submit op1", idManager.getId());
  }
  
  @Test
  public void testNameMustNotBeNull(){
    assertNotNull(task.getName());
  }

  @Test
  public void testIdMustBeValid(){
    assertTrue(task.getId() > 0);
  }

  @Test
  public void testUniqueId(){
    flexibleTask = new Task("submit op2", idManager.getId());
    assertNotEquals(flexibleTask.getId(), task.getId());
  }

  @Test
  public void testAddTag(){
    TreeSet<String> tags = new TreeSet<String>();
    tags.add("cs2101");
    task.addTags(tags);
    assertTrue(task.getTags().contains("cs2101"));
  }
  
  @Test
  public void testKeyWords() {
    assertEquals("submit", task.getKeywords().get(0));
  }
  
  @Test
  public void addSubTasks_ValidSubTasks() {
    task.addSubTask(2);
    task.addSubTask(3);
    tasksManager.addPendingTask(new Task("submit op1", idManager.getId()));
    tasksManager.addPendingTask(new Task("submit op2", idManager.getId()));
    assertEquals(2, task.getSubTasks().size());
  }
  
  @Test
  public void removeSubTasks_ValidChildOfTask() {
    task.addSubTask(5);
    task.removeSubTask(5);
    assertEquals(0, task.getSubTasks().size());
  }
  
  @Test
  public void lazyUpdateSubTasks_DeleteSubTasks() throws NoSuchTaskException {
    //Create initial subtasks
    task.addSubTask(2);
    task.addSubTask(3);
    //Add subtasks to pending list
    tasksManager.addPendingTask(new Task("submit op1", idManager.getId()));
    tasksManager.addPendingTask(new Task("submit op2", idManager.getId()));
    
    assertEquals(2, task.getSubTasks().size());
    //ID 1 is taken by initial task
    tasksManager.deletePendingTask(2);
    task.lazyUpdateSubTasks();
    assertEquals(1, task.getSubTasks().size());
  }

  @Test(expected = AssertionError.class)
  public void testIdNotZero() {
    Task test = new Task("I am wrong", -1);
    assertEquals("I am wrong", test.getName());
  }
  
  @Test
  public void getType_FloatingTask_ReturnType() {
    Task floatingTask = new Task("submit op1", 1);
    assertEquals(Constants.TYPE_TASK.FLOATING, floatingTask.getType());
  }

  @Test
  public void getType_SpecificTask_ReturnType() {
    DateTime task = new DateTime("19/09/2015", "2359");
    ParsedInput specificTaskInput = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        dateTime(task).createParsedInput();

    Task specificTask = new Task("submit op1", 2, specificTaskInput);
    
    assertEquals(Constants.TYPE_TASK.SPECIFIC, specificTask.getType());
  }

  @Test
  public void getType_EventTask_ReturnType() {
    DateTime event = new DateTime("19/09/2015", "0800", "1000");
    ParsedInput eventInput = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        dateTime(event).createParsedInput();

    Task eventTask = new Task("submit op1", 3, eventInput);
    
    assertEquals(Constants.TYPE_TASK.EVENT, eventTask.getType());
  }
  
  @Test
  public void getPriority_LowPriority() {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        priority(Constants.PRIORITY_LOW).createParsedInput();

    assertEquals(Constants.PRIORITY_LOW, input.getPriority());
  }
}
```
###### src\test\raijin\common\filter\DateFilterTest.java
``` java

package raijin.common.filter;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.filter.DateFilter;

public class DateFilterTest {

  private DateFilter dateFilter;

  //===========================================================================
  // Helper
  //===========================================================================
  
  public DateFilter getFilter(List<Task> tasks, DateTime limit) {
    return new DateFilter(tasks, limit);
  }

  @Before
  public void setUp() {}

  //===========================================================================
  // Time 
  //===========================================================================
  
  @Test
  public void isMatchedTime_SameEndTime_ReturnTrue() {
    DateTime limit = new DateTime("19/10/2015", "1000");
    
    //Not end time. 
    DateTime target = new DateTime("19/10/2015", "1000");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertTrue(dateFilter.isMatchedTime(target));
  }

  @Test
  public void isMatchedTime_DifferentEndTime_ReturnFalse() {
    DateTime limit = new DateTime("19/10/2015", "1000");
    
    DateTime target = new DateTime("19/10/2015", "1200");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertFalse(dateFilter.isMatchedTime(target));
  }

  @Test
  public void isMatchedTime_WithinDurationEvent_ReturnTrue() {
    DateTime limit = new DateTime("19/10/2015", "1000", "1700");
    
    DateTime target = new DateTime("19/10/2015", "1001", "1659");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertTrue(dateFilter.isMatchedTime(target));
  }

  @Test
  public void isMatchedTime_OverdueEvent_ReturnFalse() {
    DateTime limit = new DateTime("19/10/2015", "1000", "1700");
    
    DateTime target = new DateTime("19/10/2015", "1200", "1900");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertFalse(dateFilter.isMatchedTime(target));
  }

  @Test
  public void isMatchedTime_ExactEvent_ReturnTrue() {
    DateTime limit = new DateTime("19/10/2015", "1000", "1700");
    
    DateTime target = new DateTime("19/10/2015", "1000", "1700");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertTrue(dateFilter.isMatchedTime(target));
  }

  //===========================================================================
  // Date
  //===========================================================================

  @Test
  public void isMatchedDate_SameStartDate_ReturnTrue() {
    DateTime limit = new DateTime("19/10/2015");
    
    DateTime target = new DateTime("19/10/2015");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertTrue(dateFilter.isMatchedDate(target));
  }

  @Test
  public void isMatchedDate_DifferentStartDate_ReturnFalse() {
    DateTime limit = new DateTime("19/10/2015");
    
    DateTime target = new DateTime("20/10/2015");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertFalse(dateFilter.isMatchedDate(target));
  }

  @Test
  public void isMatchedDate_WithinDateDuration_ReturnTrue() {
    DateTime limit = new DateTime("19/10/2015", "1000", "22/10/2015", "1200");
    
    DateTime target = new DateTime("20/10/2015", "1000", "21/10/2015", "1200");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertTrue(dateFilter.isMatchedDate(target));
  }

  @Test
  public void isMatchedDate_LessThanStartDate_ReturnFalse() {
    DateTime limit = new DateTime("19/10/2015", "1000", "22/10/2015", "1200");
    
    DateTime target = new DateTime("18/10/2015", "1000", "22/10/2015", "1200");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertFalse(dateFilter.isMatchedDate(target));
  }

  @Test
  public void isMatchedDate_MoreThanEndDate_ReturnFalse() {
    DateTime limit = new DateTime("19/10/2015", "1000", "22/10/2015", "1200");
    
    DateTime target = new DateTime("19/10/2015", "1000", "23/10/2015", "1200");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertFalse(dateFilter.isMatchedDate(target));
  }

  //===========================================================================
  // Date & Time combine
  //===========================================================================
  
  @Test
  public void isMatched_OnlyDate_ReturnTrue() {
    DateTime limit = new DateTime(null, LocalDate.of(2015, 9, 19));
    
    DateTime target = new DateTime("15/09/2015", "1000", "19/09/2015", "1200");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertTrue(dateFilter.isMatched(target));
  }

  @Test
  public void isMatched_OnlyTime_ReturnTrue() {
    DateTime limit = new DateTime(null, LocalTime.of(12, 0));
    
    DateTime target = new DateTime("19/09/2015", "1000", "23/10/2015", "1200");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertTrue(dateFilter.isMatched(target));
  }

  @Test
  public void isMatched_ConflictTime_ReturnFalse() {
    DateTime limit = new DateTime("19/10/2015", "1000", "1100");
    
    DateTime target = new DateTime("19/10/2015", "0900", "1000");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertFalse(dateFilter.isMatched(target));
  }

  @Test
  public void isMatched_ConflictDate_ReturnFalse() {
    DateTime limit = new DateTime("19/10/2015", "1000", "1100");
    
    DateTime target = new DateTime("19/12/2015", "1000", "1059");
    dateFilter = getFilter(new ArrayList<Task>(), limit); 
    
    assertFalse(dateFilter.isMatched(target));
  }

}
```
###### src\test\raijin\common\filter\TagFilterTest.java
``` java

package raijin.common.filter;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.Task;
import raijin.common.filter.TagFilter;
import raijin.logic.parser.ParsedInput;
import edu.emory.mathcs.backport.java.util.Arrays;

public class TagFilterTest {

  //===========================================================================
  // Helper 
  //===========================================================================
  
  public TreeSet<String> getTags(String[] tags) {
    List<String> tmp = new ArrayList<String>(Arrays.asList(tags));
    return new TreeSet<String>(tmp);
  }

  public Task createTask(TreeSet<String> tags) {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(null).name("I am nope").
        tag(tags).createParsedInput();
    return new Task(input.getName(), 1, input);
  }

  @Before
  public void setUp() throws Exception {}

  @Test
  public void filter_DoesNotMatchAllTags() {
    TreeSet<String> limitTags = getTags(new String[] {"cs2101, cs2103"});
    TreeSet<String> input = getTags(new String[] {"cs2101"});
    List<Task> tasks = new ArrayList<Task>();
    
    //Setup tasks
    tasks.add(createTask(input));
    
    //Result
    List<Task> filtered = new TagFilter(limitTags).filter(tasks);

    assertEquals(0, filtered.size());
  }

  @Test
  public void filter_MatchAllTags() {
    TreeSet<String> limitTags = getTags(new String[] {"cs2101", "cs2103"});
    TreeSet<String> input = getTags(new String[] {"cs2101", "cs2103"});
    List<Task> tasks = new ArrayList<Task>();
    
    //Setup tasks
    tasks.add(createTask(input));
    
    //Result
    List<Task> filtered = new TagFilter(limitTags).filter(tasks);

    assertEquals(1, filtered.size());
  }

}
```
###### src\test\raijin\common\filter\TypeFilterTest.java
``` java

package raijin.common.filter;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.filter.TypeFilter;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.ParsedInputTest;

public class TypeFilterTest {

  private static ArrayList<Task> tasks;

  //===========================================================================
  // Helper
  //===========================================================================
  
  static Task createTask(String name, DateTime dateTime) {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(null).name(name)
        .dateTime(dateTime).priority("m").createParsedInput();
    return new Task(name, 1, input);
  }

  //===========================================================================
  // Tests
  //===========================================================================
  
  @BeforeClass
  public static void setUpClass() {
    tasks = new ArrayList<Task>();
    ParsedInput input = new ParsedInput.ParsedInputBuilder(null).priority("m")
        .createParsedInput();
    tasks.add(createTask("I am weird", new DateTime("23/10/2010", "2300")));
    tasks.add(createTask("I am weird", new DateTime("23/10/2010", "2300", "2340")));
    tasks.add(new Task("I am floating", 1, input));
    tasks.add(new Task("I am flying", 1, input));
  }

  @Test
  public void filter_FloatingTasks() {
    TypeFilter type = new TypeFilter(Constants.TYPE_TASK.FLOATING);
    List<Task> filtered = type.filter(tasks);
    
    assertEquals(2, filtered.size());
  }

  @Test
  public void filter_Event() {
    TypeFilter type = new TypeFilter(Constants.TYPE_TASK.EVENT);
    List<Task> filtered = type.filter(tasks);
    
    assertEquals(1, filtered.size());
  }

  @Test
  public void filter_OverdueDate() {
    TypeFilter type = new TypeFilter(Constants.TYPE_TASK.OVERDUE);
    List<Task> filtered = type.filter(tasks);
    
    assertEquals(2, filtered.size());
  }

  @Test
  public void filter_OverdueTime() {
    DateTime late = new DateTime(LocalDate.now(), null, LocalDate.now(), 
        LocalTime.now().minusMinutes(2L));

    tasks.add(createTask("I am late", late));

    TypeFilter type = new TypeFilter(Constants.TYPE_TASK.OVERDUE);
    List<Task> filtered = type.filter(tasks);
    
    assertEquals(3, filtered.size());
  }

  @Test
  public void filter_OverdueDateTime() {
    DateTime today = new DateTime(LocalDate.now(), null, LocalDate.now(), LocalTime.of(23, 59));
    ArrayList<Task> nothing = new ArrayList<Task>();
    nothing.add(createTask("I am late", today));

    TypeFilter type = new TypeFilter(Constants.TYPE_TASK.OVERDUE);
    List<Task> filtered = type.filter(nothing);
    assertEquals(0, filtered.size());
  }
}
```
###### src\test\raijin\common\utils\IDManagerTest.java
``` java

package raijin.common.utils;

import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.utils.IDManager;

public class IDManagerTest {

  private IDManager idManager;

  @Before
  public void setUp() throws Exception {
    this.idManager = IDManager.getIdManager();
    idManager.setMaxId(Constants.MAX_ID);
  }

  @Test
  public void testUniqueIds() {
    assertNotEquals(idManager.getId(), idManager.getId());
  }

  @Test
  public void testReturnId() {
    int id = idManager.getId();
    TreeSet<Integer> idPool = idManager.getIdPool();
    assertFalse(idPool.contains(id));
    idManager.returnId(id);
    assertTrue(idPool.contains(id));
  }

  @Test
  public void testFlushIdPool() {
    //Get a few ids 
    int a = idManager.getId();
    
    idManager.flushIdPool();
    assertEquals(1, idManager.getId());
  }
  
  @Test
  public void initIdPoolFromPendingTasks_ReduceAvaibleIds() {
    HashMap<Integer, Task> tasks = new HashMap<Integer, Task>();
    tasks.put(1, new Task("submit op2", idManager.getId()));
    tasks.put(2, new Task("submit op3", idManager.getId()));
    tasks.put(3, new Task("submit op4", idManager.getId()));
    idManager.flushIdPool();

    int expected_size = idManager.getMaxId() - tasks.size();
    idManager.updateIdPool(tasks);
    assertEquals(expected_size, idManager.getIdPool().size());
  }
  
  @Test
  public void updateIdPool_PendingTasksMoreThanMaxID_IncreaseMaxID() {
    HashMap<Integer, Task> tasks = new HashMap<Integer, Task>();
    for (int i=1; i <= 500; i++) {
      tasks.put(i, new Task("I am weird", i));
    }

    idManager.updateIdPool(tasks);
    assertEquals(700, idManager.getMaxId());
  }

  @Test
  public void getId_IdPoolEmpty_ExtendIdPool() {
    idManager.setIdPool(new TreeSet<Integer>());
    int id = idManager.getId();
    assertEquals(Constants.MAX_ID+1, id);
  }

}
```
###### src\test\raijin\common\utils\RaijinLoggerTest.java
``` java

package raijin.common.utils;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.classic.Level;

public class RaijinLoggerTest {

  private static Logger logger;

  @BeforeClass
  public static void setUp() throws Exception {
    logger = LoggerFactory.getLogger(RaijinLoggerTest.class);
  }

  @Test
  public void testLogDebug() {
    ArrayList<String> test = new ArrayList<String>();
    logger.debug("Size of array list is {}", test.size());
  }

}
```
###### src\test\raijin\common\utils\SortFilterTest.java
``` java

package raijin.common.utils;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.List;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import edu.emory.mathcs.backport.java.util.Arrays;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.filter.SortFilter;
import raijin.logic.parser.ParsedInput;

public class SortFilterTest {

  private static ArrayList<Task> tasks;
  private static ArrayList<Task> tasks2;

  //===========================================================================
  // Helper
  //===========================================================================
  
  static ParsedInput createNormalTask(DateTime dateTime, String priority, TreeSet<String> tags) {
    return new ParsedInput.ParsedInputBuilder(null).dateTime(dateTime)
        .priority(priority).tag(tags).createParsedInput();
  }

  static TreeSet<String> createTags(String[] tags) {
    return new TreeSet<String>(Arrays.asList(tags));
  }


  @BeforeClass
  public static void setUpClass() {
    tasks = new ArrayList<Task>();
    tasks2 = new ArrayList<Task>();

    ParsedInput input1 = createNormalTask(new DateTime("13/03/2011"), "l", createTags(
        new String[] {"cs2101"}));

    ParsedInput input2 = createNormalTask(new DateTime("18/03/2011"), "h", createTags(
        new String[] {"cs2101", "cs2103", "cs1001"}));

    ParsedInput input3 = createNormalTask(new DateTime("15/03/2011"), "m", createTags(
        new String[] {"cs2101", "cs2103"}));

    ParsedInput input4 = createNormalTask(new DateTime("13/03/2011", "1000"), "l", createTags(
        new String[] {"cs2101"}));

    ParsedInput input5 = createNormalTask(new DateTime("13/03/2011", "1100", "1300"), "l", createTags(
        new String[] {"cs2101"}));

    ParsedInput input6 = createNormalTask(new DateTime("13/03/2011", "1100", "1200"), "l", createTags(
        new String[] {"cs2101"}));

    tasks.add(new Task("I like goku", 1, input1));
    tasks.add(new Task("I like babu", 2, input2));
    tasks.add(new Task("I like moon", 3, input3));
    
    tasks2.add(new Task("submit op1", 4, input4));
    tasks2.add(new Task("submit op1", 5, input5));
    tasks2.add(new Task("submit op1", 6, input6));
  }

  @Test
  public void sortByDeadline() {
    SortFilter sort = new SortFilter(Constants.SORT_CRITERIA.DEADLINE);
    List<Task> result = sort.filter(tasks);
    
    assertEquals(1, result.get(0).getId());
    assertEquals(3, result.get(1).getId());
    assertEquals(2, result.get(2).getId());
  }

  @Test
  public void sortByDeadline_Reversed() {
    SortFilter sort = new SortFilter(Constants.SORT_CRITERIA.DEADLINE);
    sort.setReverse();
    List<Task> result = sort.filter(tasks);
    
    assertEquals(2, result.get(0).getId());
    assertEquals(3, result.get(1).getId());
    assertEquals(1, result.get(2).getId());
  }

  @Test
  public void sortByPriority() {
    SortFilter sort = new SortFilter(Constants.SORT_CRITERIA.PRIORITY);
    List<Task> result = sort.filter(tasks);
    
    assertEquals(2, result.get(0).getId());
    assertEquals(3, result.get(1).getId());
    assertEquals(1, result.get(2).getId());
  }

  @Test
  public void sortByName() {
    SortFilter sort = new SortFilter(Constants.SORT_CRITERIA.NAME);
    List<Task> result = sort.filter(tasks);
    
    assertEquals(2, result.get(0).getId());
    assertEquals(1, result.get(1).getId());
    assertEquals(3, result.get(2).getId());
  }

  @Test
  public void sortByTags() {
    SortFilter sort = new SortFilter(Constants.SORT_CRITERIA.TAG);
    List<Task> result = sort.filter(tasks);
    
    assertEquals(1, result.get(0).getId());
    assertEquals(3, result.get(1).getId());
    assertEquals(2, result.get(2).getId());
  }

  @Test
  public void sortByTime() {
    SortFilter sort = new SortFilter(Constants.SORT_CRITERIA.DEADLINE);
    List<Task> result = sort.filter(tasks2);
    
    assertEquals(4, result.get(0).getId());
    assertEquals(6, result.get(1).getId());
    assertEquals(5, result.get(2).getId());
  }

}
```
###### src\test\raijin\common\utils\TaskUtilsTest.java
``` java

package raijin.common.utils;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Test;

import edu.emory.mathcs.backport.java.util.Arrays;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.logic.parser.ParsedInput;

public class TaskUtilsTest {

  //===========================================================================
  // Helper methods
  //===========================================================================
  
  public Task createTagTask(String[] tags) {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(null).name("me no more").
        tag(new TreeSet<String>(Arrays.asList(tags))).createParsedInput();
    return new Task(input.getName(), 1, input);
  }

  public Task createSpecificTask(String name, DateTime dateTime) {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(null).name(name).
        dateTime(dateTime).createParsedInput();
    return new Task(input.getName(), 1, input);
  }

  @Before
  public void setUp() throws Exception {}

  @Test
  public void filterTaskWithTags() {
    //Create tags
    TreeSet<String> tags = new TreeSet<String>();
    tags.add("cs2101");
    tags.add("cs2103");

    //Tasks
    HashMap<Integer, Task> pendingTasks = new HashMap<Integer, Task>();
    pendingTasks.put(1, createTagTask(new String[]{"cs2101"}));
    pendingTasks.put(2, createTagTask(new String[]{"cs2103, cs2101"}));
    pendingTasks.put(3, createTagTask(new String[]{"cs2103"}));

    List<Task> result = TaskUtils.filterTaskWithTags(pendingTasks, tags);
    assertEquals(2, result.size());
  }

  @Test
  public void filterTaskWithNames() {
    HashMap<Integer, Task> pendingTasks = new HashMap<Integer, Task>();
    pendingTasks.put(1, createSpecificTask("I am me", new DateTime("19/09/2011")));
    pendingTasks.put(2, createSpecificTask("I am me", new DateTime("21/09/2011")));
    pendingTasks.put(3, createSpecificTask("I am me", new DateTime("01/08/2011")));
    
    List<Task> result = TaskUtils.filterTaskWithName(pendingTasks, "I am me");
    
    assertEquals(3, result.size());
  }
  
  @Test
  public void getOnlyNormalTasks() {
    List<Task> pendingTasks = new ArrayList<Task>();
    pendingTasks.add(createSpecificTask("I am me", new DateTime("19/09/2011")));
    pendingTasks.add(createSpecificTask("I am me", new DateTime("21/09/2011")));
    pendingTasks.add(new Task("floating task 1", 3));
    pendingTasks.add(new Task("floating task 2", 4));
    
    List<Task> result = TaskUtils.getOnlyNormalTasks(pendingTasks);
    
    assertEquals(2, result.size());
  }

  @Test
  public void getTags_MultipleSimilarTags() {
    HashMap<Integer, Task> pendingTasks = new HashMap<Integer, Task>();
    pendingTasks.put(1, createTagTask(new String[]{"cs2101"}));
    pendingTasks.put(2, createTagTask(new String[]{"cs2103"}));
    pendingTasks.put(3, createTagTask(new String[]{"cs2103"}));

    TreeSet<String> result = TaskUtils.getTags(pendingTasks);
    System.out.println(result.toString());
    assertEquals(2, result.size());
  }
}
```
###### src\test\raijin\helper\TestProperties.java
``` java

package raijin.helper;

import java.io.File;

import raijin.storage.api.Session;
import raijin.storage.api.TasksManager;

public class TestProperties {


  public final String testCaseName;                //Name of test script used
  public File actualJSON;
  public File expectedJSON;
  public String testScript;
  public static final String TEST_DATA = "/src/test/resources/data/";
  public static final String TEST_SCRIPTS = "src/test/resources/scripts/";
  public static final String TEST_OUTPUT = "src/test/resources/output/";
  public static final String TEST_EXPECTED = "src/test/resources/expected/";
  
  //Basic dependencies for Raijin
  public Session session;

  //Expected result
  public TasksManager expected;

  public TestProperties(String testCaseName) {
    this.testCaseName = testCaseName;
    setupEnvironment();                           //Setup paths for storage
  }

  void setupEnvironment() {
    session = Session.getSession();
    session.setDataPath(TEST_OUTPUT + testCaseName + ".json");
    actualJSON = new File(TEST_OUTPUT + testCaseName + ".json");
    expectedJSON = new File(TEST_EXPECTED + testCaseName + ".json");
    testScript = TEST_SCRIPTS + testCaseName + ".txt";
  }
}
```
###### src\test\raijin\helper\TestUtils.java
``` java

package raijin.helper;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import junitx.framework.FileAssert;

import org.slf4j.Logger;

import static org.junit.Assert.*;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.FailedToParseException;
import raijin.common.utils.IDManager;
import raijin.common.utils.RaijinLogger;
import raijin.logic.api.Logic;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.ParsedInput.ParsedInputBuilder;
import raijin.logic.parser.ParserInterface;
import raijin.logic.parser.SimpleParser;
import raijin.storage.api.History;
import raijin.storage.api.Session;
import raijin.storage.api.TasksManager;

/**
 * Contains utility functions that help to generate relevant test objects 
 * for software under test
 * @author papa
 * 
 */
public class TestUtils {


  private IDManager idManager;
  private ParserInterface parser = new SimpleParser();
  private static Logger logger = RaijinLogger.getLogger();
  
  public TasksManager tasksManager;

  public TestUtils(IDManager idManager, TasksManager tasksManager) {
    this.idManager = idManager;
    this.tasksManager = tasksManager;
  }
  
  public TestUtils() {
    this.idManager = IDManager.getIdManager();
    this.tasksManager = TasksManager.getManager();
  }
  
  //===========================================================================
  // Methods to create object
  //===========================================================================
  
  ParsedInputBuilder getBuilder(Constants.Command cmd) {
    return new ParsedInputBuilder(cmd);
  }

  //Directly generates an input from text
  public ParsedInput createInputFromText(String userInput) throws FailedToParseException {
    return parser.parse(userInput);
  }
  
  //Creates a task given a specific deadline
  public Task createTask(String name, DateTime deadline) {
    ParsedInput input = getBuilder(null).name(name).dateTime(deadline)
        .createParsedInput();
    return new Task(name, idManager.getId(), input);
  }

  public Task createFloatingTask(String name) {
    return new Task(name, idManager.getId());
  }

  //===========================================================================
  // Set test properties
  //===========================================================================
  
  /**
   * Reset idManager to full id pool
   * Clear tasks manager 
   * Clear history
   */
  public void reset() {
    idManager.flushIdPool();                
    tasksManager.setCompletedTasks(new HashMap<Integer, Task>());
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    History.getHistory().clear();
  }
  
  //===========================================================================
  // Assert helper
  //===========================================================================
  
  //Compare size and content of tasks
  public static void assertSimilarTasks(HashMap<Integer, Task> expected, 
      HashMap<Integer, Task> actual) {
    
    //Check that they are equal number of pending task
    assertEquals(expected.size(), actual.size());
    
    //Check that content is similar
    assertTrue(expected.values().equals(actual.values()));
  }
  
  //Compare JSON files produced after running test script
  public static void assertSimilarFiles(File expected, File actual) {
    FileAssert.assertEquals(expected, actual);
  }

  //===========================================================================
  // Running test
  //===========================================================================
  
  public static List<String> runCommands(String scriptPath, String outputPath, 
      Logic logic) {
    ArrayList<String> statusList = new ArrayList<String>();

    try(BufferedReader br = new BufferedReader(new InputStreamReader(
        new FileInputStream(scriptPath)))) {
      String userInput;
      
      //Run all commands found in script sequentially
      while ((userInput = br.readLine()) != null) {
        Status result = logic.executeCommand(userInput);
        statusList.add(result.getFeedback());
      }
      logger.info("Success");
    } catch (IOException e) {
      logger.error(e.getMessage());
    }
      return statusList;
  }

}
```
###### src\test\raijin\integration\LogicStorageIT.java
``` java

package raijin.integration;

import static org.junit.Assert.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.HashMap;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import com.google.common.reflect.TypeToken;
import com.google.gson.JsonSyntaxException;
import com.google.gson.stream.JsonReader;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.utils.IDManager;
import raijin.logic.api.Logic;
import raijin.storage.api.Session;
import raijin.storage.api.TasksManager;
import raijin.storage.handler.StorageHandler;
import raijin.ui.Raijin;
import static raijin.storage.handler.StorageHandler.*;
import static org.mockito.Mockito.*;

public class LogicStorageIT {

  private static String[] sampleTasks;
  private static Logic logic;
  private static Session session;
  private static IDManager idManager;
  private String programPath;
  private String dataPath;
  private String userConfigPath;

  @Rule public TemporaryFolder programDirectory = new TemporaryFolder();
  @Rule public TemporaryFolder storageDirectory = new TemporaryFolder();


  @BeforeClass
  public static void setUpClass() throws Exception {
    logic = new Logic();
    session = Session.getSession();
    idManager = IDManager.getIdManager();
  }

  @Before
  public void setUp() throws IOException {
    programDirectory.newFolder("data");
    session.setupBase(programDirectory.getRoot().getAbsolutePath());
  }

  //===========================================================================
  // Helper methods
  //===========================================================================
  public <T> void writeDataToFile(String dataPath, T data) throws IOException {
    writeToFile(convertToJson(data), dataPath);
  }

  @SuppressWarnings("serial")
  public TasksManager readDataFromFile(String dataPath) throws JsonSyntaxException, IOException {
    JsonReader jsonReader = getJsonReaderFromFile(dataPath);
    return readFromJson(jsonReader, new TypeToken<TasksManager>() {}.getType());
  }
  
  /*Add random tasks to current tasksMap*/
  public void addRandomTasks() {
    TasksManager tasksManager = TasksManager.getManager();
    for (int i = 0; i < sampleTasks.length; i++) {
      tasksManager.addPendingTask(new Task(sampleTasks[i], idManager.getId()));
    }
  }

  /*Reset states of memory*/
  public void resetState() {
    IDManager.getIdManager().flushIdPool();
    TasksManager.getManager().setPendingTasks(new HashMap<Integer, Task>());
  }

  //===========================================================================
  // Test cases
  //===========================================================================

  @Test 
  public void setStorageDirectory_MatchUserLocationWithBaseConfig() throws IOException {
    String storagePath = storageDirectory.getRoot().getAbsolutePath();
    session.setStorageDirectory(storagePath, session.baseConfigPath);
    session.setupStorage();
    assertEquals(storagePath, StorageHandler.getStorageDirectory(session.baseConfigPath));
  }

}
```
###### src\test\raijin\integration\RaijinIT.java
``` java

package raijin.integration;

import static org.junit.Assert.*;

import java.util.HashMap;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.Task;
import raijin.common.utils.IDManager;
import raijin.helper.TestProperties;
import raijin.helper.TestUtils;
import raijin.logic.api.Logic;
import raijin.storage.api.TasksManager;

public class RaijinIT {

  private Logic logic;

  //===========================================================================
  // Helper 
  //==========================================================================
  
  void executeTest(String testCaseName) {
    //Given
    TestProperties properties = new TestProperties(testCaseName);
    TestUtils.runCommands(properties.testScript, properties.actualJSON.getAbsolutePath(),
        logic);
    
    //Then
    TestUtils.assertSimilarFiles(properties.expectedJSON, properties.actualJSON);
  }

  @Before
  public void setUp() throws Exception {
    logic = new Logic();
    TasksManager.getManager().setCompletedTasks(new HashMap<Integer, Task>());
    TasksManager.getManager().setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
  }

  /**
   * Test C.R.U.D features of Raijin
   */
  @Test
  public void testBasicCRUD() {
    executeTest("basicCRUD");
  }

}
```
###### src\test\raijin\logic\api\LogicTest.java
``` java

package raijin.logic.api;

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import raijin.common.datatypes.Status;


public class LogicTest {

  private static Logic logic;

  @Rule 
  public TemporaryFolder tmpFolder = new TemporaryFolder();

  @BeforeClass
  public static void setUpClass() throws Exception {
    logic = new Logic();
  }
  
  @Before
  public void setUp() {
    logic.getSession().setupBase(tmpFolder.getRoot().getAbsolutePath());
  }

  @After
  public void tearDown() {
    tmpFolder.delete();
  }

  @Test
  public void executeCommand_AddFloating() {
    Status result = logic.executeCommand("add something new");
    assertTrue(result.isSuccess());
  }

  @Test
  public void executeCommand_DeleteInvalidId() {
    Status result = logic.executeCommand("delete 200");
    assertFalse(result.isSuccess());
  }

}
```
###### src\test\raijin\logic\command\AddCommandRunnerTest.java
``` java

package raijin.logic.command;

import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import com.tngtech.java.junit.dataprovider.DataProviderRunner;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.IDManager;
import raijin.logic.api.CommandRunner;
import raijin.logic.parser.ParsedInput;
import raijin.storage.api.History;
import raijin.storage.api.Session;
import raijin.storage.api.TasksManager;

public class AddCommandRunnerTest {

  private AddCommandRunner addCommandRunner;
  private TasksManager tasksManager;

  //===========================================================================
  // Helper methods
  //===========================================================================
  
  public ParsedInput createSpecificTask(String inputName, DateTime dateTime) {
    return new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
      name(inputName).dateTime(dateTime).createParsedInput();
  }

  public Status addTask(String inputName, DateTime dateTime) throws UnableToExecuteCommandException {
    ParsedInput parsedInput = createSpecificTask(inputName, dateTime);
    
    Status returnStatus = addCommandRunner.execute(parsedInput);
    return returnStatus;
  }

  //===========================================================================
  // Test Cases
  //===========================================================================

  @Before
  public void setUp() throws Exception {
    addCommandRunner = new AddCommandRunner();
    tasksManager = TasksManager.getManager();
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
  }

  @Test
  public void execute_SpecificDeadline_ReturnSuccessfulStatus() throws UnableToExecuteCommandException {
    String inputName = "submit op2 to ms lee";
    DateTime dateTime = new DateTime("19/09/2015");
    Status returnStatus = addTask(inputName, dateTime);
    String expected = String.format("You have added \"%s\" successfully", inputName);
    
    assertEquals(expected, returnStatus.getFeedback());
  }
  
  @Test
  public void undo_SpecifiedDeadline() throws UnableToExecuteCommandException {
    addTask("submit op2 to ms lee", new DateTime("19/09/2015"));
    addCommandRunner.undo();
    assertTrue(tasksManager.isEmptyPendingTasks());
  }

  @Test
  public void redo_SpecifiedDeadline() throws UnableToExecuteCommandException, NoSuchTaskException {
    addTask("submit op2 to ms lee", new DateTime("19/09/2015"));
    addCommandRunner.undo();
    addCommandRunner.redo();
    assertEquals(tasksManager.getPendingTask(1).getName(), "submit op2 to ms lee");
  }

  @Test
  public void execute_WithHighPriority() throws UnableToExecuteCommandException, NoSuchTaskException {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name("submit test").priority("h").createParsedInput();
    addCommandRunner.execute(input);
    assertEquals("h", tasksManager.getPendingTask(1).getPriority());
  }
  
  @Test
  public void execute_DuplicateTask_ReturnWarning() throws UnableToExecuteCommandException {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name("submit op2 to ms lee").dateTime(new DateTime("19/09/2015")).createParsedInput();
    tasksManager.addPendingTask(new Task(input.getName(), IDManager.getIdManager().getId(), input));
    Status status = addTask("submit op2 to ms lee", new DateTime("19/09/2015"));
    assertEquals("Duplicate task(s) not added", status.getFeedback());
  }

  @Test
  public void undo_MultipleTasks() throws UnableToExecuteCommandException {
    TreeSet<String> testNames = new TreeSet<String>();
    testNames.add("I am cute");
    testNames.add("wash batu");
    testNames.add("watch monty");
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(testNames).priority("h").createParsedInput();

    addCommandRunner.execute(input);
    int afterAdd = tasksManager.getPendingTasks().size();
    addCommandRunner.undo();
    int afterUndo = tasksManager.getPendingTasks().size();
    
    assertEquals(3, afterAdd);
    assertEquals(0, afterUndo);
  }

  @Test
  public void redo_MultipleTasks() throws UnableToExecuteCommandException {
    TreeSet<String> testNames = new TreeSet<String>();
    testNames.add("I am cute");
    testNames.add("wash batu");
    testNames.add("watch monty");
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(testNames).priority("h").createParsedInput();

    addCommandRunner.execute(input);
    addCommandRunner.undo();
    int afterUndo = tasksManager.getPendingTasks().size();
    addCommandRunner.redo();
    int afterRedo = tasksManager.getPendingTasks().size();
    
    assertEquals(0, afterUndo);
    assertEquals(3, afterRedo);
  }

  @Test
  public void createStatus_MultipleTasks() throws UnableToExecuteCommandException {
    
    //Add some existing task
    tasksManager.addPendingTask(new Task("I am cute", 1));

    TreeSet<String> testNames = new TreeSet<String>();
    testNames.add("I am cute");
    testNames.add("wash batu");
    testNames.add("watch monty");
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(testNames).priority("h").createParsedInput();
    
    Status status = addCommandRunner.execute(input);
    String expected = "Duplicate task(s) not added";
    assertEquals(expected, status.getFeedback());
  }
  
  @Test
  public void processCommand_MultipleTasks() throws UnableToExecuteCommandException {
    addTask("I am weird", new DateTime("19/09/2011"));
    addTask("I am new", new DateTime("19/09/2011"));
    addTask("I am old", new DateTime("19/09/2011"));
  }
}
```
###### src\test\raijin\logic\command\CommandRunnerTestHelper.java
``` java

package raijin.logic.command;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.logic.parser.ParsedInput;

public class CommandRunnerTestHelper {
  
  public ParsedInput createAddTask(String inputName, DateTime dateTime) {
    ParsedInput addInput = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(inputName).dateTime(dateTime).createParsedInput();
    return addInput;
  }

  public ParsedInput createDeleteTask(int id) {
    ParsedInput deletedInput = new ParsedInput.ParsedInputBuilder(Constants.Command.DELETE).
        id(id).createParsedInput();
    return deletedInput;
  }
}
```
###### src\test\raijin\logic\command\DeleteCommandRunnerTest.java
``` java
package raijin.logic.command;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.HashMap;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Test;
import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.IDManager;
import raijin.logic.parser.ParsedInput;
import raijin.storage.api.TasksManager;

public class DeleteCommandRunnerTest {

  private DeleteCommandRunner deleteCommandRunner;
  private AddCommandRunner addCommandRunner;
  private TasksManager tasksManager;

  //===========================================================================
  // Helper methods
  //===========================================================================

  public Status addTask(String inputName, DateTime dateTime) throws UnableToExecuteCommandException {
    ParsedInput parsedInput = createSpecificTask(inputName, dateTime);
    Status returnStatus = addCommandRunner.processCommand(parsedInput);
    return returnStatus; 
  }

  public ParsedInput createSpecificTask(String inputName, DateTime dateTime) {
    return new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(inputName).dateTime(dateTime).createParsedInput();
  }

  public Status deleteTask(int id) throws UnableToExecuteCommandException {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.DELETE).
        id(id).createParsedInput();

    return deleteCommandRunner.processCommand(input);
  }

  public Status deleteTaskIDS(TreeSet<Integer> ids) throws UnableToExecuteCommandException {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.DELETE).
        id(ids).createParsedInput();

    return deleteCommandRunner.processCommand(input);
  }

  //===========================================================================
  // Test Cases
  //===========================================================================

```
###### src\test\raijin\logic\command\DeleteCommandRunnerTest.java
``` java
  public void delete_WrongID() throws UnableToExecuteCommandException {
    TreeSet<String> tags = new TreeSet<String>();
    tags.add("cs21011");
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.DELETE)
      .id(100).createParsedInput();

    deleteCommandRunner.processCommand(input);
  }

  @Test
  public void processCommand_OnlyTag() 
      throws UnableToExecuteCommandException, NoSuchTaskException {
    TreeSet<String> tags = new TreeSet<String>();
    tags.add("cs21011");
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.DELETE)
      .tag(tags).createParsedInput();
    addCommandRunner.processCommand(input);
    Status result = deleteCommandRunner.processCommand(input);
    assertTrue(result.isSuccess());
  }

}
```
###### src\test\raijin\logic\command\DoneCommandRunnerTest.java
``` java
package raijin.logic.command;

import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.FailedToParseException;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.IDManager;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.SimpleParser;
import raijin.storage.api.TasksManager;

public class DoneCommandRunnerTest {

  private DoneCommandRunner doneCommandRunner;
  private AddCommandRunner addCommandRunner;
  private TasksManager tasksManager;

  //===========================================================================
  // Helper methods
  //===========================================================================

  // All of these test cases are based on testing use cases and combining multiple inputs
  public Status addTask(String inputName, DateTime dateTime) throws UnableToExecuteCommandException {
    ParsedInput parsedInput = createSpecificTask(inputName, dateTime);
    Status returnStatus = addCommandRunner.processCommand(parsedInput);
    return returnStatus; 
  }

  public ParsedInput createSpecificTask(String inputName, DateTime dateTime) {
    return new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(inputName).dateTime(dateTime).createParsedInput();
  }

  public Status doneTask(int id) throws UnableToExecuteCommandException {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.DONE).
        id(id).createParsedInput();

    return doneCommandRunner.processCommand(input);
  }

  public Status doneTaskIDS(String input) 
      throws UnableToExecuteCommandException, FailedToParseException {
    ParsedInput parsed = new SimpleParser().parse(input);  
    return doneCommandRunner.processCommand(parsed);
  }

  //===========================================================================
  // Test Cases
  //===========================================================================
```
###### src\test\raijin\logic\command\DoneCommandRunnerTest.java
``` java
  @Test
  public void processCommand_DoneMultipleTasks() 
      throws UnableToExecuteCommandException, FailedToParseException { 
    addTask("Burn burn baby", new DateTime("31/08/2015"));
    addTask("Chill Chill baby", new DateTime("31/08/2015"));
    Status returnStatus = doneTaskIDS("done 1 2 3");
    String expectedStatusLine = String.format(Constants.FEEDBACK_DONE_SUCCESS, "Ice ice baby")
        +"\n"+ String.format(Constants.FEEDBACK_DONE_SUCCESS, "Burn burn baby") +"\n"+
        String.format(Constants.FEEDBACK_DONE_SUCCESS, "Chill Chill baby") +"\n";
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
    assertTrue(tasksManager.isEmptyPendingTasks());
  }


  public void undo_DoneMultipleTasks() 
      throws UnableToExecuteCommandException, NoSuchTaskException, FailedToParseException {
    addTask("Burn burn baby", new DateTime("31/08/2015"));
    addTask("Chill Chill baby", new DateTime("31/08/2015"));
    doneTaskIDS("done 1 2 3");
    doneCommandRunner.undo();
    assertTrue(tasksManager.isEmptyCompletedTasks());
    assertEquals("Ice ice baby", tasksManager.getPendingTask(1).getName());
    assertEquals("Burn burn baby", tasksManager.getPendingTask(2).getName());
    assertEquals("Chill Chill baby", tasksManager.getPendingTask(3).getName());
  }


  public void redo_DoneMultipleTasks() 
      throws UnableToExecuteCommandException, NoSuchTaskException, FailedToParseException {
    addTask("Burn burn baby", new DateTime("31/08/2015"));
    addTask("Chill Chill baby", new DateTime("31/08/2015"));
    doneTaskIDS("done 1 2 3");
    doneCommandRunner.undo();
    doneCommandRunner.redo();
    assertTrue(!tasksManager.isEmptyCompletedTasks());
    assertEquals("Ice ice baby", tasksManager.getCompletedTasks().get(1).getName());
    assertEquals("Burn burn baby", tasksManager.getCompletedTasks().get(2).getName());
    assertEquals("Chill Chill baby", tasksManager.getCompletedTasks().get(3).getName());
  }

}
```
###### src\test\raijin\logic\command\SetCommandRunnerTest.java
``` java

package raijin.logic.command;

import static org.junit.Assert.*;

import java.io.IOException;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Status;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.ParsedInputTest;
import raijin.storage.api.Session;
import raijin.storage.handler.StorageHandler;

public class SetCommandRunnerTest {

  private Session session;
  private SetCommandRunner setCommandRunner;
  private String storageDirectory;

  @Rule
  public TemporaryFolder tmpFolder = new TemporaryFolder();

  @Rule
  public TemporaryFolder baseFolder = new TemporaryFolder();

  @Before
  public void setUp() throws Exception {
    session = Session.getSession();
    session.setupBase(baseFolder.getRoot().getAbsolutePath());
    storageDirectory = session.storageDirectory;
    setCommandRunner = new SetCommandRunner();
  }
  
  @After
  public void tearDown() throws IOException {
    StorageHandler.writeToFile(storageDirectory, session.baseConfigPath);
  }

  @Test
  public void processCommand_ValidPath_ChangeStoragePath() throws UnableToExecuteCommandException {
    String initialStoragePath = session.storageDirectory;
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.SET).
        helperOption(tmpFolder.getRoot().getAbsolutePath()).createParsedInput();
   
    setCommandRunner.execute(input);
    String currentStoragePath = session.storageDirectory;
    assertNotEquals(initialStoragePath, currentStoragePath);
  }

  @Test
  public void processCommand_InvalidPath_ReturnFail() throws UnableToExecuteCommandException {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.SET).
        helperOption("/tmp/holland").createParsedInput();
   
    Status status = setCommandRunner.execute(input);
    assertEquals(setCommandRunner.FAIL_MESSAGE, status.getFeedback());
  }
}
```
###### src\test\raijin\logic\parser\ParsedInputTest.java
``` java
package raijin.logic.parser;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.exception.FailedToParseException;
import raijin.common.exception.IllegalCommandArgumentException;

public class ParsedInputTest {

  private SimpleParser parser;
  
  @Before
  public void setUp() throws Exception {
    parser = new SimpleParser();
  }

  @Test
  public void parseAddCommand_ReturnParsedInput() {
    //Creating parsedInput for add using builder
    ParsedInput addCommand = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name("submit op1").dateTime(new DateTime("19/12/1993")).createParsedInput();

    assertEquals("submit op1", addCommand.getName());
  }
  
```
###### src\test\raijin\logic\realtime\AutoCompleteTest.java
``` java

package raijin.logic.realtime;

import static org.junit.Assert.*;

import java.io.IOException;
import java.util.HashMap;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Test;

import com.google.common.reflect.TypeToken;
import com.google.gson.JsonParseException;
import com.google.gson.stream.JsonReader;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.utils.TaskUtils;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.ParsedInputTest;
import raijin.logic.realtime.AutoComplete;
import raijin.storage.api.TasksManager;
import raijin.storage.handler.StorageHandler;

public class AutoCompleteTest {

  private TasksManager tasksManager;
  private AutoComplete autoComplete;

  //===========================================================================
  // Helper method
  //===========================================================================
  
  
  public Task generateTagTask(String name, TreeSet<String> tags) {
    ParsedInput parsedInput = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(name).tag(tags).createParsedInput();
    return new Task(name, 1, parsedInput);
  }

  public void generateTasksManager() {
    TreeSet<String> tag = new TreeSet<String>();
    HashMap<Integer, Task> pendingTasks = new HashMap<Integer, Task>();
    tag.add("cs2101");
    pendingTasks.put(1, generateTagTask("I am cute", tag));
    tag.clear();
    tag.add("cs2103");
    tag.add("anime");
    pendingTasks.put(2, generateTagTask("I am batu", tag));
    tag.clear();
    tag.add("ant");
    pendingTasks.put(3, generateTagTask("I am bubble", tag));
    tasksManager.setPendingTasks(pendingTasks);
  }

  @Before
  public void setUp() throws Exception {
    tasksManager = TasksManager.getManager();
    autoComplete = new AutoComplete(tasksManager);
  }

  @Test
  public void getLastWord_SingleString() {
    String input = "add";
    String lastWord = autoComplete.getLastWord(autoComplete.getTokens(input));
    assertEquals("add", lastWord);
  }
  
  
  @Test
  public void getLastWord_NormalAddCommand() {
    String input = "add submit op";
    String lastWord = autoComplete.getLastWord(autoComplete.getTokens(input));
    assertEquals("op", lastWord);
  }

  @Test
  public void updateSuggestions_AddCommand() {
    String input = "a";
    autoComplete.updateSuggestions(input);
    assertEquals(1, autoComplete.suggestions.size());
  }

  @Test
  public void updateSuggestions_MultipleCommand() {
    String input = "d";
    autoComplete.updateSuggestions(input);
    assertEquals(3, autoComplete.suggestions.size());
  }
  
  @Test
  public void updateSuggestions_Tag() {
    generateTasksManager();
    autoComplete.loadTagList(TaskUtils.getTags(tasksManager.getPendingTasks()));
    String input = "add submit op1 #cs2101";
    autoComplete.updateSuggestions(input);
    assertEquals(1, autoComplete.suggestions.size());
    input = "add submit op1 #an";
    autoComplete.updateSuggestions(input);
    assertEquals(2, autoComplete.suggestions.size());
  }

  @Test
  public void updateSuggestions_Task() {
    generateTasksManager();
    autoComplete.loadTaskList(TaskUtils.getTaskNames(tasksManager.getPendingTasks()));
    String input = "add I am";
    autoComplete.updateSuggestions(input);
    assertEquals(3, autoComplete.suggestions.size());
  }
  
  @Test
  public void isCommandWithID_EmptyString() {
    String input = "";
    assertFalse(autoComplete.isCommandWithID(input));
  }
  
  @Test
  public void isCommandWithID_DoneCommand() {
    String input = "done something wrong";
    assertTrue(autoComplete.isCommandWithID(input));
  }

}

```
###### src\test\raijin\logic\realtime\TimeSlotTest.java
``` java

package raijin.logic.realtime;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.helper.TestUtils;
import raijin.logic.realtime.TimeSlot;

public class TimeSlotTest {

  private static TestUtils testUtils;
  private static ArrayList<Task> pendingTasks;
  private static LocalDate testDate;

  @BeforeClass
  public static void setUpClass() {
    testUtils = new TestUtils();
    pendingTasks = new ArrayList<Task>();
    testDate = LocalDate.of(2015, 12, 12);
  }

  @Before
  public void setUp() {
    pendingTasks.clear();
  }

  @Test
  public void getEvents_OneMatched() {
    //Testing for event that spans several days
    pendingTasks.add(testUtils.createTask("Normal task", new DateTime(testDate, 
        testDate.plusDays(2L))));

    //Testing for task with specific date
    pendingTasks.add(testUtils.createTask("Specific deadline", new DateTime(
        "12/12/2015", "1000")));
    
    pendingTasks.add(testUtils.createTask("event", new DateTime(
        "12/12/2015", "1000", "1200")));
    
    TimeSlot timeSlot = new TimeSlot(testDate, pendingTasks);
    List<Task> result = timeSlot.getEvents();
    
    assertEquals(1, result.size());
  }

  @Test
  public void getOccupiedSlots_Test1() {

    pendingTasks.add(testUtils.createTask("event 1", new DateTime(testDate,
        LocalTime.of(7, 0), testDate, LocalTime.of(9, 0))));

    pendingTasks.add(testUtils.createTask("event 2", new DateTime(testDate,
        LocalTime.of(15, 0), testDate, LocalTime.of(17, 0))));

    //Overlap event
    pendingTasks.add(testUtils.createTask("event 3", new DateTime(testDate,
        LocalTime.of(16, 0), testDate, LocalTime.of(16, 45))));

    //Long event
    pendingTasks.add(testUtils.createTask("event 4", new DateTime(testDate,
        LocalTime.of(12, 0), testDate, LocalTime.of(19, 0))));

    TimeSlot timeSlot = new TimeSlot(testDate, pendingTasks);
    LocalTime result = timeSlot.getOccupiedSlots().get(0).getStartTime();
    
    assertTrue(result.equals(LocalTime.of(12, 0)));
    
  }
  
  @Test
  public void getDuration() {
    LocalTime start = LocalTime.of(5, 45);
    LocalTime end = LocalTime.of(6, 50);
    TimeSlot timeSlot = new TimeSlot(testDate, pendingTasks);
    
    assertEquals(65, timeSlot.getDuration(start, end));
  }

  @Test
  public void streamlineEvents_Test1() {

    pendingTasks.add(testUtils.createTask("event 0", new DateTime(testDate,
        LocalTime.of(5, 0), testDate, LocalTime.of(6, 0))));

    pendingTasks.add(testUtils.createTask("event 1", new DateTime(testDate,
        LocalTime.of(20, 0), testDate, LocalTime.of(22, 0))));

    pendingTasks.add(testUtils.createTask("event 2", new DateTime(testDate,
        LocalTime.of(8, 0), testDate, LocalTime.of(12, 0))));

    //Overlap event
    pendingTasks.add(testUtils.createTask("event 3", new DateTime(testDate,
        LocalTime.of(16, 0), testDate, LocalTime.of(16, 45))));

    //Long event
    pendingTasks.add(testUtils.createTask("event 4", new DateTime(testDate,
        LocalTime.of(12, 0), testDate, LocalTime.of(19, 0))));

    pendingTasks.add(testUtils.createTask("event 5", new DateTime(testDate,
        LocalTime.of(20, 20), testDate, LocalTime.of(23, 0))));

    TimeSlot timeSlot = new TimeSlot(testDate, pendingTasks);

    List<DateTime> result = timeSlot.getOccupiedSlots();
    assertEquals(3, result.size());

  }
}
```
###### src\test\raijin\storage\api\HistoryTest.java
``` java

package raijin.storage.api;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.rmi.UnexpectedException;
import java.util.EmptyStackException;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import raijin.common.exception.UnableToExecuteCommandException;
import raijin.logic.command.AddCommandRunner;


public class HistoryTest {

  private static History history;
  private static AddCommandRunner addCommandRunner;

  @BeforeClass
  public static void setUpClass() throws Exception {
    history = History.getHistory();
    addCommandRunner = mock(AddCommandRunner.class);
  }

  @Test
  public void isEmptyUndoStack_EmptyStack_ReturnFalse() {
    history.clear();
    assertTrue(history.isEmptyUndoStack());
  }

  @Test
  public void isEmptyRedoStack_EmptyStack_ReturnFalse() {
    history.clear();
    assertTrue(history.isEmptyRedoStack());
  }
  
  @Test
  public void addCommand_ValidCommand_VerifyAdded() {
    //Ensures start from clean slate
    history.clear();
    history.pushCommand(addCommandRunner);
    assertFalse(history.isEmptyUndoStack());
  }
  
  @Test
  public void undo_VerifyAddedToRedoStack() throws UnableToExecuteCommandException {
    //Ensures start from clean slate
    history.clear();
    history.pushCommand(addCommandRunner);
    history.undo();
    assertFalse(history.isEmptyRedoStack());
  }

  @Test
  public void redo_VerifyAddedToUndoStack() throws UnableToExecuteCommandException {
    //Ensures start from clean slate
    history.clear();
    history.pushCommand(addCommandRunner);
    history.undo();
    history.redo();
    assertFalse(history.isEmptyUndoStack());
  }

  @Test(expected=UnableToExecuteCommandException.class)
  public void undo_NoCommandsInStack_ThrowException() throws UnableToExecuteCommandException {
    history.clear();
    history.undo();
  }

  @Test(expected=UnableToExecuteCommandException.class)
  public void redo_NoCommandsInStack_ThrowException() throws UnableToExecuteCommandException {
    history.clear();
    history.redo();
  }

}
```
###### src\test\raijin\storage\api\SessionTest.java
``` java

package raijin.storage.api;

import static org.junit.Assert.*;

import java.io.File;
import java.io.UnsupportedEncodingException;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import raijin.common.datatypes.Constants;
import raijin.common.exception.StorageFailureException;
import raijin.storage.handler.StorageHandler;

public class SessionTest {

  private static Session session;
  private static String invalidJsonFile = "/test-classes/invalid.json";
  private static String wrongFormatFile = "/test-classes/wrongFormat.json";
  private static String nothing = "/nothing";

  @Rule public TemporaryFolder tmpFolder = new TemporaryFolder();

  @BeforeClass
  public static void setUpClass() throws Exception {
    session = Session.getSession();
    invalidJsonFile = StorageHandler.getJarPath() + invalidJsonFile;
    wrongFormatFile = StorageHandler.getJarPath() + wrongFormatFile;
    nothing = StorageHandler.getJarPath() + nothing;
  }

  @AfterClass
  public static void tearDownClass() throws Exception {
    new File(invalidJsonFile).delete();
    new File(wrongFormatFile).delete();
    new File(nothing).delete();
  }

  @Test
  public void testProgramDirectory_MatchWithTargetDirectory() throws UnsupportedEncodingException {
    String expected = StorageHandler.getJarPath() + Constants.NAME_USER_FOLDER;
    session.setupBase(expected);
    assertEquals(expected, session.programDirectory);
  }
  
  @Test(expected = StorageFailureException.class)
  public void initTasksManager_InvalidJson() throws UnsupportedEncodingException {
    session.getDataFromJson(StorageHandler.getJarPath() + invalidJsonFile);
  }

  @Test(expected = StorageFailureException.class)
  public void initTasksManager_WrongFormat() throws UnsupportedEncodingException {
    TasksManager tasksManager = session.getDataFromJson(StorageHandler.getJarPath() 
        + wrongFormatFile);
  }

  @Test(expected = StorageFailureException.class)
  public void initTasksManager_MissingFile() throws UnsupportedEncodingException {
    TasksManager tasksManager = session.getDataFromJson(StorageHandler.getJarPath() 
        + "/nothing");
  }
}
```
###### src\test\raijin\storage\api\TasksManagerTest.java
``` java

package raijin.storage.api;

import static org.junit.Assert.*;

import java.util.HashMap;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;

import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.utils.IDManager;
import raijin.common.utils.RaijinLogger;

public class TasksManagerTest {

  private TasksManager tasksManager;
  private static IDManager idManager;

  @BeforeClass
  public static void setUpClass() {
    idManager = IDManager.getIdManager();
  }

  @Before
  public void setUp() throws Exception {
    tasksManager = TasksManager.getManager();
    /*Reset state of pending tasks*/
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    tasksManager.setCompletedTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
  }

  @Test
  public void getPendingTasks_ReturnValidTask() throws NoSuchTaskException {
    Task input = new Task("submit op1", idManager.getId());
    tasksManager.addPendingTask(input);
    assertEquals("submit op1", tasksManager.getPendingTask(1).getName());
  }


  @Test(expected = NoSuchTaskException.class)
  public void getPendingTasks_ThrowException() throws NoSuchTaskException {
    tasksManager.getPendingTask(1);
  }

}
```
###### src\test\raijin\storage\handler\StorageHandlerTest.java
``` java

package raijin.storage.handler;

import static org.junit.Assert.*;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.storage.api.TasksManager;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;

public class StorageHandlerTest {

  @Rule public TemporaryFolder tmpFolder = new TemporaryFolder();

  @Test
  public void testCreateDirectory() throws IOException {
    String path = tmpFolder.getRoot().getAbsolutePath();
    tmpFolder.newFolder("data");
    assertFalse(StorageHandler.createDirectory(path+"/data"));
  }


  @Rule public TemporaryFolder tmpFolder2 = new TemporaryFolder();
  @Test
  public void testCopyFiles() throws IOException {
    String path2 = tmpFolder2.getRoot().getAbsolutePath();
    File targetFile = tmpFolder.newFile("test.lol");
    StorageHandler.copyFiles(targetFile.toPath(), tmpFolder2.getRoot().toPath());
    assertFalse(new File(path2, "test.lol").exists());
  }
  
  @Test
  public void testIsDirectory() throws IOException {
    assertTrue(StorageHandler.isDirectory(tmpFolder.getRoot().getAbsolutePath()));
    File targetFile = tmpFolder.newFile("test.lol");
    assertFalse(StorageHandler.isDirectory(targetFile.getAbsolutePath()));
  }

  @Test
  public void testReadWriteJson() throws IOException {
    File testFile = tmpFolder.newFile("test.json");
    HashMap<String, String> config = new HashMap<String, String>();
    config.put("status", "running");
    config.put("undo", "Ctrl+Z");
    config.put("exit", "Alt+F4");
    StorageHandler.writeToFile(
        StorageHandler.convertToJson(config), testFile.getAbsolutePath());
    HashMap<String, String> config2 = StorageHandler.readFromJson(
        StorageHandler.getJsonReaderFromFile(testFile.getAbsolutePath()), 
        new TypeToken<HashMap<String, String>>(){}.getType());
    assertEquals(config, config2);
  }
  
  @Test
  public void testCreateFile() throws IOException {
    String expectedPath = tmpFolder.getRoot().getAbsolutePath() + Constants.NAME_BASE_CONFIG;
    StorageHandler.createFile(expectedPath);
    assertTrue(new File(expectedPath).exists());
  }

  @Test
  public void testGetStorageDirectory() throws IOException {
    File baseConfig = tmpFolder.newFile("base.cfg");
    String expectedStorageLocation = tmpFolder2.getRoot().getAbsolutePath();
    StorageHandler.writeToFile(expectedStorageLocation, baseConfig.getAbsolutePath());
    String storageLocation = StorageHandler.getStorageDirectory(baseConfig.getAbsolutePath());
    assertEquals(expectedStorageLocation, storageLocation);
  }

  @Test
  public void sanitizePath_WindowPath_ReturnInvariantPath() {
    String input = "/D:/LingJie Work/Workspace/Repo/main/target/classes/data";
    String expected = "D:/LingJie Work/Workspace/Repo/main/target/classes/data";
    
    String sanitized = StorageHandler.sanitizePath(input);
    assertEquals(expected, sanitized);
  }
  
}
```
###### src\test\raijin\ui\DisplayControllerIT.java
``` java

package raijin.ui;

import static org.junit.Assert.*;

import java.io.FileNotFoundException;
import java.time.LocalDate;
import java.time.LocalTime;
import java.util.HashMap;
import java.util.List;

import javafx.application.Platform;
import javafx.scene.Parent;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.input.KeyCode;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.loadui.testfx.GuiTest;
import org.loadui.testfx.utils.FXTestUtils;
import org.mockito.Mockito;


import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.ChangeViewEvent;
import raijin.common.eventbus.events.SetCurrentDisplayEvent;
import raijin.common.eventbus.events.TasksChangedEvent;
import raijin.common.utils.TaskUtils;
import raijin.helper.TestUtils;
import raijin.logic.api.Logic;
import raijin.storage.api.TasksManager;

public class DisplayControllerIT {

  private static final LocalDate overdue = LocalDate.now().minusDays(2L);
  private static final LocalDate today = LocalDate.now();
  private static final LocalDate tomorrow = today.plusDays(1L);
  private static final LocalDate future = today.plusDays(5L);

  private static final String specific = "19/09/2100";
  private static final String specific2 = "21/09/2100";

  private static DisplayController displayController;
  private static GuiTest raijin;
  private static Logic logic;
  private static RaijinEventBus eventbus = RaijinEventBus.getInstance();


  private static HashMap<Integer, Task> pendingTasks;
  private static HashMap<Integer, Task> completedTasks;
  private static TestUtils testUtils;

  @Rule
  public TemporaryFolder tmpFolder = new TemporaryFolder();

  @BeforeClass
  public static void setUpClass() throws InterruptedException, FileNotFoundException {
    //================
    // Init UI
    //================

    FXTestUtils.launchApp(Raijin.class);
    Thread.sleep(1000);                     //Wait for program to be launched
    raijin = new GuiTest() {

      @Override
      protected Parent getRootNode() {
        return Raijin.getStage().getScene().getRoot();
      }

    };

    //====================
    // Init domain objects
    //====================
    
    logic = new Logic();
    testUtils = new TestUtils();
    pendingTasks = new HashMap<Integer, Task>();
    
    DateTime overdueDate = new DateTime(overdue, null, overdue, LocalTime.MAX);
    DateTime todayDate = new DateTime(today, null, today, LocalTime.MAX);
    DateTime tomorrowDate = new DateTime(tomorrow, null, tomorrow, LocalTime.MAX);
    DateTime futureDate = new DateTime(future, null, future, LocalTime.MAX);

    /*Adding floating tasks*/
    pendingTasks.put(1, new Task("test 1", 1));
    pendingTasks.put(2, new Task("test 2", 2));
    pendingTasks.put(3, new Task("test 3", 3));

    /*Adding overdue tasks*/
    pendingTasks.put(4, testUtils.createTask("meet james", overdueDate));
    pendingTasks.put(5, testUtils.createTask("meet thompson", overdueDate));

    /*Adding specific task*/
    pendingTasks.put(6, testUtils.createTask("meet thompson", new DateTime(
        LocalDate.of(2100, 9, 19), LocalDate.of(2100, 9, 19))));
    pendingTasks.put(13, testUtils.createTask("meet bomb", new DateTime(
        LocalDate.of(2100, 9, 21), LocalDate.of(2100, 9, 21))));
    /*Today's tasks*/
    pendingTasks.put(7, testUtils.createTask("meet owl", todayDate));
    pendingTasks.put(8, testUtils.createTask("meet hoot", todayDate));
    /*Tomorrow's tasks*/
    pendingTasks.put(9, testUtils.createTask("buy toy gun gun", tomorrowDate));
    pendingTasks.put(10, testUtils.createTask("meet pinu", tomorrowDate));
    /*Future's tasks*/
    pendingTasks.put(11, testUtils.createTask("buy toy gun gun", futureDate));

    /*Adding completed task*/
    completedTasks = new HashMap<Integer, Task>();
    completedTasks.put(12, new Task("test", 4));

    TasksManager.getManager().setPendingTasks(pendingTasks);
    TasksManager.getManager().setCompletedTasks(completedTasks);

    displayController = new DisplayController();
  }

  @Test
  public void displayFloating_ReturnThreeTasks() {
    logic.executeCommand("display f");
    List<Task> displayedTasks = eventbus.getDisplayedTasks();
    assertEquals(3, displayedTasks.size());
  }

  @Test
  public void displayOverdue_ReturnTwoTasks() {
    logic.executeCommand("display o");
    List<Task> displayedTasks = eventbus.getDisplayedTasks();
    assertEquals(2, displayedTasks.size());
  }

  @Test
  public void displayCompleted_ReturnOneTask() {
    logic.executeCommand("display c");
    List<Task> displayedTasks = eventbus.getDisplayedTasks();
    assertEquals(1, displayedTasks.size());
  }

  @Test
  public void displaySpecific_ReturnOneTask() {
    logic.executeCommand("display " + specific);
    List<Task> displayedTasks = eventbus.getDisplayedTasks();
    assertEquals(1, displayedTasks.size());
  }

  @Test
  public void displayAll_ReturnTwelveTasks() {
    logic.executeCommand("display a");
    List<Task> displayedTasks = eventbus.getDisplayedTasks();
    assertEquals(12, displayedTasks.size());
  }

  @Test
  public void displayDefault_ReturnTenTasks() {
    logic.executeCommand("display");
    List<Task> displayedTasks = eventbus.getDisplayedTasks();
    assertEquals(10, displayedTasks.size());
  }

  @Test
  public void displayRange_ReturnTwoTasks() {
    String dateInput = specific + " to " + specific2;
    logic.executeCommand("display " + dateInput);
    List<Task> displayedTasks = eventbus.getDisplayedTasks();
    assertEquals(2, displayedTasks.size());
  }

  @Test
  public void scrollUpDown_IndexReturnToOriginal() throws InterruptedException {
    raijin.push(KeyCode.PAGE_DOWN);
    raijin.push(KeyCode.PAGE_UP);
    int scrollIndex = DisplayController.scrollIndex;
    assertEquals(0, scrollIndex);
  }

}
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java

package raijin.ui;
  
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.HashMap;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import org.loadui.testfx.GuiTest;
import org.loadui.testfx.utils.FXTestUtils;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.RaijinEventBus;
import raijin.common.eventbus.events.SetFeedbackEvent;
import raijin.logic.api.Logic;
import raijin.storage.api.TasksManager;
import javafx.application.Platform;
import javafx.scene.Parent;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.HBox;
import javafx.scene.text.TextFlow;

public class RaijinInputIT {

  private static GuiTest raijin;
  private static RaijinEventBus eventbus;

  @BeforeClass
  public static void setUpClass() throws InterruptedException {
    FXTestUtils.launchApp(Raijin.class);
    Thread.sleep(7000);                     //Wait for program to be launched
    raijin = new GuiTest() {

      @Override
      protected Parent getRootNode() {
        return Raijin.getStage().getScene().getRoot();
      }

    };
    
    eventbus = RaijinEventBus.getInstance();
  }

  @Before
  public void setUp() {
    TasksManager.getManager().setPendingTasks(new HashMap<Integer, Task>());
  }

  @After
  public void cleanUp() {
    raijin.release(new KeyCode[] {});
    raijin.release(new MouseButton[] {});
    raijin.push(KeyCode.CONTROL, KeyCode.R);
  }

  @Test
  /*Testing autocomplete of add command*/
  public void testAddCommandAutoComplete() {
    raijin.type(KeyCode.A).push(KeyCode.TAB);
    TextField result = (TextField) GuiTest.find("#inputCommandBar");
    assertEquals("add", result.getText());
  }

  @Test
  public void testMaximiseShortcut() throws InterruptedException {
    Platform.runLater(new Runnable() {
      
      @Override
      public void run() {
        Raijin.getStage().setMaximized(false);
      }
    });
    Thread.sleep(500);
    raijin.push(KeyCode.ALT, KeyCode.M);
    Thread.sleep(2000);
    assertTrue(Raijin.getStage().isMaximized());
  }

  @Test
  public void testClearShortcut() throws InterruptedException {
    String testInput = "Write for fun";
    raijin.type(testInput);
    raijin.push(KeyCode.CONTROL, KeyCode.R);
    TextField result = (TextField) GuiTest.find("#inputCommandBar");
    assertEquals("", result.getText());
  }
  
  @Test
  public void testGetPreviousCommand() throws InterruptedException {
    String testInput = "Write for fun";
    raijin.type(testInput).press(KeyCode.ENTER);
    raijin.type("Does not matter").press(KeyCode.UP);
    TextField result = (TextField) GuiTest.find("#inputCommandBar");
    assertEquals(testInput, result.getText());
  }

  @Test
  public void testSetFeedbackEvent() throws InterruptedException {
    String testInput = "This is a normal feedback";
    eventbus.post(new SetFeedbackEvent(testInput));
    Label result = (Label) GuiTest.find("#feedbackBar");

    assertEquals(testInput, result.getText());
  }

  @Test
  public void testHelpBar() {
    raijin.type("edit 20");
    TextFlow result = (TextFlow) GuiTest.find("#helpBar");
    assertTrue(!result.getChildren().isEmpty());
  }

  @Test
  public void testUndoShortcut() {
    raijin.type("add floating boy").push(KeyCode.ENTER);
    raijin.push(KeyCode.CONTROL, KeyCode.Z);
    Label result = (Label) GuiTest.find("#feedbackBar");
    assertEquals(Constants.FEEDBACK_UNDO_SUCCESS, result.getText());
  }

  @Test
  public void testRedoShortcut() {
    raijin.type("add meet at Limbo").push(KeyCode.ENTER);
    raijin.push(KeyCode.CONTROL, KeyCode.Z);
    raijin.push(KeyCode.CONTROL, KeyCode.Y);
    Label result = (Label) GuiTest.find("#feedbackBar");
    assertEquals(Constants.FEEDBACK_REDO_SUCCESS, result.getText());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testHelpUsingCommand() {
    raijin.type("help").push(KeyCode.ENTER);
	assertTrue(Raijin.isHelpOn);
	raijin.push(KeyCode.CONTROL, KeyCode.H);
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testCutAndPasteShortcut() throws InterruptedException {
    Thread.sleep(500);
    raijin.type("help please cut");
    raijin.doubleClick().push(KeyCode.CONTROL, KeyCode.X);
	raijin.push(KeyCode.CONTROL, KeyCode.V);
    TextField result = (TextField) GuiTest.find("#inputCommandBar");
	assertEquals("help please cut", result.getText());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testGenerationOfTimeSlot() throws InterruptedException {
    Thread.sleep(500);
    raijin.type("add i am busy on 19/10 0800 to 1000").push(KeyCode.ENTER);
    raijin.type("add i am meeting on 19/10");
    HBox result = (HBox) GuiTest.find("#timeSlot");
	assertTrue(result.isVisible());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testDeleteGuide() throws InterruptedException {
    raijin.type("delete 1");
    TextFlow result = (TextFlow) GuiTest.find("#helpBar");
	assertTrue(result.isVisible());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testDoneGuide() throws InterruptedException {
    raijin.type("done 1");
    TextFlow result = (TextFlow) GuiTest.find("#helpBar");
	assertTrue(result.isVisible());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testSearchGuide() throws InterruptedException {
    raijin.type("search mario");
    TextFlow result = (TextFlow) GuiTest.find("#helpBar");
	assertTrue(result.isVisible());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testRedoGuide() throws InterruptedException {
    raijin.type("redo ");
    TextFlow result = (TextFlow) GuiTest.find("#helpBar");
	assertTrue(result.isVisible());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testAddBatchGuide() throws InterruptedException {
    raijin.type("add one ; two ; three");
    TextFlow result = (TextFlow) GuiTest.find("#helpBar");
	assertTrue(result.isVisible());
  }

  @Test
```
###### src\test\raijin\ui\RaijinInputIT.java
``` java
  public void testAddEventGuide() throws InterruptedException {
    raijin.type("add meet snoopy from ");
    TextFlow result = (TextFlow) GuiTest.find("#helpBar");
	assertTrue(result.isVisible());
  }

}
```
###### src\test\raijin\ui\SidebarControllerIT.java
``` java

package raijin.ui;

import static org.junit.Assert.*;

import java.io.FileNotFoundException;
import java.util.HashMap;

import javafx.application.Platform;
import javafx.scene.Parent;
import javafx.scene.control.Button;
import javafx.scene.control.Label;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.loadui.testfx.GuiTest;
import org.loadui.testfx.utils.FXTestUtils;
import org.mockito.Mockito;

import com.sun.javafx.robot.FXRobot;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.Task;
import raijin.common.eventbus.events.ChangeViewEvent;
import raijin.common.eventbus.events.TasksChangedEvent;
import raijin.common.utils.TaskUtils;
import raijin.logic.api.Logic;
import raijin.storage.api.TasksManager;

public class SidebarControllerIT {

  private static SidebarController sidebarController;

  private static GuiTest raijin;
  private static Logic logic;

  private static HashMap<Integer, Task> pendingTasks;

  private static HashMap<Integer, Task> completedTasks;

  @Rule
  public TemporaryFolder tmpFolder = new TemporaryFolder();

  @Before
  public void setUp() throws InterruptedException {
    Platform.runLater(new Runnable() {
      
      @Override
      public void run() {
        Raijin.getStage().setMaximized(true);
      }
    });
    Thread.sleep(1000);
  }

  @BeforeClass
  public static void setUpClass() throws InterruptedException, FileNotFoundException {
    //================
    // Init UI
    //================

    FXTestUtils.launchApp(Raijin.class);
    Thread.sleep(5000);                     //Wait for program to be launched
    raijin = new GuiTest() {

      @Override
      protected Parent getRootNode() {
        return Raijin.getStage().getScene().getRoot();
      }

    };


    //====================
    // Init domain objects
    //====================
    
    logic = new Logic();
    pendingTasks = new HashMap<Integer, Task>();
    pendingTasks.put(1, new Task("test 1", 1));
    pendingTasks.put(2, new Task("test 2", 2));
    pendingTasks.put(3, new Task("test 3", 3));

    completedTasks = new HashMap<Integer, Task>();
    completedTasks.put(4, new Task("test", 4));

    TasksManager.getManager().setPendingTasks(pendingTasks);
    TasksManager.getManager().setCompletedTasks(completedTasks);

    sidebarController = new SidebarController(logic);
  }
  
  @Test
  public void updateState_TestNumberOfPendingTasks() {
    TasksChangedEvent changeEvent = new TasksChangedEvent();
    sidebarController.updateState(changeEvent);
    assertEquals("3", sidebarController.numOfPending.getText());
  }

  @Test
  public void updateState_TestNumberOfCompletedTasks() {
    TasksChangedEvent changeEvent = new TasksChangedEvent();
    sidebarController.updateState(changeEvent);
    assertEquals("1", sidebarController.numOfCompleted.getText());
  }

  @Test
  public void updateView_ChangeToToday() {
    ChangeViewEvent event = new ChangeViewEvent(TaskUtils.getTasksList(
        pendingTasks), Constants.View.TODAY);
    sidebarController.updateFocus(event);
    assertEquals(sidebarController.currentFocusedButton, 
        sidebarController.today);
  }

  @Test
  public void updateView_ChangeToTomorrow() {
    ChangeViewEvent event = new ChangeViewEvent(TaskUtils.getTasksList(
        pendingTasks), Constants.View.TOMORROW);
    sidebarController.updateFocus(event);
    assertEquals(sidebarController.currentFocusedButton, 
        sidebarController.tomorrow);
  }
  
  @Test
  public void clickTomorrow_FocusOnTomorrowButton() throws InterruptedException {
    Button tomorrow = (Button) GuiTest.find("#tomorrow");
    raijin.move(tomorrow).click(tomorrow);
    Button focusButton = sidebarController.currentFocusedButton;
    assertEquals(focusButton, sidebarController.tomorrow);
  }

  @Test
  public void clickFuture_FocusOnNextWeekButton() {
    Button future = (Button) GuiTest.find("#future");
    raijin.move(future).click(future);
    Button focusButton = sidebarController.currentFocusedButton;
    assertEquals(focusButton, sidebarController.future);
  }

}
```
###### target\classes\raijin\ui\resource\layout\SidebarController.fxml
``` fxml

<?import javafx.scene.image.*?>
<?import javafx.scene.shape.*?>
<?import javafx.scene.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.text.*?>
<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.BorderPane?>

<fx:root maxWidth="-Infinity" prefHeight="-1.0" prefWidth="170.0" type="BorderPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
  <center>
    <VBox prefHeight="185.0" prefWidth="200.0" spacing="15.0" style="-fx-background-color: #ffffff; -fx-border-color: #ffffff #eeeeee  #ffffff #ffffff; -fx-border-width: 2px;">
      <children>
            <ImageView fitHeight="40.0" fitWidth="104.0" pickOnBounds="true" preserveRatio="true" translateX="30.0">
               <image>
                  <Image url="@../styles/RaijinLogo.png" />
               </image>
               <VBox.margin>
                  <Insets bottom="25.0" top="10.0" />
               </VBox.margin>
            </ImageView>
            <HBox fx:id="inboxHBox">
               <children>
                  <Button fx:id="inbox" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleInboxButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ccf8ff;" text="all" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfPending" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="18.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="todayHBox">
               <children>
              <Button fx:id="today" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleTodayButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="today" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                     <opaqueInsets>
                        <Insets />
                     </opaqueInsets>
                  </Button>
                  <Label fx:id="numOfToday" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="18.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="tomorrowHBox">
               <children>
              <Button fx:id="tomorrow" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleTomorrowButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="tomorrow" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfTomorrow" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="nextWeekHBox">
               <children>
              <Button fx:id="future" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleFutureButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="future" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfNextTasks" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <Separator prefWidth="200.0" />
            <HBox fx:id="overdueHBox">
               <children>
              <Button fx:id="overdue" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleOverdueButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="overdue" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfOverdue" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-background-color: #eeeeee; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5;" text="0" textFill="#e16363">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="completedHBox">
               <children>
              <Button fx:id="completed" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleCompletedButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="completed" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfCompleted" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0" textFill="#0ba9f2">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
            <HBox fx:id="completedHBox1">
               <children>
                  <Button fx:id="floating" alignment="TOP_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" mnemonicParsing="false" onAction="#handleFloatingButtonAction" prefHeight="33.0" prefWidth="122.0" style="-fx-background-color: #ffffff;" text="floating" wrapText="true" VBox.vgrow="NEVER">
                     <font>
                        <Font name="Droid Sans Mono" size="16.0" />
                     </font>
                  </Button>
                  <Label fx:id="numOfFloating" prefHeight="25.0" prefWidth="45.0" style="-fx-font-weight: bold; -fx-font-size: 16; -fx-border-radius: 5 5 5 5; -fx-background-radius: 5 5 5 5; -fx-background-color: #eeeeee;" text="0">
                     <font>
                        <Font name="Droid Sans Georgian" size="16.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="10.0" right="10.0" top="3.0" />
                     </HBox.margin>
                     <padding>
                        <Insets left="5.0" />
                     </padding>
                  </Label>
               </children>
            </HBox>
      </children>
         <opaqueInsets>
            <Insets />
         </opaqueInsets>
    </VBox>
  </center>
</fx:root>
```
