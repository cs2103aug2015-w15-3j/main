# A0124745E
###### src\main\raijin\common\datatypes\Constants.java
``` java
  public static final String FEEDBACK_NO_TASK_NAME = "Error: Please specify a name for your task!";
  public static final String FEEDBACK_NO_TASK_ID = "Error: Please specify a task ID!";
  public static final String FEEDBACK_NO_KEYWORDS = "Error: Please specify keywords to search!";
  public static final String FEEDBACK_NO_FILEPATH = "Error: Please specify a file path!";
  public static final String FEEDBACK_INVALID_CMD = "Error: Please use a valid command!";
  public static final String FEEDBACK_INVALID_ID = "Error: Please specify a number for the task ID!";
  public static final String FEEDBACK_INVALID_DATE = "Error: The date you gave doesn't exist!";
  public static final String FEEDBACK_INVALID_SUBTASK = "Error: Subtask ID needs to be a number!";
  public static final String FEEDBACK_INVALID_PRIORITY = "Error: Invalid priority type!";
  public static final String FEEDBACK_INVALID_STARTTIME = "Error: Invalid start time format!";
  public static final String FEEDBACK_INVALID_ENDDATE = "Error: Invalid end date format!";
  public static final String FEEDBACK_INVALID_ENDTIME = "Error: Invalid end time format!";
  public static final String FEEDBACK_INVALID_ENDDATETIME = "Error: Invalid end date/time format!";
  
  //==================
  // Display 
  //==================
```
###### src\main\raijin\common\datatypes\Constants.java
``` java
  
  // Regex for recognizing date patterns. Available test cases at: http://fiddle.re/56t2j6
  public static final String DATE_PATTERN = "^(0?[1-9]|[12][0-9]|3[01])(\\/|-|\\.)((0?[1-9]|1[012])"
      + "|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)((\\/|-|\\.)(\\d{4}|\\d{2}))?$";
  
  public static final String DATE_START_PREPOSITION = "by|at|on|during|from";
  public static final String DATE_END_PREPOSITION = "to|till|until|-";
  
  // Regex for recognizing a date operator. Used for splitting into String array.
  public static final String DATE_OPERATOR = "(\\/|-|\\.)";
  
  // Regex for recognizing priority/subtask/tag operator.
  public static final String PREFIXES = "^[!|@|#|$].*";

  // Regex for recognizing 24hr time patterns. Available test cases at: http://fiddle.re/bc9mj6
  public static final String TIME24_PATTERN = "^([01]?[0-9]|2[0-3])[0-5][0-9]$";
  //Regex for recognizing 24hr time patterns. Available test cases at: http://fiddle.re/dfduv6
  public static final String TIME12_PATTERN = "(0?[1-9]|1[0-2])((.|:)[0-5][0-9])?(am?|pm?)";
  public static final String TIME_PATTERN = TIME24_PATTERN +"|"+ TIME12_PATTERN;
  
  public static final String[] MONTHS = new String[]{"jan","feb","mar","apr","may","jun","jul",
      "aug","sep","oct","nov","dec"};
  
  // Regex for recognizing days input.
  public static final String DAYS = "mond?a?y?|tues?d?a?y?|wedn?e?s?d?a?y?|thur?s?d?a?y?|frid?a?y?"
      + "|satu?r?d?a?y?|sund?a?y?";
  public static final String[] DAYS_LIST = new String[]{"mond?a?y?", "tues?d?a?y?", 
      "wedn?e?s?d?a?y?", "thur?s?d?a?y?", "frid?a?y?", "satu?r?d?a?y?", "sund?a?y?"};
  
  //===========================================================================
  // Command related constants
  //===========================================================================
```
###### src\main\raijin\logic\command\EditCommandRunner.java
``` java
package raijin.logic.command;

import java.util.TreeSet;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Task;
import raijin.common.datatypes.Status;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.logic.api.CommandRunner;
import raijin.logic.api.UndoableRedoable;
import raijin.logic.parser.ParsedInput;

public class EditCommandRunner extends CommandRunner implements UndoableRedoable {

  private ParsedInput inputBeforeChange;
  private Task taskAfterChange;
  private Task taskBeforeChange;
  
  Task modifyTask(ParsedInput input) {
    String name = (input.getName() == "") ? taskBeforeChange.getName() : input.getName();
    String priority = (input.getPriority() != null) 
        ? input.getPriority() : taskBeforeChange.getPriority();
    TreeSet<String> tags = (input.getTags().isEmpty()) 
        ? taskBeforeChange.getTags() : input.getTags();
    DateTime date = (input.getDateTime() == null) 
        ? taskBeforeChange.getDateTime() : input.getDateTime();
    //int id = idManager.getId();    
        
    ParsedInput modifiedInput = new ParsedInput.ParsedInputBuilder(Constants.Command.EDIT)
        .name(name).dateTime(date).priority(priority).tag(tags).createParsedInput();
    
    return new Task(name, taskBeforeChange.getId(), modifiedInput);
  }
  
  Status editSuccessfulStatus() {
    String taskName = taskAfterChange.getName();
    taskName = normalizeTaskName(taskName);
    return new Status(String.format(Constants.FEEDBACK_EDIT_SUCCESS, taskName));
  }
  
  public Status processCommand(ParsedInput input) throws UnableToExecuteCommandException {
    try {
      inputBeforeChange = input;
      taskBeforeChange = tasksManager.getPendingTask(input.getId());
      tasksManager.editPendingTask(taskBeforeChange.getId());
    } catch (NoSuchTaskException e) {
      wrapLowerLevelException(e, Constants.Command.EDIT);
    }
    taskAfterChange = modifyTask(input);
    tasksManager.addPendingTask(taskAfterChange);
    history.pushCommand(this);
    return editSuccessfulStatus();
  }

  public void undo() throws UnableToExecuteCommandException  {
    try {
      tasksManager.editPendingTask(taskAfterChange.getId());
    } catch (NoSuchTaskException e) {
      wrapLowerLevelException(e, Constants.Command.EDIT);
    }
    tasksManager.addPendingTask(taskBeforeChange);
  }

  public void redo() throws UnableToExecuteCommandException {
    try {
      tasksManager.deletePendingTask(taskBeforeChange.getId());
    } catch (NoSuchTaskException e) {
      wrapLowerLevelException(e, Constants.Command.EDIT);
    }
    taskAfterChange.setId(idManager.getId());
    tasksManager.addPendingTask(taskAfterChange);
    
  }

}
```
###### src\main\raijin\logic\parser\AddParser.java
``` java

package raijin.logic.parser;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.TreeSet;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.exception.IllegalCommandArgumentException;

public class AddParser {
  
  private String[] wordsOfInput;
  private ParsedInput.ParsedInputBuilder builder;
  private TreeSet<String> tags;
  private TreeSet<String> names;
  private String currentTime;
  private String currentDate;
  private int parseType; // 0 for add, 1 for edit, 2 for display.
  
  private boolean containsStartDate;
  private boolean containsEndDate;
  private boolean containsStartTime;
  private boolean containsEndTime;
  
  private static final String datePattern = Constants.DATE_PATTERN;
  private static final String dateOperator = Constants.DATE_OPERATOR;
  private static final String timePattern = Constants.TIME_PATTERN;
  private static final DateTimeFormat dtFormat = new DateTimeFormat();
  
  private String name, startDate, startTime, endDate, endTime;
  private int start, tpsIndex, index;
  
  public AddParser(ParsedInput.ParsedInputBuilder builder, String[] wordsOfInput, int type) 
      throws IllegalCommandArgumentException {
    
    if (type == 0 && wordsOfInput.length < 2) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_NO_TASK_NAME,
          Constants.CommandParam.NAME);
    }  
    
    this.wordsOfInput = wordsOfInput;
    this.builder = builder;
    tags = new TreeSet<String>();
    names = new TreeSet<String>();
    
    containsStartDate = false;
    containsEndDate = false;
    containsStartTime = false;
    containsEndTime = false;
    
    parseType = type;
    currentTime = LocalTime.now().format(DateTimeFormatter.ofPattern("HHmm"));
    currentDate = LocalDate.now().format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
    
    name = ""; 
    startDate = ""; 
    startTime = ""; 
    endDate = ""; 
    endTime = "";
    
  }
  
  /**
   * Method that parses the input for name, date or time inputs when task is added.
   * 
   * @return    ParsedInputBuilder                 Appropriate ParsedInputBuilders accordingly.
   * @throws    IllegalCommandArgumentException
   */
  public ParsedInput.ParsedInputBuilder process() throws IllegalCommandArgumentException {
    start = 1; // For recording starting index of the name currently being checked
    index = wordsOfInput.length; // (Last index of task name - 1) currently being checked
    tpsIndex = wordsOfInput.length; // Latest index of tag/priority/subtask inputs
    
    for (int i = 0; i < wordsOfInput.length; i++) {
      if (wordsOfInput[i].toLowerCase().matches(Constants.DATE_START_PREPOSITION)) {
        
        // Checks for format of {startDate}. If doesn't exist, ignore.
        if (i < wordsOfInput.length-1 && wordsOfInput[i+1].toLowerCase().matches(datePattern)) {
          
          containsStartDate = true;
          index = tpsIndex > i ? i : tpsIndex ;
          startDate = wordsOfInput[i+1];
          
          // startDate {startTime}
          if (i < wordsOfInput.length-2 && wordsOfInput[i+2].toLowerCase().matches(timePattern)) {
            containsStartTime = true;
            startTime = wordsOfInput[i+2];
          } else if (i < wordsOfInput.length-2 
              && !wordsOfInput[i+2].toLowerCase().matches(timePattern)
              && !wordsOfInput[i+2].matches(Constants.DATE_END_PREPOSITION) 
              && !wordsOfInput[i+2].equals(";") && !wordsOfInput[i+2].matches(Constants.PREFIXES)){
            throw new IllegalCommandArgumentException(Constants.FEEDBACK_INVALID_STARTTIME,
                Constants.CommandParam.DATETIME); 
          }

          
          // startDate {endDate}
          if (i < wordsOfInput.length-3 && 
              wordsOfInput[i+2].toLowerCase().matches(Constants.DATE_END_PREPOSITION)) {
            if (wordsOfInput[i+3].toLowerCase().matches(datePattern)) {
              containsEndDate = true;
              endDate = wordsOfInput[i+3];
            } else {
              throw new IllegalCommandArgumentException(Constants.FEEDBACK_INVALID_ENDDATE,
                  Constants.CommandParam.DATETIME); 
            }
          }          
          
          if (containsStartDate && containsStartTime && i < wordsOfInput.length-4 && 
              wordsOfInput[i+3].toLowerCase().matches(Constants.DATE_END_PREPOSITION)) {
            
            if (wordsOfInput[i+4].toLowerCase().toLowerCase().matches(timePattern)) {
              
              // startDate startTime {endTime}
              containsEndTime = true;
              endTime = wordsOfInput[i+4];
              
            } else if (wordsOfInput[i+4].toLowerCase().matches(datePattern)) {
              
              // startDate startTime {endDate} endTime
              containsEndDate = true;
              endDate = wordsOfInput[i+4];
              
              // startDate startTime endDate {endTime}
              checkForEndTimeInput(i+5);
              
            } else {
              throw new IllegalCommandArgumentException(Constants.FEEDBACK_INVALID_ENDDATETIME,
                  Constants.CommandParam.DATETIME); 
            } 
            
          } 
        } else if (i < wordsOfInput.length-1 && 
            wordsOfInput[i+1].toLowerCase().matches(timePattern)) {
          
          // Checks for format of {startTime}. If doesn't exist, ignore.
          containsStartTime = true;
          index = tpsIndex > i ? i : tpsIndex ;
          startTime = wordsOfInput[i+1];
          
          // startTime {endTime}
          if (i < wordsOfInput.length - 3 && 
              wordsOfInput[i+2].toLowerCase().matches(Constants.DATE_END_PREPOSITION)) {
            checkForEndTimeInput(i+3);
          }
          
        } else if (i < wordsOfInput.length-1 && 
            wordsOfInput[i+1].toLowerCase().matches(Constants.DAYS + "|today|tdy|tomorrow|tmr")) {
          lookUpNextDay(i);
          
        } else if (i < wordsOfInput.length-1 && wordsOfInput[i+1].toLowerCase().equals("next")) { 
          lookUpNextDate(i);
        }
      }
    
      checkForPriority(i);
      checkForProject(i);
      checkForTag(i);
      checkForSubtask(i);
      checkForBatchAdding(i);
      
    }
    
    extractLastTaskName();
    
    formatDateTime();
    DateTime dateTime = createDateTime();
    
    return builder.name(names).dateTime(dateTime).tag(tags);
  }

  /**
   * Checks string for any day string input. Eg. Mon(day), Tue(sday), etc.
   * Also checks for "today" or "tomorrow" input and processes accordingly.
   * 
   * @param i           Index of string input array.
   * @throws IllegalCommandArgumentException
   */
  public void lookUpNextDay(int i) throws IllegalCommandArgumentException {
    containsStartDate = true;
    index = tpsIndex > i ? i : tpsIndex ;
    
    if (wordsOfInput[i+1].toLowerCase().matches(Constants.DAYS)) {
      // by (day)
      produceDateFromDay(wordsOfInput[i+1], 0);
    } else if (wordsOfInput[i+1].toLowerCase().matches("today|tdy")) {
      // by today
      produceDateFromDay(null, 5);
    } else if (wordsOfInput[i+1].toLowerCase().matches("tomorrow|tmr")) {
      // by tomorrow
      produceDateFromDay(null, 6);
    }
    
    if (i < wordsOfInput.length-2 && wordsOfInput[i+2].toLowerCase().matches(timePattern)) {
      containsStartTime = true;
      startTime = wordsOfInput[i+2];
    
      if (i < wordsOfInput.length - 4 && 
          wordsOfInput[i+3].toLowerCase().matches(Constants.DATE_END_PREPOSITION)) {
        checkForEndTimeInput(i+4);
      }
      
    }
  }
  
  /**
   * Processes the date that the user wants to look up for.
   * 
   * @param i       Index of string input array.
   * @throws IllegalCommandArgumentException 
   */
  public void lookUpNextDate(int i) throws IllegalCommandArgumentException {
    if (i < wordsOfInput.length-2) {           
      if (wordsOfInput[i+2].toLowerCase().matches(Constants.DAYS)) {
        // by next (day)
        containsStartDate = true;
        index = tpsIndex > i ? i : tpsIndex ;
        produceDateFromDay(wordsOfInput[i+2], 1);
        
        // by next day (starttime)
        if (i < wordsOfInput.length-3 && wordsOfInput[i+3].toLowerCase().matches(timePattern)) {
          containsStartTime = true;
          startTime = wordsOfInput[i+3];
          
          // by next day starttime (endtime)
          if (i < wordsOfInput.length - 5 && 
              wordsOfInput[i+4].toLowerCase().matches(Constants.DATE_END_PREPOSITION)) {
            checkForEndTimeInput(i+5);
          }
        }   
      } else if (wordsOfInput[i+2].toLowerCase().matches("week|wk")) {
        // by next (week)
        containsStartDate = true;
        index = tpsIndex > i ? i : tpsIndex ;
        produceDateFromDay(null, 2);
      } else if (wordsOfInput[i+2].toLowerCase().matches("month|mth")) {
        // by next (month)
        containsStartDate = true;
        index = tpsIndex > i ? i : tpsIndex ;
        produceDateFromDay(null, 3);
      } else if (wordsOfInput[i+2].toLowerCase().matches("year|yr")) {
        // by next (year)
        containsStartDate = true;
        index = tpsIndex > i ? i : tpsIndex ;
        produceDateFromDay(null, 4);
      }
    }
  }

  /**
   * Checks for any batch adding to be processed.
   * 
   * @param i       Index of string input array.
   * @throws IllegalCommandArgumentException
   */
  public void checkForBatchAdding(int i) throws IllegalCommandArgumentException {
    if (wordsOfInput[i].equals(";")) {
      if (index == wordsOfInput.length) {
        index = i;
      }
      extractLastTaskName();
      name = "";
      start = i+1;                    // Move on to check on next name
      index = wordsOfInput.length;    // Reset end index to end of string
    }
  }

  /**
   * Checks current word of array for any subtask association.
   * 
   * @param i       Index of string input array.
   * @throws IllegalCommandArgumentException
   */
  public void checkForSubtask(int i) throws IllegalCommandArgumentException {
    if (wordsOfInput[i].indexOf('@') == 0) {
      if ((!containsStartDate || !containsStartTime) && index > i) {
        index = i;
        tpsIndex = i;
      }
      String id = wordsOfInput[i].substring(1);
      try {
        builder.subTaskOf(Integer.parseInt(id));
      } catch (NumberFormatException e) {
        throw new IllegalCommandArgumentException(Constants.FEEDBACK_INVALID_SUBTASK,
            Constants.CommandParam.SUBTASKOF);
      }
    }
  }

  /**
   * Checks current word of array for any tag association.
   * 
   * @param i       Index of string input array.
   */
  public void checkForTag(int i) {
    if (wordsOfInput[i].indexOf('#') == 0) {
      if ((!containsStartDate || !containsStartTime) && index > i) {
        index = i;
        tpsIndex = i;
      }
      String tag = wordsOfInput[i].substring(1);
      tags.add(tag);
    }
  }

  /**
   * Checks current word of array for any project association.
   * 
   * @param i       Index of string input array.
   */
  public void checkForProject(int i) {
    if (wordsOfInput[i].indexOf('$') == 0) {
      if ((!containsStartDate || !containsStartTime) && index > i) {
        index = i;
        tpsIndex = i;
      }
      String project = wordsOfInput[i].substring(1);
      builder.project(project);
    }
  }

  /**
   * Checks current word of array for any priority adding.
   * 
   * @param i       Index of string input array.
   * @throws IllegalCommandArgumentException
   */
  public void checkForPriority(int i) throws IllegalCommandArgumentException {
    if (wordsOfInput[i].indexOf("!") == 0) {
      if ((!containsStartDate || !containsStartTime) && index > i) {
        index = i;
        tpsIndex = i;
      }
      String priority = wordsOfInput[i].substring(1);
      if (priority.matches("h|high")) {
        builder.priority(Constants.PRIORITY_HIGH);
      } else if (priority.matches("m|mid|middle|medium")) {
        builder.priority(Constants.PRIORITY_MID);
      } else if (priority.matches("l|low")) {
        builder.priority(Constants.PRIORITY_LOW);
      } else {
        throw new IllegalCommandArgumentException(Constants.FEEDBACK_INVALID_PRIORITY,
            Constants.CommandParam.PRIORITY);
      }
    }
  }
  
  /**
   * Method that produces a Date string based on day input by user
   * 
   * @param dayInput    Day of week input by user. Eg. Mon(day), Tue(sday), etc.
   * @param plus        Amount to add onto the date. 1 for next day, 2 week, 3 month & 4 for year.
   *                    5 for today, 6 for tomorrow.
   */
  public void produceDateFromDay(String dayInput, int plus) {
    LocalDate date = null;
    
    if (plus == 2) {
      date = LocalDate.now().plusWeeks(1);
    } else if (plus == 3) {
      date = LocalDate.now().plusMonths(1);
    } else if (plus == 4) {
      date = LocalDate.now().plusYears(1);
    } else if (plus == 5) {
      date = LocalDate.now();
    } else if (plus == 6) {
      date = LocalDate.now().plusDays(1);
    } else {
      for (int n = 0; n < Constants.DAYS_LIST.length; n++) {
        if (dayInput.toLowerCase().matches(Constants.DAYS_LIST[n])) {
          int days = (n+1) - LocalDate.now().getDayOfWeek().getValue();

          if (days >= 0) {
            if (plus == 1) {
              date = LocalDate.now().plusDays(days+7);
            } else {
              date = LocalDate.now().plusDays(days);
            }
          } else {
            date = LocalDate.now().plusDays(days+7);
          }

          break;
        }
      }
    }
    startDate = date.getDayOfMonth() + "/" + date.getMonthValue() + "/" +date.getYear();
  }
  
  /**
   * Extracts task names that has yet to be processed and checks if it is blank in the case of
   * adding. Throws exception as adding requires a task name.
   * 
   * @throws IllegalCommandArgumentException
   */
  public void extractLastTaskName() throws IllegalCommandArgumentException {
    // Adds name that isn't checked by ";" (i.e. start is < wordsOfInput.length)
    for (int n = start; n < index; n++) {
      if (wordsOfInput[n].indexOf("/") == 0) {
        name += wordsOfInput[n].substring(1);
      } else {
        name += wordsOfInput[n];
      }
      if (n < index-1) {
        name += " ";
      }
    }
    
    if (name.length() == 0 && parseType == 0) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_NO_TASK_NAME, 
          Constants.CommandParam.NAME);
    } 
    names.add(name);
  }

  /**
   * Checks the dates for any invalid calendar dates, and creates relevant DateTime objects.
   * 
   * @return DateTime                           DateTime object containing all date and time info.
   * @throws IllegalCommandArgumentException
   */
  public DateTime createDateTime() throws IllegalCommandArgumentException {
    DateTime dateTime = null;
    if (containsStartDate && containsStartTime && containsEndDate && containsEndTime) {
      dateTime = new DateTime(startDate, startTime, endDate, endTime);
      checkStartEndDate(startDate, endDate, dateTime);
    } else if (containsStartDate && containsStartTime && containsEndTime) {
      dateTime = new DateTime(startDate, startTime, endTime);
      checkEndDate(startDate, dateTime);
    } else if (containsStartDate && containsStartTime) {
      dateTime = new DateTime(startDate, startTime);
      checkEndDate(startDate, dateTime);
    } else if (containsStartDate && containsEndDate) {
      dateTime = new DateTime(startDate, currentTime, endDate, "2359");
      checkStartEndDate(startDate, endDate, dateTime);
    } else if (containsStartDate) {
      dateTime = new DateTime(startDate);
      checkEndDate(startDate, dateTime);
    } else if (containsStartTime && containsEndTime) {
      dateTime = new DateTime(currentDate, startTime, endTime);
    } else if (containsStartTime) {
      dateTime = new DateTime(currentDate, startTime);
    }
    return dateTime;
  }

  /**
   * Checks parseType before determining the type of format used for Date.
   * Formats both date and time input to a format that can be used for DateTime parsing.
   */
  public void formatDateTime() {
    // Check if type of parsing is for display or not. 
    // If it is for display, no need to check if date has already passed.
    if (parseType != 2) {
      startDate = dtFormat.formatDate(startDate,0);
      endDate = dtFormat.formatDate(endDate,0);
    } else {
      startDate = dtFormat.formatDate(startDate,1);
      endDate = dtFormat.formatDate(endDate,1);
    }
    
    startTime = dtFormat.formatTime(startTime);
    endTime = dtFormat.formatTime(endTime);
  }

  /**
   * Checks the word for any end time input.
   * 
   * @param i       Index of string input array.
   * @throws IllegalCommandArgumentException
   */
  public void checkForEndTimeInput(int i) throws IllegalCommandArgumentException {
    if (wordsOfInput[i].toLowerCase().matches(timePattern)) {
      containsEndTime = true;
      endTime = wordsOfInput[i];
    } else {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_INVALID_ENDTIME,
          Constants.CommandParam.DATETIME); 
    }
  }
  
  /**
   * Method that checks if start and end date exists on the calendar.
   * 
   * @param startDate       Start date in dd/mm/yyyy format.
   * @param endDate         End date in dd/mm/yyyy format.
   * @param dateTime        DateTime object created from both startDate & endDate.
   * @throws                IllegalCommandArgumentException
   */
  public void checkStartEndDate(String startDate, String endDate, DateTime dateTime)
      throws IllegalCommandArgumentException {
    int startDay = Integer.parseInt(startDate.split(dateOperator)[0]);
    int endDay = Integer.parseInt(endDate.split(dateOperator)[0]);
    if (dateTime.getStartDate().getDayOfMonth() != startDay ||
        dateTime.getEndDate().getDayOfMonth() != endDay) {
      throw new IllegalCommandArgumentException(
          Constants.FEEDBACK_INVALID_DATE, Constants.CommandParam.DATETIME);
    }
  }
  
  /**
   * Method that checks if start date exists on the calendar.
   * 
   * @param endDate         End date in dd/mm/yyyy format.
   * @param dateTime        DateTime object created from startDate.
   * @throws                IllegalCommandArgumentException
   */
  public void checkEndDate(String endDate, DateTime dateTime)
      throws IllegalCommandArgumentException {
    int startDay = Integer.parseInt(endDate.split(dateOperator)[0]);
    if (dateTime.getEndDate().getDayOfMonth() != startDay) {
      throw new IllegalCommandArgumentException(
          Constants.FEEDBACK_INVALID_DATE, Constants.CommandParam.DATETIME);
    }
  }
  
}
```
###### src\main\raijin\logic\parser\DateTimeFormat.java
``` java
package raijin.logic.parser;

import java.text.DecimalFormat;
import java.time.LocalDate;

import raijin.common.datatypes.Constants;

public class DateTimeFormat {
  public DateTimeFormat() {
    
  }
  
  /**
   * Method that formats date into the proper dd/mm/yyyy format.
   * Date will be assumed to be next year if (year isn't input) & (current date is later).
   * Assumption: Date string has already been checked to be valid.
   * 
   * @param date    date String that hasn't been formatted.
   * @param type    Type of formatting: 0 for add/edit, 1 for display
   * @return        Date string formatted to proper dd/mm/yyyy format.  
   */
  public String formatDate(String date, int type) {
    if (date.length() == 0) {
      return date;
    }
    DecimalFormat twoDigits = new DecimalFormat("00");
    String[] dayMonth = date.split(Constants.DATE_OPERATOR);
    String[] months = Constants.MONTHS;
    
    int day = Integer.parseInt(dayMonth[0]);
    int month = 0;
    int year;
    
    // Check for month written in letters
    for (int i = 0; i < months.length; i++) {
      if (dayMonth[1].toLowerCase().equals(months[i])) {
        month = i+1;
      }
    }
    if (month == 0) {
      month = Integer.parseInt(dayMonth[1]);
    }
    
    int dayNow = LocalDate.now().getDayOfMonth();
    int monthNow = LocalDate.now().getMonthValue();
    
    // Check for year input. If no year input, use existing year or the upcoming one.
    if (dayMonth.length == 3) {
      year = Integer.parseInt(dayMonth[2]);
      if (dayMonth[2].length() < 4) {
        year += 2000; // ASSUMPTION: This app is used within the year of 2000 to 2999.
      }
    } else if (type == 0 && (month < monthNow || (month == monthNow && day < dayNow))) {
      year = LocalDate.now().getYear() + 1;
    } else {
      year = LocalDate.now().getYear();
    }
    
    
    return twoDigits.format(day) + "/" + twoDigits.format(month) + "/" + year;
  }
  
  /**
   * Method that formats time to a proper format that will allow LocalTime parsing.
   * Checks whether it is 12/24hr formatting before proceeding.
   * 
   * @param time    String of time input by user.
   * @return        The proper time format after formatting the string input.     
   */
  public String formatTime(String time) {
    if (time.matches(Constants.TIME12_PATTERN)) {
      return format12HourTime(time);
      
    } else if (time.length() == 3) {
      if (time.charAt(0) == '0') {
        // Assuming the String time starts with "00" as it passed the format matching already.
        time += "0";
      } else {
        time = "0" + time;
      }
    }

    return time;
  }
  
  
  public String format12HourTime(String time) {
    String time24 = "";
    int oprIndex = time.indexOf(":") > 0 ? time.indexOf(":") : time.indexOf(".");
    boolean isPM = time.contains("p");
    
    if (oprIndex == -1) {
      int periodIndex = time.indexOf("p") > 0 ? time.indexOf("p") : time.indexOf("a");
      if (periodIndex == 1) {
        int hour = Integer.parseInt(time.substring(0,1));
        if (isPM) {
          time24 = (hour+12) + "00";
        } else {
          time24 = "0" + hour + "00";
        }
      } else {
        int hour = Integer.parseInt(time.substring(0,2));
        if (isPM) {
          time24 = hour == 12 ? "1200" : (hour+12) + "00";
        } else {
          time24 = hour == 12 ? "0000" : hour + "00";
        }
      }
    } else if (oprIndex == 1) {
      time24 += isPM ? Integer.parseInt(time.substring(0,1))+12 : "0" + time.charAt(0);
      time24 += time.substring(2,4);
    } else if (oprIndex == 2) {
      int hour = Integer.parseInt(time.substring(0,2));
      if (isPM) {
        time24 += hour == 12 ? "12" : (hour+12) ;
        time24 += time.substring(3,5);
      } else {
        time24 = "";
        time24 += hour == 12 ? "00" : hour ;
        time24 += time.substring(3,5);
      }
    }
    
    return time24;
  }
}
```
###### src\main\raijin\logic\parser\DeleteParser.java
``` java
package raijin.logic.parser;

import java.util.TreeSet;

import raijin.common.datatypes.Constants;
import raijin.common.exception.IllegalCommandArgumentException;

public class DeleteParser {
  
  private String[] wordsOfInput;
  private ParsedInput.ParsedInputBuilder builder;
  private TreeSet<String> tags; 
  
  public DeleteParser(String[] wordsOfInput) {
    this.wordsOfInput = wordsOfInput;
    builder = new ParsedInput.ParsedInputBuilder(Constants.Command.DELETE);
    tags = new TreeSet<String>();
  }
  
  /**
   * Method that deletes a task based on the taskID input by user.
   * 
   * @return    ParsedInputBuilder                  Appropriate ParsedInputBuilders accordingly.
   * @throws    IllegalCommandArgumentException
   */
  public ParsedInput.ParsedInputBuilder process() throws IllegalCommandArgumentException {
    if (wordsOfInput.length < 2) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_NO_TASK_ID,
          Constants.CommandParam.ID);
    }
    
    for (int i = 1; i < wordsOfInput.length; i++) {
      try {
        builder.id(Integer.parseInt(wordsOfInput[i]));
      } catch (NumberFormatException e) {
        tags.add(wordsOfInput[i]);
      } 
    }
    
    return builder.tag(tags);
  }
}
```
###### src\main\raijin\logic\parser\DisplayParser.java
``` java
package raijin.logic.parser;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.exception.IllegalCommandArgumentException;

public class DisplayParser {

  private static final String datePattern = Constants.DATE_PATTERN;
  private static final DateTimeFormat dtFormat = new DateTimeFormat();
  
  private String[] wordsOfInput;
  private ParsedInput.ParsedInputBuilder builder;
  
  public DisplayParser(String[] wordsOfInput) {
    this.wordsOfInput = wordsOfInput;
    builder = new ParsedInput.ParsedInputBuilder(Constants.Command.DISPLAY);
  }
  
  /**
   * Method that parses display type input by user and responds accordingly.
   * Currently allows for "p", "c", "a", "o", "f" or dates for its options.
   * 
   * @returns   ParsedInputBuilder                  Appropriate ParsedInputBuilders accordingly.
   * @throws    IllegalCommandArgumentException
   */
  public ParsedInput.ParsedInputBuilder process() throws IllegalCommandArgumentException {  

    int indexOfDate = 0;
    String displayType = "p";
    boolean containsDate = false;
    
    for (int i = 0; i < wordsOfInput.length; i++) {   
      if (wordsOfInput[i].matches(datePattern) && !containsDate) {
        indexOfDate = i;
        containsDate = true;
      } else if (wordsOfInput[i].matches("completed|done|c")) {
        displayType = "c";
      } else if (wordsOfInput[i].matches("all|everything|a")) {
        displayType = "a";
      } else if (wordsOfInput[i].matches("due|expired|o|overdue")) {
        displayType = "o";
      } else if (wordsOfInput[i].matches("floating|f")) {
        displayType = "f";
      } 
    }
    
    // If date input exists, add date preposition inside so as to make use of AddParser's parsing.
    if (indexOfDate > 0) {
      addDateStartPreposition(indexOfDate);
    }
    
    ParsedInput parsed = new AddParser(builder, wordsOfInput, 2).process().createParsedInput();
    
    return builder.displayOptions(displayType).dateTime(parsed.getDateTime());
  }
  
  public void addDateStartPreposition(int indexOfDate) {
    String[] newWordsOfInput = new String[wordsOfInput.length+1];
    newWordsOfInput[0] = "display";
    for (int i = 1; i < indexOfDate; i++) {
      newWordsOfInput[i] = wordsOfInput[i];
    }
    
    newWordsOfInput[indexOfDate] = "by";
    
    for (int i = indexOfDate+1; i < newWordsOfInput.length; i++) {
      newWordsOfInput[i] = wordsOfInput[i-1];
    }
    wordsOfInput = newWordsOfInput;
  }
}
```
###### src\main\raijin\logic\parser\DoneParser.java
``` java
package raijin.logic.parser;

import java.util.TreeSet;

import raijin.common.datatypes.Constants;
import raijin.common.exception.IllegalCommandArgumentException;

public class DoneParser {
  
  private String[] wordsOfInput;
  private ParsedInput.ParsedInputBuilder builder;
  private TreeSet<String> tags; 
  
  public DoneParser(String[] wordsOfInput) {
    this.wordsOfInput = wordsOfInput;
    builder = new ParsedInput.ParsedInputBuilder(Constants.Command.DONE);
    tags = new TreeSet<String>();
  }
  
  /**
   * Method that marks a task as done based on taskID input by user.
   * 
   * @returns   ParsedInputBuilder                  Appropriate ParsedInputBuilders accordingly.
   * @throws    IllegalCommandArgumentException
   */
  public ParsedInput.ParsedInputBuilder process() throws IllegalCommandArgumentException {
    if (wordsOfInput.length < 2) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_NO_TASK_ID,
          Constants.CommandParam.ID);
    }
    
    for (int i = 1; i < wordsOfInput.length; i++) {
      try {
        builder.id(Integer.parseInt(wordsOfInput[i]));
      } catch (NumberFormatException e) {
        tags.add(wordsOfInput[i]);
      } 
    }
    return builder.tag(tags);
  }
}
```
###### src\main\raijin\logic\parser\EditParser.java
``` java
package raijin.logic.parser;

import raijin.common.datatypes.Constants;
import raijin.common.exception.IllegalCommandArgumentException;

public class EditParser {
  
  private int id;
  private String[] wordsOfInput;
  private ParsedInput.ParsedInputBuilder builder;
  
  public EditParser(ParsedInput.ParsedInputBuilder builder, String[] wordsOfInput) {
    this.wordsOfInput = wordsOfInput;
    this.builder = builder;
  }
  
  /**
   * Method that parses the input for any modification users want to make for a specific task.
   * Able to modify name, date, or time.
   * 
   * @return    ParsedInputBuilder                  Appropriate ParsedInputBuilders accordingly.
   * @throws    IllegalCommandArgumentException
   */
  public ParsedInput.ParsedInputBuilder process() throws IllegalCommandArgumentException {
    try {
      id = Integer.parseInt(wordsOfInput[1]);
    } catch (NumberFormatException e) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_INVALID_ID,
          Constants.CommandParam.ID);
    } catch (ArrayIndexOutOfBoundsException e) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_NO_TASK_ID,
          Constants.CommandParam.ID);
    }
    
    // Deletes taskID from wordsOfInput and makes use of parseAddTask() method.
    extractID();
    return new AddParser(builder, wordsOfInput, 1).process().id(id);
  }

  public void extractID() {
    String[] newWordsOfInput = new String[wordsOfInput.length-1];
    newWordsOfInput[0] = "edit";
    for (int i = 1; i < newWordsOfInput.length; i++) {
      newWordsOfInput[i] = wordsOfInput[i+1];
    }
    wordsOfInput = newWordsOfInput;
  }
  
}
```
###### src\main\raijin\logic\parser\SearchParser.java
``` java

package raijin.logic.parser;

import java.util.TreeSet;

import raijin.common.datatypes.Constants;
import raijin.common.exception.IllegalCommandArgumentException;

public class SearchParser {
  
  private ParsedInput.ParsedInputBuilder builder;
  private String[] wordsOfInput;
  private TreeSet<Integer> ids;
  private TreeSet<String> tags;
  private String keywords;
 
  public SearchParser(String[] wordsOfInput) {
    builder = new ParsedInput.ParsedInputBuilder(Constants.Command.SEARCH);
    this.wordsOfInput = wordsOfInput;
    ids = new TreeSet<Integer>();
    tags = new TreeSet<String>();
    keywords = "";
  }
  
  public ParsedInput.ParsedInputBuilder process() throws IllegalCommandArgumentException {
    if (wordsOfInput.length < 2) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_NO_KEYWORDS,
          Constants.CommandParam.NAME);
    }
    
    for (int i = 1; i < wordsOfInput.length; i++) {
      if (wordsOfInput[i].matches("!h|!l|!m")) {
        builder.priority(wordsOfInput[i].substring(1));
      } else if (wordsOfInput[i].indexOf("#") == 0) {
        tags.add(wordsOfInput[i].substring(1));
      } else { 
        try {
          ids.add(Integer.parseInt(wordsOfInput[i]));
          keywords += wordsOfInput[i] + " ";
        } catch (NumberFormatException e) {
          keywords += wordsOfInput[i] + " ";
        }
      }
    }
    
    return builder.name(keywords.trim()).id(ids).tag(tags);
  }
}
```
###### src\main\raijin\logic\parser\SetParser.java
``` java

package raijin.logic.parser;

import raijin.common.datatypes.Constants;
import raijin.common.exception.IllegalCommandArgumentException;

public class SetParser {

  private String[] wordsOfInput;
  private ParsedInput.ParsedInputBuilder builder;
  
  public SetParser(String[] wordsOfInput) {
    this.wordsOfInput = wordsOfInput;
    builder = new ParsedInput.ParsedInputBuilder(Constants.Command.SET);
  }
  
  public ParsedInput.ParsedInputBuilder process() throws IllegalCommandArgumentException {
    try {
      return builder.helperOption(wordsOfInput[1]);
    } catch (ArrayIndexOutOfBoundsException e) {
      throw new IllegalCommandArgumentException(Constants.FEEDBACK_NO_FILEPATH,
          Constants.CommandParam.HELPEROPTION);
    }
  }
}
```
###### src\main\raijin\logic\parser\SimpleParser.java
``` java
package raijin.logic.parser;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.exception.IllegalCommandException;
import raijin.common.exception.IllegalCommandArgumentException;
import raijin.common.exception.FailedToParseException;

public class SimpleParser implements ParserInterface {
  
  private String[] wordsOfInput;
  private ParsedInput.ParsedInputBuilder builder;
  
  /**
   * Parses the user's input and creates corresponding ParsedInput object.
   * 
   * @param userInput   String of user input into the system.
   * @return            ParsedInput object based on user input.
   * @throws Exception  When invalid input is detected.
   */
  public ParsedInput parse(String userInput) throws FailedToParseException {
    wordsOfInput = userInput.trim().split("\\s+");
    
    try {
      if (isFirstWord("add|\\+")) {
        builder = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD);
        builder = new AddParser(builder, wordsOfInput, 0).process();
      } else if (isFirstWord("edit|change")) {
        builder = new ParsedInput.ParsedInputBuilder(Constants.Command.EDIT);
        builder = new EditParser(builder, wordsOfInput).process();
      } else if (isFirstWord("delete|del")) {
        builder = new DeleteParser(wordsOfInput).process();
      } else if (isFirstWord("done|finish")) {
        builder = new DoneParser(wordsOfInput).process();
      } else if (isFirstWord("display|show")) {
        builder = new DisplayParser(wordsOfInput).process();
      } else if (isFirstWord("help")) { //TODO: Specific help commands.
        builder = new ParsedInput.ParsedInputBuilder(Constants.Command.HELP);
      } else if (isFirstWord("undo")) {
        builder = new ParsedInput.ParsedInputBuilder(Constants.Command.UNDO);
      } else if (isFirstWord("redo")) {
        builder = new ParsedInput.ParsedInputBuilder(Constants.Command.REDO);
      } else if (isFirstWord("exit")) {
        builder = new ParsedInput.ParsedInputBuilder(Constants.Command.EXIT);
      } else if (isFirstWord("set")) {
        builder = new SetParser(wordsOfInput).process();
      } else if (isFirstWord("search|find")) {
        builder = new SearchParser(wordsOfInput).process();
      } else {
        throw new IllegalCommandException(Constants.FEEDBACK_INVALID_CMD, wordsOfInput[0]);
      }
    } catch (IllegalCommandException e1) {
      throw new FailedToParseException(e1.getMessage(), userInput, e1);
    } catch (IllegalCommandArgumentException e2) {
      throw new FailedToParseException(e2.getMessage(), userInput, e2);
    }
     
    return builder.createParsedInput();
  }
  
  /**
   * Method that checks first String of String array for a particular word.
   * 
   * @param word    Word to check for in the first element of array.
   * @return        boolean true or false whether it contains the word.
   */
  public boolean isFirstWord(String word) {
    return wordsOfInput[0].toLowerCase().matches(word);
  }
  
}
```
###### src\test\raijin\logic\command\DeleteCommandRunnerTest.java
``` java
  @Test
  public void processCommand_DeleteMultipleTasks() throws UnableToExecuteCommandException { 
    addTask("Burn burn baby", new DateTime("31/08/2015"));
    addTask("Chill Chill baby", new DateTime("31/08/2015"));
    TreeSet<Integer> ids = new TreeSet<Integer>();
    ids.add(1); ids.add(2); ids.add(3);
    Status returnStatus = deleteTaskIDS(ids);
    String expectedStatusLine = String.format(Constants.FEEDBACK_DELETE_SUCCESS, "Ice ice "
        + "baby") +"\n"+ String.format(Constants.FEEDBACK_DELETE_SUCCESS, "Burn burn baby") 
        +"\n"+ String.format(Constants.FEEDBACK_DELETE_SUCCESS, "Chill Chill baby") +"\n";
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
    assertTrue(tasksManager.isEmptyPendingTasks());
  }

  @Test
  public void undo_DeleteMultipleTasks() 
      throws UnableToExecuteCommandException, NoSuchTaskException {
    addTask("Burn burn baby", new DateTime("31/08/2015"));
    addTask("Chill Chill baby", new DateTime("31/08/2015"));
    TreeSet<Integer> ids = new TreeSet<Integer>();
    ids.add(1); ids.add(2); ids.add(3);
    deleteTaskIDS(ids);
    deleteCommandRunner.undo();
    assertTrue(!tasksManager.isEmptyPendingTasks());
    assertEquals("Ice ice baby", tasksManager.getPendingTask(1).getName());
    assertEquals("Burn burn baby", tasksManager.getPendingTask(2).getName());
    assertEquals("Chill Chill baby", tasksManager.getPendingTask(3).getName());
  }

  @Test
  public void redo_DeleteMultipleTasks() 
      throws UnableToExecuteCommandException, NoSuchTaskException {
    addTask("Burn burn baby", new DateTime("31/08/2015"));
    addTask("Chill Chill baby", new DateTime("31/08/2015"));
    TreeSet<Integer> ids = new TreeSet<Integer>();
    ids.add(1); ids.add(2); ids.add(3);
    deleteTaskIDS(ids);
    deleteCommandRunner.undo();
    deleteCommandRunner.redo();
    assertTrue(tasksManager.isEmptyPendingTasks());
  }
}
```
###### src\test\raijin\logic\command\EditCommandRunnerTest.java
``` java
package raijin.logic.command;

import static org.junit.Assert.*;

import java.util.HashMap;
import java.util.TreeSet;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.datatypes.Status;
import raijin.common.datatypes.Task;
import raijin.common.exception.FailedToParseException;
import raijin.common.exception.NoSuchTaskException;
import raijin.common.exception.UnableToExecuteCommandException;
import raijin.common.utils.IDManager;
import raijin.logic.parser.ParsedInput;
import raijin.logic.parser.SimpleParser;
import raijin.storage.api.TasksManager;

public class EditCommandRunnerTest {

  private SimpleParser parser;
  private AddCommandRunner addCommandRunner;
  private EditCommandRunner editCommandRunner;
  private TasksManager tasksManager;

  @Before
  public void setUp() throws Exception {
    parser = new SimpleParser();
    addCommandRunner = new AddCommandRunner();
    editCommandRunner = new EditCommandRunner();
    tasksManager = TasksManager.getManager();
    tasksManager.setPendingTasks(new HashMap<Integer, Task>());
    IDManager.getIdManager().flushIdPool();
    addTask("First entry.", new DateTime("03/10/2015"), "h", "work");
  }

  @Test
  public void execute_EditTaskName() throws UnableToExecuteCommandException, NoSuchTaskException {
    Status returnStatus = editTask(1, "First entry changed.", null);
    String expectedStatusLine = String.format(Constants.FEEDBACK_EDIT_SUCCESS, 
        "First entry changed.");
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
    assertEquals("First entry changed.", tasksManager.getPendingTask(1).getName());
  }

  @Test
  public void execute_EditTaskDate() throws NoSuchTaskException, UnableToExecuteCommandException {
    Status returnStatus = editTask(1, null, new DateTime("05/10/2015"));
    String expectedStatusLine = String.format(Constants.FEEDBACK_EDIT_SUCCESS, 
        "First entry.");
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
    assertEquals("2015-10-05", tasksManager.getPendingTask(1).getDateTime()
        .getStartDate().toString());
  }

  @Test
  public void execute_EditTaskNameDate() 
      throws NoSuchTaskException, UnableToExecuteCommandException, FailedToParseException {
    ParsedInput input = parser.parse("edit 1 First entry changed again. by 5/10");
    Status returnStatus = editCommandRunner.execute(input);
    String expectedStatusLine = String.format(Constants.FEEDBACK_EDIT_SUCCESS, 
        "First entry changed again.");
    assertEquals(expectedStatusLine, returnStatus.getFeedback());
    assertEquals("First entry changed again.", tasksManager.getPendingTask(1).getName());
    assertEquals("2016-10-05", tasksManager.getPendingTask(1).getDateTime()
        .getEndDate().toString());
    assertEquals("h", tasksManager.getPendingTask(1).getPriority());
    assertEquals("work", tasksManager.getPendingTask(1).getTags().pollFirst());
  }

  @Test
  public void execute_EditTaskPriorityTag() 
      throws UnableToExecuteCommandException, NoSuchTaskException, FailedToParseException {
    Status returnStatus = editCommandRunner.execute(parser.parse("edit 1 !l #school"));
    assertEquals(String.format(Constants.FEEDBACK_EDIT_SUCCESS, "First entry.")
        , returnStatus.getFeedback());
    assertEquals("l", tasksManager.getPendingTask(1).getPriority());
    assertEquals("school", tasksManager.getPendingTask(1).getTags().pollFirst());
  }

  @Test
  public void undo_EditTaskNameDate() throws NoSuchTaskException, UnableToExecuteCommandException {
    editTask(1, "First entry changed.", new DateTime("05/10/2015"));
    editCommandRunner.undo();
    assertEquals("First entry.", tasksManager.getPendingTask(1).getName());
    assertEquals("2015-10-03", tasksManager.getPendingTask(1).getDateTime()
        .getStartDate().toString());
  }

  @Test
  public void redo_EditTaskNameDate() throws NoSuchTaskException, UnableToExecuteCommandException {
    editTask(1, "First entry changed.", new DateTime("05/10/2015"));
    editCommandRunner.undo();
    editCommandRunner.redo();
    assertEquals("First entry changed.", tasksManager.getPendingTask(1).getName());
    assertEquals("2015-10-05", tasksManager.getPendingTask(1).getDateTime()
        .getStartDate().toString());
  }

  //===========================================================================
  // Helper methods
  //===========================================================================

  public Status addTask(String inputName, DateTime dateTime, String priority, String tag)
      throws UnableToExecuteCommandException {
    ParsedInput parsedInput = createSpecificTask(inputName, dateTime, priority, tag);
    Status returnStatus = addCommandRunner.execute(parsedInput);
    return returnStatus;
  }

  public ParsedInput createSpecificTask(String inputName, DateTime dateTime, String priority,
      String tag) {
    TreeSet<String> tags = new TreeSet<String>();
    tags.add(tag);
    return new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name(inputName).dateTime(dateTime).priority(priority)
        .tag(tags).createParsedInput();
  }

  public Status editTask(int id, String inputName, DateTime dateTime) 
      throws NoSuchTaskException, UnableToExecuteCommandException {
    ParsedInput parsedInput;
    if (inputName == null) {
      parsedInput = modifyTaskDate(id, dateTime);
    } else if (dateTime == null) {
      parsedInput = modifyTaskName(id, inputName);
    } else {
      parsedInput = modifyTaskNameDate(id, inputName, dateTime);
    }
    return editCommandRunner.execute(parsedInput);
  }

  public ParsedInput modifyTaskName(int id, String inputName) {
    return new ParsedInput.ParsedInputBuilder(Constants.Command.EDIT).
        id(id).name(inputName).createParsedInput();
  }

  public ParsedInput modifyTaskDate(int id, DateTime dateTime) {
    return new ParsedInput.ParsedInputBuilder(Constants.Command.EDIT).
        id(id).dateTime(dateTime).createParsedInput();
  }

  public ParsedInput modifyTaskNameDate(int id, String inputName, DateTime dateTime) {
    return new ParsedInput.ParsedInputBuilder(Constants.Command.EDIT).
        id(id).name(inputName).dateTime(dateTime).createParsedInput();
  }
}
```
###### src\test\raijin\logic\parser\AddParserTest.java
``` java

package raijin.logic.parser;

import static org.junit.Assert.*;

import java.time.LocalDate;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.Constants;
import raijin.common.datatypes.DateTime;
import raijin.common.exception.FailedToParseException;
import raijin.common.exception.IllegalCommandArgumentException;

public class AddParserTest {

  private SimpleParser parser;
  private AddParser addParser;
  private ParsedInput addCommand;
  private ParsedInput.ParsedInputBuilder builder;
  
  @Before
  public void setUp() throws IllegalCommandArgumentException {
    parser = new SimpleParser();
    builder = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD);
    String[] wordsOfInput = new String("add testing").split(" ");
    addParser = new AddParser(builder, wordsOfInput, 0);
  }
  
  @Test
  public void testAddWithStandardDate() throws FailedToParseException {
    addCommand = parser.parse("add finish parser by 26/12/2015");
    assertEquals("finish parser", addCommand.getName());
    assertEquals("2015-12-26", addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void testAddWithInformalDate() throws FailedToParseException {
    /* This is a boundary case for the ‘exact value’ partition */
    addCommand = parser.parse("add finish something by 28/2");
    assertEquals("finish something", addCommand.getName());
    assertEquals("2016-02-28", addCommand.getDateTime().getStartDate().toString());

    addCommand = parser.parse("add finish something at 1-1");
    assertEquals("finish something", addCommand.getName());
    assertEquals("2016-01-01", addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void testAddWithDifferentDateTimeInputs() throws FailedToParseException{
    addCommand = parser.parse("add finish something by 27/12/15 000");
    assertEquals("finish something", addCommand.getName());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals("00:00", addCommand.getDateTime().getEndTime().toString());
    
    addCommand = parser.parse("add finish something from 27.deC to 28-12");
    assertEquals("finish something", addCommand.getName());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals("2015-12-28", addCommand.getDateTime().getEndDate().toString());
    
    /* This is a boundary case for the ‘exact value’ partition */
    addCommand = parser.parse("add attend something from 27.dec 000 till 2359");
    assertEquals("attend something", addCommand.getName());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals("00:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("23:59", addCommand.getDateTime().getEndTime().toString());
    
    addCommand = parser.parse("add finish something from 0800 to 0900");
    assertEquals("finish something", addCommand.getName());
    assertEquals("08:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("09:00", addCommand.getDateTime().getEndTime().toString());
  }
  
  @Test
  public void testAddWithPriorityAndTagsAfterTimeline() throws FailedToParseException {
    addCommand = parser.parse("add finish work from 0800 to 0900 !h #work #school");
    assertEquals("finish work", addCommand.getName());
    assertEquals("08:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("09:00", addCommand.getDateTime().getEndTime().toString());
    assertEquals(Constants.PRIORITY_HIGH, addCommand.getPriority());
    assertEquals("school", addCommand.getTags().pollFirst());
    assertEquals("work", addCommand.getTags().pollFirst());
  }
  
  @Test
  public void testAddWithPriorityAndTagsBeforeEvent() throws FailedToParseException {
    addCommand = parser.parse("add finish work !h #work #school from 27/12 0800 to 27/12 0900");
    assertEquals("finish work", addCommand.getName());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals("2015-12-27", addCommand.getDateTime().getEndDate().toString());
    assertEquals("08:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("09:00", addCommand.getDateTime().getEndTime().toString());
    assertEquals(Constants.PRIORITY_HIGH, addCommand.getPriority());
    assertEquals("school", addCommand.getTags().pollFirst());
    assertEquals("work", addCommand.getTags().pollFirst());
  }
  
  @Test
  public void testAddWithPriorityAndTagsAfterEvent() throws FailedToParseException {
    addCommand = parser.parse("add finish work from 27/12 0800 to 27/12 0900 !h #work #school");
    assertEquals("finish work", addCommand.getName());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals("2015-12-27", addCommand.getDateTime().getEndDate().toString());
    assertEquals("08:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("09:00", addCommand.getDateTime().getEndTime().toString());
    assertEquals(Constants.PRIORITY_HIGH, addCommand.getPriority());
    assertEquals("school", addCommand.getTags().pollFirst());
    assertEquals("work", addCommand.getTags().pollFirst());
  }
  
  @Test
  public void testAddSubtasking() throws FailedToParseException {
    addCommand = parser.parse("add finish work @3");
    assertEquals("finish work", addCommand.getName());
    assertEquals(3, addCommand.getSubTaskOf());
  }
  
  @Test
  public void testAddWithTagsPriorityAfterOneDate() throws FailedToParseException {
    addCommand = parser.parse("add finish work by 27/12 !h #work");
    assertEquals("finish work", addCommand.getName());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals(Constants.PRIORITY_HIGH, addCommand.getPriority());
    assertEquals("work", addCommand.getTags().pollFirst());
  }
  
  @Test
  public void testAddWithTagsPriorityAfterOneDateAndTimeline() throws FailedToParseException {
    addCommand = parser.parse("add finish work from 27/12 1800 to 2000 !h #work");
    assertEquals("finish work", addCommand.getName());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals("18:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("20:00", addCommand.getDateTime().getEndTime().toString());
    assertEquals(Constants.PRIORITY_HIGH, addCommand.getPriority());
    assertEquals("work", addCommand.getTags().pollFirst());
  }
  
  @Test
  public void testBatchAdding() throws FailedToParseException {
    addCommand = parser.parse("add finish work ; do more work ; do somemore!");
    assertEquals("do more work", addCommand.getNames().pollFirst());
    assertEquals("do somemore!", addCommand.getNames().pollFirst());
    assertEquals("finish work", addCommand.getNames().pollFirst());
  }
  
  @Test
  public void testBatchAddWithDates() throws FailedToParseException {
    addCommand = parser.parse("add finish work by 24/12 ; do more work ; do somemore!");
    assertEquals("do more work", addCommand.getNames().pollFirst());
    assertEquals("do somemore!", addCommand.getNames().pollFirst());
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals("2015-12-24", addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void testBatchAddWithDatesAtEnd() throws FailedToParseException {
    addCommand = parser.parse("add finish work ; do more work ; do somemore! by 27/12");
    assertEquals("do more work", addCommand.getNames().pollFirst());
    assertEquals("do somemore!", addCommand.getNames().pollFirst());
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void testAddWithProject() throws FailedToParseException {
    addCommand = parser.parse("add finish work by 27/12 $cs2103t");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
    assertEquals("cs2103t", addCommand.getProject());
  }
  
  @Test
  public void testAddWithDelimiters() throws FailedToParseException {
    addCommand = parser.parse("add finish work /by 27/12 /#YOLO by 27/12");
    assertEquals("finish work by 27/12 #YOLO", addCommand.getNames().pollFirst());
    assertEquals("2015-12-27", addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void testAddWith12HrTime() throws FailedToParseException {
    addCommand = parser.parse("add finish work by 6am to 10.30p");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals("06:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("22:30", addCommand.getDateTime().getEndTime().toString());
  }
  
  @Test
  public void testAddWithToday() throws FailedToParseException {
    addCommand = parser.parse("add finish work by today 10am - 11pm");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals(LocalDate.now().toString(), addCommand.getDateTime().getStartDate().toString());
    assertEquals("10:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("23:00", addCommand.getDateTime().getEndTime().toString());
  }
  
  @Test
  public void testAddWithTomorrow() throws FailedToParseException {
    addCommand = parser.parse("add finish work by tmr 8:00am - 11:00am");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals(LocalDate.now().plusDays(1).toString(), 
        addCommand.getDateTime().getStartDate().toString());
    assertEquals("08:00", addCommand.getDateTime().getStartTime().toString());
    assertEquals("11:00", addCommand.getDateTime().getEndTime().toString());
  }
  
  //@Test // This test input needs constant changes as it changes according to current date.
  public void testAddWithDayOfWeek() throws FailedToParseException {
    addCommand = parser.parse("add finish work by tues");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals("2015-11-10", addCommand.getDateTime().getStartDate().toString());
  }
  
  //@Test // This test input needs constant changes as it changes according to current date.
  public void testAddWithDayOfNext() throws FailedToParseException {
    addCommand = parser.parse("add finish work by next sun 12.10pm to 9.59pm");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    assertEquals("2015-11-15", addCommand.getDateTime().getStartDate().toString());
    assertEquals("12:10", addCommand.getDateTime().getStartTime().toString());
    assertEquals("21:59", addCommand.getDateTime().getEndTime().toString());
  }
  
  @Test
  public void testAddWithDayOfNextWeek() throws FailedToParseException {
    addCommand = parser.parse("add finish work by next week");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    LocalDate exptDate = LocalDate.now().plusWeeks(1);
    assertEquals(exptDate.toString(), addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void testAddWithDayOfNextMonth() throws FailedToParseException {
    addCommand = parser.parse("add finish work by next mth");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    LocalDate exptDate = LocalDate.now().plusMonths(1);
    assertEquals(exptDate.toString(), addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void testAddWithDayOfNextYear() throws FailedToParseException {
    addCommand = parser.parse("add finish work by next yr");
    assertEquals("finish work", addCommand.getNames().pollFirst());
    LocalDate exptDate = LocalDate.now().plusYears(1);
    assertEquals(exptDate.toString(), addCommand.getDateTime().getStartDate().toString());
  }
  
  @Test(expected=IllegalCommandArgumentException.class)
  public void testNoNameGivenError() throws IllegalCommandArgumentException {
    new AddParser(builder, new String("add").split(" "), 0).process();
  }
  
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidSubTaskInput() throws IllegalCommandArgumentException {
    new AddParser(builder, new String("add work @a").split(" "), 0).process();
  }
  
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidPriorityInput() throws IllegalCommandArgumentException {
    new AddParser(builder, new String("add work !a").split(" "), 0).process();
  }
  
  /* This is a boundary case for the ‘negative value’ partition */
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidStartTimeFormat() throws IllegalCommandArgumentException {
    new AddParser(builder, new String("add finish something by 27-DEC 0").split(" "), 0).process();
  }
  
  /* This is a boundary case for the ‘negative value’ partition */
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidEndDateAfterStartDate() throws IllegalCommandArgumentException {
    String[] wordsOfInput = new String("add finish something from 27-DEC to 0/1").split(" ");
    new AddParser(builder, wordsOfInput, 0).process();
  }
  
  /* This is a boundary case for the ‘positive value’ partition */
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidEndTimeAfterStartTime() throws IllegalCommandArgumentException {
    String[] wordsOfInput = new String("add finish something from 1800 to 2500").split(" ");
    new AddParser(builder, wordsOfInput, 0).process();
  }
  
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidEndDateAfterStartDateTime() throws IllegalCommandArgumentException {
    String[] wordsOfInput = new String("add finish something from 27-DEC 1800 to 0/1").split(" ");
    new AddParser(builder, wordsOfInput, 0).process();
  }
  
  /* This is a boundary case for the ‘negative value’ partition */
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidEndTimeAfterStartDateTime() throws IllegalCommandArgumentException {
    String[] wordsOfInput = new String("add finish something from 27-DEC 1800 to 00").split(" ");
    new AddParser(builder, wordsOfInput, 0).process();
  }
  
  /* This is a boundary case for the ‘negative value’ partition */
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidEndTimeAfterStartDateTimeEndDate() throws IllegalCommandArgumentException {
    String[] wordsOfInput = new String
        ("add finish something from 27-DEC 1800 to 28.12 00").split(" ");
    new AddParser(builder, wordsOfInput, 0).process();
  }
  
  /* This is a boundary case for the ‘positive value’ partition */
  @Test(expected=IllegalCommandArgumentException.class)
  public void testCheckStartDate() throws IllegalCommandArgumentException {
    addParser.checkEndDate("30/02/2015", new DateTime("30/02/2015"));
  }
  
  /* This is a boundary case for the ‘positive value’ partition */
  @Test(expected=IllegalCommandArgumentException.class)
  public void testCheckStartEndDate() throws IllegalCommandArgumentException {
    addParser.checkStartEndDate("29/02/2015", "30/02/2015", 
        new DateTime("29/02/2015", "0800", "30/02/2015", "1000"));
  }

}
```
###### src\test\raijin\logic\parser\DisplayParserTest.java
``` java
package raijin.logic.parser;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import raijin.common.exception.FailedToParseException;

public class DisplayParserTest {

  private SimpleParser parser;
  private ParsedInput displayCommand;
  
  @Before
  public void init() {
    parser = new SimpleParser();
  }
  
  @Test
  public void testDefaultDisplay() throws FailedToParseException {
    displayCommand = parser.parse("display");
    assertEquals("p", displayCommand.getDisplayOptions());
  }
  
  @Test
  public void parseDisplayDate() throws FailedToParseException {
    displayCommand = parser.parse("display 1.1");
    assertEquals("p", displayCommand.getDisplayOptions());
    assertEquals("2015-01-01", displayCommand.getDateTime().getStartDate().toString());
    
    displayCommand = parser.parse("display 30/10");
    assertEquals("p", displayCommand.getDisplayOptions());
    assertEquals("2015-10-30", displayCommand.getDateTime().getStartDate().toString());

  }
  
  @Test(expected=FailedToParseException.class)
  public void parseDisplayNonExistentDate() throws FailedToParseException {
    displayCommand = parser.parse("display 30-feb");
    assertEquals("p", displayCommand.getDisplayOptions());
    assertEquals("2015-02-28", displayCommand.getDateTime().getStartDate().toString());
  }
  
  @Test
  public void parseDisplayStartEndDate() throws FailedToParseException {
    displayCommand = parser.parse("display o 30/10 to 5/11");
    assertEquals("o", displayCommand.getDisplayOptions());
    assertEquals("2015-10-30", displayCommand.getDateTime().getStartDate().toString());
    assertEquals("2015-11-05", displayCommand.getDateTime().getEndDate().toString());
  }
  
  @Test
  public void parseDisplayStartEndDateTime() throws FailedToParseException {
    displayCommand = parser.parse("display 30/10 0800 to 5/11 900 c");
    assertEquals("c", displayCommand.getDisplayOptions());
    assertEquals("2015-10-30", displayCommand.getDateTime().getStartDate().toString());
    assertEquals("2015-11-05", displayCommand.getDateTime().getEndDate().toString());
    assertEquals("08:00", displayCommand.getDateTime().getStartTime().toString());
    assertEquals("09:00", displayCommand.getDateTime().getEndTime().toString());
  }
  
  @Test
  public void parseDisplayCompleted() throws FailedToParseException {
    displayCommand = parser.parse("display c 19/9");
    assertEquals("c", displayCommand.getDisplayOptions());
    assertEquals("2015-09-19", displayCommand.getDateTime().getStartDate().toString());
    
    displayCommand = parser.parse("display completed 19/9");
    assertEquals("c", displayCommand.getDisplayOptions());
    assertEquals("2015-09-19", displayCommand.getDateTime().getStartDate().toString());
  }

  @Test
  public void parseDisplayAll() throws FailedToParseException {
    displayCommand = parser.parse("display a");
    assertEquals("a", displayCommand.getDisplayOptions());
    displayCommand = parser.parse("display all");
    assertEquals("a", displayCommand.getDisplayOptions());
  }
  
  @Test
  public void parseDisplayPending() throws FailedToParseException {
    displayCommand = parser.parse("display p");
    assertEquals("p", displayCommand.getDisplayOptions());
    displayCommand = parser.parse("display today");
    assertEquals("p", displayCommand.getDisplayOptions());
  }
  
  @Test
  public void parseDisplayFloating() throws FailedToParseException {
    displayCommand = parser.parse("display f");
    assertEquals("f", displayCommand.getDisplayOptions());
    displayCommand = parser.parse("display floating");
    assertEquals("f", displayCommand.getDisplayOptions());
  }
  
  @Test
  public void parseDisplayOverdue() throws FailedToParseException {
    displayCommand = parser.parse("display o");
    assertEquals("o", displayCommand.getDisplayOptions());
    displayCommand = parser.parse("display overdue");
    assertEquals("o", displayCommand.getDisplayOptions());
  }
  
}
```
###### src\test\raijin\logic\parser\EditParserTest.java
``` java
package raijin.logic.parser;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import raijin.common.datatypes.Constants;
import raijin.common.exception.IllegalCommandArgumentException;

public class EditParserTest {

  private ParsedInput.ParsedInputBuilder builder;
  private String[] wordsOfInput;
  
  @Before
  public void setUp() {
    builder = new ParsedInput.ParsedInputBuilder(Constants.Command.EDIT);
  }
  
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidTaskNumberInput() throws IllegalCommandArgumentException {
    wordsOfInput = new String("edit something").split(" ");
    new EditParser(builder, wordsOfInput).process();
  }
  
  @Test(expected=IllegalCommandArgumentException.class)
  public void testInvalidInput() throws IllegalCommandArgumentException {
    wordsOfInput = new String("edit").split(" ");
    new EditParser(builder, wordsOfInput).process();
  }
  
  @Test
  public void testBasicEditing() throws IllegalCommandArgumentException {
    wordsOfInput = new String("edit 1 something by 28/12").split(" ");
    ParsedInput parsed = new EditParser(builder, wordsOfInput).process().createParsedInput();
    assertEquals(1, parsed.getId());
    assertEquals("something", parsed.getName());
    assertEquals(1, parsed.getId());
    assertEquals("2015-12-28", parsed.getDateTime().getStartDate().toString());
  }
}
```
###### src\test\raijin\logic\parser\ParsedInputTest.java
``` java
  @Test
  public void parseAddCommandInSimpleParser() throws FailedToParseException {
    ParsedInput editCommand = parser.parse("+ full test from 1/1 800 to 12/5 000");
    assertEquals("full test", editCommand.getName());
    assertEquals("2016-01-01", editCommand.getDateTime().getStartDate().toString());
    assertEquals("08:00", editCommand.getDateTime().getStartTime().toString());
    assertEquals("2016-05-12", editCommand.getDateTime().getEndDate().toString());
    assertEquals("00:00", editCommand.getDateTime().getEndTime().toString());
  }
  
  @Test
  public void parseEditCommandInSimpleParser() throws FailedToParseException {
    ParsedInput editCommand = parser.parse("change 1 full test from 1/1 800 to 12/5 000");
    assertEquals(1, editCommand.getId());
    assertEquals("full test", editCommand.getName());
    assertEquals("2016-01-01", editCommand.getDateTime().getStartDate().toString());
    assertEquals("08:00", editCommand.getDateTime().getStartTime().toString());
    assertEquals("2016-05-12", editCommand.getDateTime().getEndDate().toString());
    assertEquals("00:00", editCommand.getDateTime().getEndTime().toString());
  }
  
  @Test
  public void parseDeleteCommandInSimpleParser() throws FailedToParseException {
    ParsedInput deleteCommand = parser.parse("del 12");
    assertEquals(12, deleteCommand.getId());
    
    deleteCommand = parser.parse("delete 1 work 2 school 3 ");
    assertEquals(1, deleteCommand.getIds().pollFirst().intValue());
    assertEquals(2, deleteCommand.getIds().pollFirst().intValue());
    assertEquals(3, deleteCommand.getIds().pollFirst().intValue());
    assertEquals("school", deleteCommand.getTags().pollFirst());
    assertEquals("work", deleteCommand.getTags().pollFirst());
  }
  
  @Test
  public void parseDoneCommandInSimpleParser() throws FailedToParseException {
    ParsedInput doneCommand = parser.parse("finish 28");
    assertEquals(28, doneCommand.getId());
    
    doneCommand = parser.parse("done 4 work 5 school 6");
    assertEquals(4, doneCommand.getIds().pollFirst().intValue());
    assertEquals(5, doneCommand.getIds().pollFirst().intValue());
    assertEquals(6, doneCommand.getIds().pollFirst().intValue());
    assertEquals("school", doneCommand.getTags().pollFirst());
    assertEquals("work", doneCommand.getTags().pollFirst());
  }

  @Test
  public void getPriority_ReturnPriority() {
    ParsedInput input = new ParsedInput.ParsedInputBuilder(Constants.Command.ADD).
        name("I am cute").createParsedInput();
    assertEquals(null, input.getPriority());
  }
  
  @Test(expected=FailedToParseException.class)
  public void testInvalidFilePathInput() throws FailedToParseException {
    parser.parse("set");
  }
  
  @Test(expected=FailedToParseException.class)
  public void testInvalidDeleteInput() throws FailedToParseException {
    parser.parse("delete");
  }
  
  @Test(expected=FailedToParseException.class)
  public void testInvalidDoneInput() throws FailedToParseException {
    parser.parse("done");
  }
  
  @Test(expected=FailedToParseException.class)
  public void testInvalidSearchInput() throws FailedToParseException {
    parser.parse("search");
  }
  
}
```
###### src\test\raijin\logic\parser\SearchParserTest.java
``` java
package raijin.logic.parser;

import static org.junit.Assert.*;

import org.junit.Before;
import org.junit.Test;

import raijin.common.exception.FailedToParseException;

public class SearchParserTest {

  private SimpleParser parser;
  private ParsedInput searchCommand;
  
  @Before
  public void init() {
    parser = new SimpleParser();
  }
  
  @Test
  public void testBasicSearch() throws FailedToParseException {
    searchCommand = parser.parse("search everything including 1 is included 4");
    assertEquals(1, searchCommand.getIds().pollFirst().intValue());
    assertEquals(4, searchCommand.getIds().pollFirst().intValue());
    assertEquals("everything including 1 is included 4", searchCommand.getName());
  }
  
  @Test
  public void testSearchWithTag() throws FailedToParseException {
    searchCommand = parser.parse("search everything including #work");
    assertEquals("everything including", searchCommand.getName());
    assertEquals("work", searchCommand.getTags().pollFirst());
  }
  
  @Test
  public void testSearchWithPriority() throws FailedToParseException {
    searchCommand = parser.parse("search everything that is !h");
    assertEquals("everything that is", searchCommand.getName());
    assertEquals("h", searchCommand.getPriority());
  }
  
  @Test
  public void testAdvancedSearch() throws FailedToParseException {
    searchCommand = parser.parse("search everything including 1 except !l and #school is included ");
    assertEquals(1, searchCommand.getIds().pollFirst().intValue());
    assertEquals("everything including 1 except and is included", searchCommand.getName());
    assertEquals("school", searchCommand.getTags().pollFirst());
    assertEquals("l", searchCommand.getPriority());
    
  }
}
```
